// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: services/timeline.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_services_2ftimeline_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_services_2ftimeline_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common/timestamp.pb.h"
#include "common/pagination.pb.h"
#include "services/note.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_services_2ftimeline_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_services_2ftimeline_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_services_2ftimeline_2eproto;
namespace sonet {
namespace timeline {
class GetTimelinePreferencesRequest;
struct GetTimelinePreferencesRequestDefaultTypeInternal;
extern GetTimelinePreferencesRequestDefaultTypeInternal _GetTimelinePreferencesRequest_default_instance_;
class GetTimelinePreferencesResponse;
struct GetTimelinePreferencesResponseDefaultTypeInternal;
extern GetTimelinePreferencesResponseDefaultTypeInternal _GetTimelinePreferencesResponse_default_instance_;
class GetTimelineRequest;
struct GetTimelineRequestDefaultTypeInternal;
extern GetTimelineRequestDefaultTypeInternal _GetTimelineRequest_default_instance_;
class GetTimelineResponse;
struct GetTimelineResponseDefaultTypeInternal;
extern GetTimelineResponseDefaultTypeInternal _GetTimelineResponse_default_instance_;
class GetUserTimelineRequest;
struct GetUserTimelineRequestDefaultTypeInternal;
extern GetUserTimelineRequestDefaultTypeInternal _GetUserTimelineRequest_default_instance_;
class GetUserTimelineResponse;
struct GetUserTimelineResponseDefaultTypeInternal;
extern GetUserTimelineResponseDefaultTypeInternal _GetUserTimelineResponse_default_instance_;
class HealthCheckRequest;
struct HealthCheckRequestDefaultTypeInternal;
extern HealthCheckRequestDefaultTypeInternal _HealthCheckRequest_default_instance_;
class HealthCheckResponse;
struct HealthCheckResponseDefaultTypeInternal;
extern HealthCheckResponseDefaultTypeInternal _HealthCheckResponse_default_instance_;
class HealthCheckResponse_DetailsEntry_DoNotUse;
struct HealthCheckResponse_DetailsEntry_DoNotUseDefaultTypeInternal;
extern HealthCheckResponse_DetailsEntry_DoNotUseDefaultTypeInternal _HealthCheckResponse_DetailsEntry_DoNotUse_default_instance_;
class MarkTimelineReadRequest;
struct MarkTimelineReadRequestDefaultTypeInternal;
extern MarkTimelineReadRequestDefaultTypeInternal _MarkTimelineReadRequest_default_instance_;
class MarkTimelineReadResponse;
struct MarkTimelineReadResponseDefaultTypeInternal;
extern MarkTimelineReadResponseDefaultTypeInternal _MarkTimelineReadResponse_default_instance_;
class RankingSignals;
struct RankingSignalsDefaultTypeInternal;
extern RankingSignalsDefaultTypeInternal _RankingSignals_default_instance_;
class RefreshTimelineRequest;
struct RefreshTimelineRequestDefaultTypeInternal;
extern RefreshTimelineRequestDefaultTypeInternal _RefreshTimelineRequest_default_instance_;
class RefreshTimelineResponse;
struct RefreshTimelineResponseDefaultTypeInternal;
extern RefreshTimelineResponseDefaultTypeInternal _RefreshTimelineResponse_default_instance_;
class SubscribeTimelineUpdatesRequest;
struct SubscribeTimelineUpdatesRequestDefaultTypeInternal;
extern SubscribeTimelineUpdatesRequestDefaultTypeInternal _SubscribeTimelineUpdatesRequest_default_instance_;
class TimelineItem;
struct TimelineItemDefaultTypeInternal;
extern TimelineItemDefaultTypeInternal _TimelineItem_default_instance_;
class TimelineMetadata;
struct TimelineMetadataDefaultTypeInternal;
extern TimelineMetadataDefaultTypeInternal _TimelineMetadata_default_instance_;
class TimelineMetadata_AlgorithmParamsEntry_DoNotUse;
struct TimelineMetadata_AlgorithmParamsEntry_DoNotUseDefaultTypeInternal;
extern TimelineMetadata_AlgorithmParamsEntry_DoNotUseDefaultTypeInternal _TimelineMetadata_AlgorithmParamsEntry_DoNotUse_default_instance_;
class TimelinePreferences;
struct TimelinePreferencesDefaultTypeInternal;
extern TimelinePreferencesDefaultTypeInternal _TimelinePreferences_default_instance_;
class TimelineUpdate;
struct TimelineUpdateDefaultTypeInternal;
extern TimelineUpdateDefaultTypeInternal _TimelineUpdate_default_instance_;
class UpdateTimelinePreferencesRequest;
struct UpdateTimelinePreferencesRequestDefaultTypeInternal;
extern UpdateTimelinePreferencesRequestDefaultTypeInternal _UpdateTimelinePreferencesRequest_default_instance_;
class UpdateTimelinePreferencesResponse;
struct UpdateTimelinePreferencesResponseDefaultTypeInternal;
extern UpdateTimelinePreferencesResponseDefaultTypeInternal _UpdateTimelinePreferencesResponse_default_instance_;
}  // namespace timeline
}  // namespace sonet
PROTOBUF_NAMESPACE_OPEN
template<> ::sonet::timeline::GetTimelinePreferencesRequest* Arena::CreateMaybeMessage<::sonet::timeline::GetTimelinePreferencesRequest>(Arena*);
template<> ::sonet::timeline::GetTimelinePreferencesResponse* Arena::CreateMaybeMessage<::sonet::timeline::GetTimelinePreferencesResponse>(Arena*);
template<> ::sonet::timeline::GetTimelineRequest* Arena::CreateMaybeMessage<::sonet::timeline::GetTimelineRequest>(Arena*);
template<> ::sonet::timeline::GetTimelineResponse* Arena::CreateMaybeMessage<::sonet::timeline::GetTimelineResponse>(Arena*);
template<> ::sonet::timeline::GetUserTimelineRequest* Arena::CreateMaybeMessage<::sonet::timeline::GetUserTimelineRequest>(Arena*);
template<> ::sonet::timeline::GetUserTimelineResponse* Arena::CreateMaybeMessage<::sonet::timeline::GetUserTimelineResponse>(Arena*);
template<> ::sonet::timeline::HealthCheckRequest* Arena::CreateMaybeMessage<::sonet::timeline::HealthCheckRequest>(Arena*);
template<> ::sonet::timeline::HealthCheckResponse* Arena::CreateMaybeMessage<::sonet::timeline::HealthCheckResponse>(Arena*);
template<> ::sonet::timeline::HealthCheckResponse_DetailsEntry_DoNotUse* Arena::CreateMaybeMessage<::sonet::timeline::HealthCheckResponse_DetailsEntry_DoNotUse>(Arena*);
template<> ::sonet::timeline::MarkTimelineReadRequest* Arena::CreateMaybeMessage<::sonet::timeline::MarkTimelineReadRequest>(Arena*);
template<> ::sonet::timeline::MarkTimelineReadResponse* Arena::CreateMaybeMessage<::sonet::timeline::MarkTimelineReadResponse>(Arena*);
template<> ::sonet::timeline::RankingSignals* Arena::CreateMaybeMessage<::sonet::timeline::RankingSignals>(Arena*);
template<> ::sonet::timeline::RefreshTimelineRequest* Arena::CreateMaybeMessage<::sonet::timeline::RefreshTimelineRequest>(Arena*);
template<> ::sonet::timeline::RefreshTimelineResponse* Arena::CreateMaybeMessage<::sonet::timeline::RefreshTimelineResponse>(Arena*);
template<> ::sonet::timeline::SubscribeTimelineUpdatesRequest* Arena::CreateMaybeMessage<::sonet::timeline::SubscribeTimelineUpdatesRequest>(Arena*);
template<> ::sonet::timeline::TimelineItem* Arena::CreateMaybeMessage<::sonet::timeline::TimelineItem>(Arena*);
template<> ::sonet::timeline::TimelineMetadata* Arena::CreateMaybeMessage<::sonet::timeline::TimelineMetadata>(Arena*);
template<> ::sonet::timeline::TimelineMetadata_AlgorithmParamsEntry_DoNotUse* Arena::CreateMaybeMessage<::sonet::timeline::TimelineMetadata_AlgorithmParamsEntry_DoNotUse>(Arena*);
template<> ::sonet::timeline::TimelinePreferences* Arena::CreateMaybeMessage<::sonet::timeline::TimelinePreferences>(Arena*);
template<> ::sonet::timeline::TimelineUpdate* Arena::CreateMaybeMessage<::sonet::timeline::TimelineUpdate>(Arena*);
template<> ::sonet::timeline::UpdateTimelinePreferencesRequest* Arena::CreateMaybeMessage<::sonet::timeline::UpdateTimelinePreferencesRequest>(Arena*);
template<> ::sonet::timeline::UpdateTimelinePreferencesResponse* Arena::CreateMaybeMessage<::sonet::timeline::UpdateTimelinePreferencesResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sonet {
namespace timeline {

enum TimelineUpdate_UpdateType : int {
  TimelineUpdate_UpdateType_UPDATE_TYPE_UNKNOWN = 0,
  TimelineUpdate_UpdateType_UPDATE_TYPE_NEW_ITEMS = 1,
  TimelineUpdate_UpdateType_UPDATE_TYPE_ITEM_UPDATED = 2,
  TimelineUpdate_UpdateType_UPDATE_TYPE_ITEM_DELETED = 3,
  TimelineUpdate_UpdateType_UPDATE_TYPE_BULK_REFRESH = 4,
  TimelineUpdate_UpdateType_TimelineUpdate_UpdateType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TimelineUpdate_UpdateType_TimelineUpdate_UpdateType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TimelineUpdate_UpdateType_IsValid(int value);
constexpr TimelineUpdate_UpdateType TimelineUpdate_UpdateType_UpdateType_MIN = TimelineUpdate_UpdateType_UPDATE_TYPE_UNKNOWN;
constexpr TimelineUpdate_UpdateType TimelineUpdate_UpdateType_UpdateType_MAX = TimelineUpdate_UpdateType_UPDATE_TYPE_BULK_REFRESH;
constexpr int TimelineUpdate_UpdateType_UpdateType_ARRAYSIZE = TimelineUpdate_UpdateType_UpdateType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TimelineUpdate_UpdateType_descriptor();
template<typename T>
inline const std::string& TimelineUpdate_UpdateType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TimelineUpdate_UpdateType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TimelineUpdate_UpdateType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TimelineUpdate_UpdateType_descriptor(), enum_t_value);
}
inline bool TimelineUpdate_UpdateType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TimelineUpdate_UpdateType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TimelineUpdate_UpdateType>(
    TimelineUpdate_UpdateType_descriptor(), name, value);
}
enum TimelineAlgorithm : int {
  TIMELINE_ALGORITHM_UNKNOWN = 0,
  TIMELINE_ALGORITHM_CHRONOLOGICAL = 1,
  TIMELINE_ALGORITHM_ALGORITHMIC = 2,
  TIMELINE_ALGORITHM_HYBRID = 3,
  TimelineAlgorithm_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TimelineAlgorithm_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TimelineAlgorithm_IsValid(int value);
constexpr TimelineAlgorithm TimelineAlgorithm_MIN = TIMELINE_ALGORITHM_UNKNOWN;
constexpr TimelineAlgorithm TimelineAlgorithm_MAX = TIMELINE_ALGORITHM_HYBRID;
constexpr int TimelineAlgorithm_ARRAYSIZE = TimelineAlgorithm_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TimelineAlgorithm_descriptor();
template<typename T>
inline const std::string& TimelineAlgorithm_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TimelineAlgorithm>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TimelineAlgorithm_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TimelineAlgorithm_descriptor(), enum_t_value);
}
inline bool TimelineAlgorithm_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TimelineAlgorithm* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TimelineAlgorithm>(
    TimelineAlgorithm_descriptor(), name, value);
}
enum ContentSource : int {
  CONTENT_SOURCE_UNKNOWN = 0,
  CONTENT_SOURCE_FOLLOWING = 1,
  CONTENT_SOURCE_TRENDING = 2,
  CONTENT_SOURCE_RECOMMENDED = 3,
  CONTENT_SOURCE_PROMOTED = 4,
  CONTENT_SOURCE_LISTS = 5,
  ContentSource_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ContentSource_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ContentSource_IsValid(int value);
constexpr ContentSource ContentSource_MIN = CONTENT_SOURCE_UNKNOWN;
constexpr ContentSource ContentSource_MAX = CONTENT_SOURCE_LISTS;
constexpr int ContentSource_ARRAYSIZE = ContentSource_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ContentSource_descriptor();
template<typename T>
inline const std::string& ContentSource_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ContentSource>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ContentSource_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ContentSource_descriptor(), enum_t_value);
}
inline bool ContentSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContentSource* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ContentSource>(
    ContentSource_descriptor(), name, value);
}
// ===================================================================

class RankingSignals final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.timeline.RankingSignals) */ {
 public:
  inline RankingSignals() : RankingSignals(nullptr) {}
  ~RankingSignals() override;
  explicit PROTOBUF_CONSTEXPR RankingSignals(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RankingSignals(const RankingSignals& from);
  RankingSignals(RankingSignals&& from) noexcept
    : RankingSignals() {
    *this = ::std::move(from);
  }

  inline RankingSignals& operator=(const RankingSignals& from) {
    CopyFrom(from);
    return *this;
  }
  inline RankingSignals& operator=(RankingSignals&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RankingSignals& default_instance() {
    return *internal_default_instance();
  }
  static inline const RankingSignals* internal_default_instance() {
    return reinterpret_cast<const RankingSignals*>(
               &_RankingSignals_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RankingSignals& a, RankingSignals& b) {
    a.Swap(&b);
  }
  inline void Swap(RankingSignals* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RankingSignals* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RankingSignals* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RankingSignals>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RankingSignals& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RankingSignals& from) {
    RankingSignals::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RankingSignals* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.timeline.RankingSignals";
  }
  protected:
  explicit RankingSignals(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthorAffinityScoreFieldNumber = 1,
    kContentQualityScoreFieldNumber = 2,
    kEngagementVelocityFieldNumber = 3,
    kRecencyScoreFieldNumber = 4,
    kPersonalizationScoreFieldNumber = 5,
    kDiversityScoreFieldNumber = 6,
    kIsReplyToFollowingFieldNumber = 7,
    kMutualFollowerInteractionsFieldNumber = 8,
  };
  // double author_affinity_score = 1;
  void clear_author_affinity_score();
  double author_affinity_score() const;
  void set_author_affinity_score(double value);
  private:
  double _internal_author_affinity_score() const;
  void _internal_set_author_affinity_score(double value);
  public:

  // double content_quality_score = 2;
  void clear_content_quality_score();
  double content_quality_score() const;
  void set_content_quality_score(double value);
  private:
  double _internal_content_quality_score() const;
  void _internal_set_content_quality_score(double value);
  public:

  // double engagement_velocity = 3;
  void clear_engagement_velocity();
  double engagement_velocity() const;
  void set_engagement_velocity(double value);
  private:
  double _internal_engagement_velocity() const;
  void _internal_set_engagement_velocity(double value);
  public:

  // double recency_score = 4;
  void clear_recency_score();
  double recency_score() const;
  void set_recency_score(double value);
  private:
  double _internal_recency_score() const;
  void _internal_set_recency_score(double value);
  public:

  // double personalization_score = 5;
  void clear_personalization_score();
  double personalization_score() const;
  void set_personalization_score(double value);
  private:
  double _internal_personalization_score() const;
  void _internal_set_personalization_score(double value);
  public:

  // double diversity_score = 6;
  void clear_diversity_score();
  double diversity_score() const;
  void set_diversity_score(double value);
  private:
  double _internal_diversity_score() const;
  void _internal_set_diversity_score(double value);
  public:

  // bool is_reply_to_following = 7;
  void clear_is_reply_to_following();
  bool is_reply_to_following() const;
  void set_is_reply_to_following(bool value);
  private:
  bool _internal_is_reply_to_following() const;
  void _internal_set_is_reply_to_following(bool value);
  public:

  // int32 mutual_follower_interactions = 8;
  void clear_mutual_follower_interactions();
  int32_t mutual_follower_interactions() const;
  void set_mutual_follower_interactions(int32_t value);
  private:
  int32_t _internal_mutual_follower_interactions() const;
  void _internal_set_mutual_follower_interactions(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.timeline.RankingSignals)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double author_affinity_score_;
    double content_quality_score_;
    double engagement_velocity_;
    double recency_score_;
    double personalization_score_;
    double diversity_score_;
    bool is_reply_to_following_;
    int32_t mutual_follower_interactions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2ftimeline_2eproto;
};
// -------------------------------------------------------------------

class TimelineItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.timeline.TimelineItem) */ {
 public:
  inline TimelineItem() : TimelineItem(nullptr) {}
  ~TimelineItem() override;
  explicit PROTOBUF_CONSTEXPR TimelineItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimelineItem(const TimelineItem& from);
  TimelineItem(TimelineItem&& from) noexcept
    : TimelineItem() {
    *this = ::std::move(from);
  }

  inline TimelineItem& operator=(const TimelineItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimelineItem& operator=(TimelineItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimelineItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimelineItem* internal_default_instance() {
    return reinterpret_cast<const TimelineItem*>(
               &_TimelineItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TimelineItem& a, TimelineItem& b) {
    a.Swap(&b);
  }
  inline void Swap(TimelineItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimelineItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimelineItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimelineItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TimelineItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TimelineItem& from) {
    TimelineItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimelineItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.timeline.TimelineItem";
  }
  protected:
  explicit TimelineItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInjectionReasonFieldNumber = 6,
    kNoteFieldNumber = 1,
    kRankingSignalsFieldNumber = 3,
    kInjectedAtFieldNumber = 4,
    kSourceFieldNumber = 2,
    kPositionInTimelineFieldNumber = 7,
    kFinalScoreFieldNumber = 5,
  };
  // string injection_reason = 6;
  void clear_injection_reason();
  const std::string& injection_reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_injection_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_injection_reason();
  PROTOBUF_NODISCARD std::string* release_injection_reason();
  void set_allocated_injection_reason(std::string* injection_reason);
  private:
  const std::string& _internal_injection_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_injection_reason(const std::string& value);
  std::string* _internal_mutable_injection_reason();
  public:

  // .sonet.note.Note note = 1;
  bool has_note() const;
  private:
  bool _internal_has_note() const;
  public:
  void clear_note();
  const ::sonet::note::Note& note() const;
  PROTOBUF_NODISCARD ::sonet::note::Note* release_note();
  ::sonet::note::Note* mutable_note();
  void set_allocated_note(::sonet::note::Note* note);
  private:
  const ::sonet::note::Note& _internal_note() const;
  ::sonet::note::Note* _internal_mutable_note();
  public:
  void unsafe_arena_set_allocated_note(
      ::sonet::note::Note* note);
  ::sonet::note::Note* unsafe_arena_release_note();

  // .sonet.timeline.RankingSignals ranking_signals = 3;
  bool has_ranking_signals() const;
  private:
  bool _internal_has_ranking_signals() const;
  public:
  void clear_ranking_signals();
  const ::sonet::timeline::RankingSignals& ranking_signals() const;
  PROTOBUF_NODISCARD ::sonet::timeline::RankingSignals* release_ranking_signals();
  ::sonet::timeline::RankingSignals* mutable_ranking_signals();
  void set_allocated_ranking_signals(::sonet::timeline::RankingSignals* ranking_signals);
  private:
  const ::sonet::timeline::RankingSignals& _internal_ranking_signals() const;
  ::sonet::timeline::RankingSignals* _internal_mutable_ranking_signals();
  public:
  void unsafe_arena_set_allocated_ranking_signals(
      ::sonet::timeline::RankingSignals* ranking_signals);
  ::sonet::timeline::RankingSignals* unsafe_arena_release_ranking_signals();

  // .sonet.common.Timestamp injected_at = 4;
  bool has_injected_at() const;
  private:
  bool _internal_has_injected_at() const;
  public:
  void clear_injected_at();
  const ::sonet::common::Timestamp& injected_at() const;
  PROTOBUF_NODISCARD ::sonet::common::Timestamp* release_injected_at();
  ::sonet::common::Timestamp* mutable_injected_at();
  void set_allocated_injected_at(::sonet::common::Timestamp* injected_at);
  private:
  const ::sonet::common::Timestamp& _internal_injected_at() const;
  ::sonet::common::Timestamp* _internal_mutable_injected_at();
  public:
  void unsafe_arena_set_allocated_injected_at(
      ::sonet::common::Timestamp* injected_at);
  ::sonet::common::Timestamp* unsafe_arena_release_injected_at();

  // .sonet.timeline.ContentSource source = 2;
  void clear_source();
  ::sonet::timeline::ContentSource source() const;
  void set_source(::sonet::timeline::ContentSource value);
  private:
  ::sonet::timeline::ContentSource _internal_source() const;
  void _internal_set_source(::sonet::timeline::ContentSource value);
  public:

  // int32 position_in_timeline = 7;
  void clear_position_in_timeline();
  int32_t position_in_timeline() const;
  void set_position_in_timeline(int32_t value);
  private:
  int32_t _internal_position_in_timeline() const;
  void _internal_set_position_in_timeline(int32_t value);
  public:

  // double final_score = 5;
  void clear_final_score();
  double final_score() const;
  void set_final_score(double value);
  private:
  double _internal_final_score() const;
  void _internal_set_final_score(double value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.timeline.TimelineItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr injection_reason_;
    ::sonet::note::Note* note_;
    ::sonet::timeline::RankingSignals* ranking_signals_;
    ::sonet::common::Timestamp* injected_at_;
    int source_;
    int32_t position_in_timeline_;
    double final_score_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2ftimeline_2eproto;
};
// -------------------------------------------------------------------

class TimelineMetadata_AlgorithmParamsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TimelineMetadata_AlgorithmParamsEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TimelineMetadata_AlgorithmParamsEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> SuperType;
  TimelineMetadata_AlgorithmParamsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR TimelineMetadata_AlgorithmParamsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TimelineMetadata_AlgorithmParamsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TimelineMetadata_AlgorithmParamsEntry_DoNotUse& other);
  static const TimelineMetadata_AlgorithmParamsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TimelineMetadata_AlgorithmParamsEntry_DoNotUse*>(&_TimelineMetadata_AlgorithmParamsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "sonet.timeline.TimelineMetadata.AlgorithmParamsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_services_2ftimeline_2eproto;
};

// -------------------------------------------------------------------

class TimelineMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.timeline.TimelineMetadata) */ {
 public:
  inline TimelineMetadata() : TimelineMetadata(nullptr) {}
  ~TimelineMetadata() override;
  explicit PROTOBUF_CONSTEXPR TimelineMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimelineMetadata(const TimelineMetadata& from);
  TimelineMetadata(TimelineMetadata&& from) noexcept
    : TimelineMetadata() {
    *this = ::std::move(from);
  }

  inline TimelineMetadata& operator=(const TimelineMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimelineMetadata& operator=(TimelineMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimelineMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimelineMetadata* internal_default_instance() {
    return reinterpret_cast<const TimelineMetadata*>(
               &_TimelineMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TimelineMetadata& a, TimelineMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(TimelineMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimelineMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimelineMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimelineMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TimelineMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TimelineMetadata& from) {
    TimelineMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimelineMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.timeline.TimelineMetadata";
  }
  protected:
  explicit TimelineMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kAlgorithmParamsFieldNumber = 7,
    kTimelineVersionFieldNumber = 6,
    kLastUpdatedFieldNumber = 3,
    kLastUserReadFieldNumber = 4,
    kTotalItemsFieldNumber = 1,
    kNewItemsSinceLastFetchFieldNumber = 2,
    kAlgorithmUsedFieldNumber = 5,
  };
  // map<string, double> algorithm_params = 7;
  int algorithm_params_size() const;
  private:
  int _internal_algorithm_params_size() const;
  public:
  void clear_algorithm_params();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_algorithm_params() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_algorithm_params();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      algorithm_params() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_algorithm_params();

  // string timeline_version = 6;
  void clear_timeline_version();
  const std::string& timeline_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_timeline_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_timeline_version();
  PROTOBUF_NODISCARD std::string* release_timeline_version();
  void set_allocated_timeline_version(std::string* timeline_version);
  private:
  const std::string& _internal_timeline_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timeline_version(const std::string& value);
  std::string* _internal_mutable_timeline_version();
  public:

  // .sonet.common.Timestamp last_updated = 3;
  bool has_last_updated() const;
  private:
  bool _internal_has_last_updated() const;
  public:
  void clear_last_updated();
  const ::sonet::common::Timestamp& last_updated() const;
  PROTOBUF_NODISCARD ::sonet::common::Timestamp* release_last_updated();
  ::sonet::common::Timestamp* mutable_last_updated();
  void set_allocated_last_updated(::sonet::common::Timestamp* last_updated);
  private:
  const ::sonet::common::Timestamp& _internal_last_updated() const;
  ::sonet::common::Timestamp* _internal_mutable_last_updated();
  public:
  void unsafe_arena_set_allocated_last_updated(
      ::sonet::common::Timestamp* last_updated);
  ::sonet::common::Timestamp* unsafe_arena_release_last_updated();

  // .sonet.common.Timestamp last_user_read = 4;
  bool has_last_user_read() const;
  private:
  bool _internal_has_last_user_read() const;
  public:
  void clear_last_user_read();
  const ::sonet::common::Timestamp& last_user_read() const;
  PROTOBUF_NODISCARD ::sonet::common::Timestamp* release_last_user_read();
  ::sonet::common::Timestamp* mutable_last_user_read();
  void set_allocated_last_user_read(::sonet::common::Timestamp* last_user_read);
  private:
  const ::sonet::common::Timestamp& _internal_last_user_read() const;
  ::sonet::common::Timestamp* _internal_mutable_last_user_read();
  public:
  void unsafe_arena_set_allocated_last_user_read(
      ::sonet::common::Timestamp* last_user_read);
  ::sonet::common::Timestamp* unsafe_arena_release_last_user_read();

  // int32 total_items = 1;
  void clear_total_items();
  int32_t total_items() const;
  void set_total_items(int32_t value);
  private:
  int32_t _internal_total_items() const;
  void _internal_set_total_items(int32_t value);
  public:

  // int32 new_items_since_last_fetch = 2;
  void clear_new_items_since_last_fetch();
  int32_t new_items_since_last_fetch() const;
  void set_new_items_since_last_fetch(int32_t value);
  private:
  int32_t _internal_new_items_since_last_fetch() const;
  void _internal_set_new_items_since_last_fetch(int32_t value);
  public:

  // .sonet.timeline.TimelineAlgorithm algorithm_used = 5;
  void clear_algorithm_used();
  ::sonet::timeline::TimelineAlgorithm algorithm_used() const;
  void set_algorithm_used(::sonet::timeline::TimelineAlgorithm value);
  private:
  ::sonet::timeline::TimelineAlgorithm _internal_algorithm_used() const;
  void _internal_set_algorithm_used(::sonet::timeline::TimelineAlgorithm value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.timeline.TimelineMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        TimelineMetadata_AlgorithmParamsEntry_DoNotUse,
        std::string, double,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> algorithm_params_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr timeline_version_;
    ::sonet::common::Timestamp* last_updated_;
    ::sonet::common::Timestamp* last_user_read_;
    int32_t total_items_;
    int32_t new_items_since_last_fetch_;
    int algorithm_used_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2ftimeline_2eproto;
};
// -------------------------------------------------------------------

class TimelinePreferences final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.timeline.TimelinePreferences) */ {
 public:
  inline TimelinePreferences() : TimelinePreferences(nullptr) {}
  ~TimelinePreferences() override;
  explicit PROTOBUF_CONSTEXPR TimelinePreferences(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimelinePreferences(const TimelinePreferences& from);
  TimelinePreferences(TimelinePreferences&& from) noexcept
    : TimelinePreferences() {
    *this = ::std::move(from);
  }

  inline TimelinePreferences& operator=(const TimelinePreferences& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimelinePreferences& operator=(TimelinePreferences&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimelinePreferences& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimelinePreferences* internal_default_instance() {
    return reinterpret_cast<const TimelinePreferences*>(
               &_TimelinePreferences_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TimelinePreferences& a, TimelinePreferences& b) {
    a.Swap(&b);
  }
  inline void Swap(TimelinePreferences* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimelinePreferences* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimelinePreferences* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimelinePreferences>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TimelinePreferences& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TimelinePreferences& from) {
    TimelinePreferences::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimelinePreferences* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.timeline.TimelinePreferences";
  }
  protected:
  explicit TimelinePreferences(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMutedKeywordsFieldNumber = 7,
    kMutedUsersFieldNumber = 8,
    kPreferredLanguagesFieldNumber = 9,
    kPreferredAlgorithmFieldNumber = 1,
    kShowRepliesFieldNumber = 2,
    kShowRenotesFieldNumber = 3,
    kShowRecommendedContentFieldNumber = 4,
    kShowTrendingContentFieldNumber = 5,
    kSensitiveContentWarningFieldNumber = 6,
    kTimelineRefreshMinutesFieldNumber = 10,
  };
  // repeated string muted_keywords = 7;
  int muted_keywords_size() const;
  private:
  int _internal_muted_keywords_size() const;
  public:
  void clear_muted_keywords();
  const std::string& muted_keywords(int index) const;
  std::string* mutable_muted_keywords(int index);
  void set_muted_keywords(int index, const std::string& value);
  void set_muted_keywords(int index, std::string&& value);
  void set_muted_keywords(int index, const char* value);
  void set_muted_keywords(int index, const char* value, size_t size);
  std::string* add_muted_keywords();
  void add_muted_keywords(const std::string& value);
  void add_muted_keywords(std::string&& value);
  void add_muted_keywords(const char* value);
  void add_muted_keywords(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& muted_keywords() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_muted_keywords();
  private:
  const std::string& _internal_muted_keywords(int index) const;
  std::string* _internal_add_muted_keywords();
  public:

  // repeated string muted_users = 8;
  int muted_users_size() const;
  private:
  int _internal_muted_users_size() const;
  public:
  void clear_muted_users();
  const std::string& muted_users(int index) const;
  std::string* mutable_muted_users(int index);
  void set_muted_users(int index, const std::string& value);
  void set_muted_users(int index, std::string&& value);
  void set_muted_users(int index, const char* value);
  void set_muted_users(int index, const char* value, size_t size);
  std::string* add_muted_users();
  void add_muted_users(const std::string& value);
  void add_muted_users(std::string&& value);
  void add_muted_users(const char* value);
  void add_muted_users(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& muted_users() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_muted_users();
  private:
  const std::string& _internal_muted_users(int index) const;
  std::string* _internal_add_muted_users();
  public:

  // repeated string preferred_languages = 9;
  int preferred_languages_size() const;
  private:
  int _internal_preferred_languages_size() const;
  public:
  void clear_preferred_languages();
  const std::string& preferred_languages(int index) const;
  std::string* mutable_preferred_languages(int index);
  void set_preferred_languages(int index, const std::string& value);
  void set_preferred_languages(int index, std::string&& value);
  void set_preferred_languages(int index, const char* value);
  void set_preferred_languages(int index, const char* value, size_t size);
  std::string* add_preferred_languages();
  void add_preferred_languages(const std::string& value);
  void add_preferred_languages(std::string&& value);
  void add_preferred_languages(const char* value);
  void add_preferred_languages(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& preferred_languages() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_preferred_languages();
  private:
  const std::string& _internal_preferred_languages(int index) const;
  std::string* _internal_add_preferred_languages();
  public:

  // .sonet.timeline.TimelineAlgorithm preferred_algorithm = 1;
  void clear_preferred_algorithm();
  ::sonet::timeline::TimelineAlgorithm preferred_algorithm() const;
  void set_preferred_algorithm(::sonet::timeline::TimelineAlgorithm value);
  private:
  ::sonet::timeline::TimelineAlgorithm _internal_preferred_algorithm() const;
  void _internal_set_preferred_algorithm(::sonet::timeline::TimelineAlgorithm value);
  public:

  // bool show_replies = 2;
  void clear_show_replies();
  bool show_replies() const;
  void set_show_replies(bool value);
  private:
  bool _internal_show_replies() const;
  void _internal_set_show_replies(bool value);
  public:

  // bool show_renotes = 3;
  void clear_show_renotes();
  bool show_renotes() const;
  void set_show_renotes(bool value);
  private:
  bool _internal_show_renotes() const;
  void _internal_set_show_renotes(bool value);
  public:

  // bool show_recommended_content = 4;
  void clear_show_recommended_content();
  bool show_recommended_content() const;
  void set_show_recommended_content(bool value);
  private:
  bool _internal_show_recommended_content() const;
  void _internal_set_show_recommended_content(bool value);
  public:

  // bool show_trending_content = 5;
  void clear_show_trending_content();
  bool show_trending_content() const;
  void set_show_trending_content(bool value);
  private:
  bool _internal_show_trending_content() const;
  void _internal_set_show_trending_content(bool value);
  public:

  // bool sensitive_content_warning = 6;
  void clear_sensitive_content_warning();
  bool sensitive_content_warning() const;
  void set_sensitive_content_warning(bool value);
  private:
  bool _internal_sensitive_content_warning() const;
  void _internal_set_sensitive_content_warning(bool value);
  public:

  // int32 timeline_refresh_minutes = 10;
  void clear_timeline_refresh_minutes();
  int32_t timeline_refresh_minutes() const;
  void set_timeline_refresh_minutes(int32_t value);
  private:
  int32_t _internal_timeline_refresh_minutes() const;
  void _internal_set_timeline_refresh_minutes(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.timeline.TimelinePreferences)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> muted_keywords_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> muted_users_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> preferred_languages_;
    int preferred_algorithm_;
    bool show_replies_;
    bool show_renotes_;
    bool show_recommended_content_;
    bool show_trending_content_;
    bool sensitive_content_warning_;
    int32_t timeline_refresh_minutes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2ftimeline_2eproto;
};
// -------------------------------------------------------------------

class TimelineUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.timeline.TimelineUpdate) */ {
 public:
  inline TimelineUpdate() : TimelineUpdate(nullptr) {}
  ~TimelineUpdate() override;
  explicit PROTOBUF_CONSTEXPR TimelineUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimelineUpdate(const TimelineUpdate& from);
  TimelineUpdate(TimelineUpdate&& from) noexcept
    : TimelineUpdate() {
    *this = ::std::move(from);
  }

  inline TimelineUpdate& operator=(const TimelineUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimelineUpdate& operator=(TimelineUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimelineUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimelineUpdate* internal_default_instance() {
    return reinterpret_cast<const TimelineUpdate*>(
               &_TimelineUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TimelineUpdate& a, TimelineUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(TimelineUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimelineUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimelineUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimelineUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TimelineUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TimelineUpdate& from) {
    TimelineUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimelineUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.timeline.TimelineUpdate";
  }
  protected:
  explicit TimelineUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TimelineUpdate_UpdateType UpdateType;
  static constexpr UpdateType UPDATE_TYPE_UNKNOWN =
    TimelineUpdate_UpdateType_UPDATE_TYPE_UNKNOWN;
  static constexpr UpdateType UPDATE_TYPE_NEW_ITEMS =
    TimelineUpdate_UpdateType_UPDATE_TYPE_NEW_ITEMS;
  static constexpr UpdateType UPDATE_TYPE_ITEM_UPDATED =
    TimelineUpdate_UpdateType_UPDATE_TYPE_ITEM_UPDATED;
  static constexpr UpdateType UPDATE_TYPE_ITEM_DELETED =
    TimelineUpdate_UpdateType_UPDATE_TYPE_ITEM_DELETED;
  static constexpr UpdateType UPDATE_TYPE_BULK_REFRESH =
    TimelineUpdate_UpdateType_UPDATE_TYPE_BULK_REFRESH;
  static inline bool UpdateType_IsValid(int value) {
    return TimelineUpdate_UpdateType_IsValid(value);
  }
  static constexpr UpdateType UpdateType_MIN =
    TimelineUpdate_UpdateType_UpdateType_MIN;
  static constexpr UpdateType UpdateType_MAX =
    TimelineUpdate_UpdateType_UpdateType_MAX;
  static constexpr int UpdateType_ARRAYSIZE =
    TimelineUpdate_UpdateType_UpdateType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  UpdateType_descriptor() {
    return TimelineUpdate_UpdateType_descriptor();
  }
  template<typename T>
  static inline const std::string& UpdateType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, UpdateType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function UpdateType_Name.");
    return TimelineUpdate_UpdateType_Name(enum_t_value);
  }
  static inline bool UpdateType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      UpdateType* value) {
    return TimelineUpdate_UpdateType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNewItemsFieldNumber = 2,
    kUpdatedItemIdsFieldNumber = 3,
    kDeletedItemIdsFieldNumber = 4,
    kUpdateTimestampFieldNumber = 6,
    kTypeFieldNumber = 1,
    kTotalNewItemsFieldNumber = 5,
  };
  // repeated .sonet.timeline.TimelineItem new_items = 2;
  int new_items_size() const;
  private:
  int _internal_new_items_size() const;
  public:
  void clear_new_items();
  ::sonet::timeline::TimelineItem* mutable_new_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::timeline::TimelineItem >*
      mutable_new_items();
  private:
  const ::sonet::timeline::TimelineItem& _internal_new_items(int index) const;
  ::sonet::timeline::TimelineItem* _internal_add_new_items();
  public:
  const ::sonet::timeline::TimelineItem& new_items(int index) const;
  ::sonet::timeline::TimelineItem* add_new_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::timeline::TimelineItem >&
      new_items() const;

  // repeated string updated_item_ids = 3;
  int updated_item_ids_size() const;
  private:
  int _internal_updated_item_ids_size() const;
  public:
  void clear_updated_item_ids();
  const std::string& updated_item_ids(int index) const;
  std::string* mutable_updated_item_ids(int index);
  void set_updated_item_ids(int index, const std::string& value);
  void set_updated_item_ids(int index, std::string&& value);
  void set_updated_item_ids(int index, const char* value);
  void set_updated_item_ids(int index, const char* value, size_t size);
  std::string* add_updated_item_ids();
  void add_updated_item_ids(const std::string& value);
  void add_updated_item_ids(std::string&& value);
  void add_updated_item_ids(const char* value);
  void add_updated_item_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& updated_item_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_updated_item_ids();
  private:
  const std::string& _internal_updated_item_ids(int index) const;
  std::string* _internal_add_updated_item_ids();
  public:

  // repeated string deleted_item_ids = 4;
  int deleted_item_ids_size() const;
  private:
  int _internal_deleted_item_ids_size() const;
  public:
  void clear_deleted_item_ids();
  const std::string& deleted_item_ids(int index) const;
  std::string* mutable_deleted_item_ids(int index);
  void set_deleted_item_ids(int index, const std::string& value);
  void set_deleted_item_ids(int index, std::string&& value);
  void set_deleted_item_ids(int index, const char* value);
  void set_deleted_item_ids(int index, const char* value, size_t size);
  std::string* add_deleted_item_ids();
  void add_deleted_item_ids(const std::string& value);
  void add_deleted_item_ids(std::string&& value);
  void add_deleted_item_ids(const char* value);
  void add_deleted_item_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& deleted_item_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_deleted_item_ids();
  private:
  const std::string& _internal_deleted_item_ids(int index) const;
  std::string* _internal_add_deleted_item_ids();
  public:

  // .sonet.common.Timestamp update_timestamp = 6;
  bool has_update_timestamp() const;
  private:
  bool _internal_has_update_timestamp() const;
  public:
  void clear_update_timestamp();
  const ::sonet::common::Timestamp& update_timestamp() const;
  PROTOBUF_NODISCARD ::sonet::common::Timestamp* release_update_timestamp();
  ::sonet::common::Timestamp* mutable_update_timestamp();
  void set_allocated_update_timestamp(::sonet::common::Timestamp* update_timestamp);
  private:
  const ::sonet::common::Timestamp& _internal_update_timestamp() const;
  ::sonet::common::Timestamp* _internal_mutable_update_timestamp();
  public:
  void unsafe_arena_set_allocated_update_timestamp(
      ::sonet::common::Timestamp* update_timestamp);
  ::sonet::common::Timestamp* unsafe_arena_release_update_timestamp();

  // .sonet.timeline.TimelineUpdate.UpdateType type = 1;
  void clear_type();
  ::sonet::timeline::TimelineUpdate_UpdateType type() const;
  void set_type(::sonet::timeline::TimelineUpdate_UpdateType value);
  private:
  ::sonet::timeline::TimelineUpdate_UpdateType _internal_type() const;
  void _internal_set_type(::sonet::timeline::TimelineUpdate_UpdateType value);
  public:

  // int32 total_new_items = 5;
  void clear_total_new_items();
  int32_t total_new_items() const;
  void set_total_new_items(int32_t value);
  private:
  int32_t _internal_total_new_items() const;
  void _internal_set_total_new_items(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.timeline.TimelineUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::timeline::TimelineItem > new_items_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> updated_item_ids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> deleted_item_ids_;
    ::sonet::common::Timestamp* update_timestamp_;
    int type_;
    int32_t total_new_items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2ftimeline_2eproto;
};
// -------------------------------------------------------------------

class GetTimelineRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.timeline.GetTimelineRequest) */ {
 public:
  inline GetTimelineRequest() : GetTimelineRequest(nullptr) {}
  ~GetTimelineRequest() override;
  explicit PROTOBUF_CONSTEXPR GetTimelineRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTimelineRequest(const GetTimelineRequest& from);
  GetTimelineRequest(GetTimelineRequest&& from) noexcept
    : GetTimelineRequest() {
    *this = ::std::move(from);
  }

  inline GetTimelineRequest& operator=(const GetTimelineRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTimelineRequest& operator=(GetTimelineRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTimelineRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTimelineRequest* internal_default_instance() {
    return reinterpret_cast<const GetTimelineRequest*>(
               &_GetTimelineRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetTimelineRequest& a, GetTimelineRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTimelineRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTimelineRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTimelineRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTimelineRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTimelineRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetTimelineRequest& from) {
    GetTimelineRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTimelineRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.timeline.GetTimelineRequest";
  }
  protected:
  explicit GetTimelineRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kPaginationFieldNumber = 3,
    kAlgorithmFieldNumber = 2,
    kIncludeRankingSignalsFieldNumber = 4,
    kRealTimeUpdatesFieldNumber = 5,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // .sonet.common.PaginationRequest pagination = 3;
  bool has_pagination() const;
  private:
  bool _internal_has_pagination() const;
  public:
  void clear_pagination();
  const ::sonet::common::PaginationRequest& pagination() const;
  PROTOBUF_NODISCARD ::sonet::common::PaginationRequest* release_pagination();
  ::sonet::common::PaginationRequest* mutable_pagination();
  void set_allocated_pagination(::sonet::common::PaginationRequest* pagination);
  private:
  const ::sonet::common::PaginationRequest& _internal_pagination() const;
  ::sonet::common::PaginationRequest* _internal_mutable_pagination();
  public:
  void unsafe_arena_set_allocated_pagination(
      ::sonet::common::PaginationRequest* pagination);
  ::sonet::common::PaginationRequest* unsafe_arena_release_pagination();

  // .sonet.timeline.TimelineAlgorithm algorithm = 2;
  void clear_algorithm();
  ::sonet::timeline::TimelineAlgorithm algorithm() const;
  void set_algorithm(::sonet::timeline::TimelineAlgorithm value);
  private:
  ::sonet::timeline::TimelineAlgorithm _internal_algorithm() const;
  void _internal_set_algorithm(::sonet::timeline::TimelineAlgorithm value);
  public:

  // bool include_ranking_signals = 4;
  void clear_include_ranking_signals();
  bool include_ranking_signals() const;
  void set_include_ranking_signals(bool value);
  private:
  bool _internal_include_ranking_signals() const;
  void _internal_set_include_ranking_signals(bool value);
  public:

  // bool real_time_updates = 5;
  void clear_real_time_updates();
  bool real_time_updates() const;
  void set_real_time_updates(bool value);
  private:
  bool _internal_real_time_updates() const;
  void _internal_set_real_time_updates(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.timeline.GetTimelineRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::sonet::common::PaginationRequest* pagination_;
    int algorithm_;
    bool include_ranking_signals_;
    bool real_time_updates_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2ftimeline_2eproto;
};
// -------------------------------------------------------------------

class GetTimelineResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.timeline.GetTimelineResponse) */ {
 public:
  inline GetTimelineResponse() : GetTimelineResponse(nullptr) {}
  ~GetTimelineResponse() override;
  explicit PROTOBUF_CONSTEXPR GetTimelineResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTimelineResponse(const GetTimelineResponse& from);
  GetTimelineResponse(GetTimelineResponse&& from) noexcept
    : GetTimelineResponse() {
    *this = ::std::move(from);
  }

  inline GetTimelineResponse& operator=(const GetTimelineResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTimelineResponse& operator=(GetTimelineResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTimelineResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTimelineResponse* internal_default_instance() {
    return reinterpret_cast<const GetTimelineResponse*>(
               &_GetTimelineResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetTimelineResponse& a, GetTimelineResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTimelineResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTimelineResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTimelineResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTimelineResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTimelineResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetTimelineResponse& from) {
    GetTimelineResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTimelineResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.timeline.GetTimelineResponse";
  }
  protected:
  explicit GetTimelineResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
    kErrorMessageFieldNumber = 5,
    kMetadataFieldNumber = 2,
    kPaginationFieldNumber = 3,
    kSuccessFieldNumber = 4,
  };
  // repeated .sonet.timeline.TimelineItem items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::sonet::timeline::TimelineItem* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::timeline::TimelineItem >*
      mutable_items();
  private:
  const ::sonet::timeline::TimelineItem& _internal_items(int index) const;
  ::sonet::timeline::TimelineItem* _internal_add_items();
  public:
  const ::sonet::timeline::TimelineItem& items(int index) const;
  ::sonet::timeline::TimelineItem* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::timeline::TimelineItem >&
      items() const;

  // string error_message = 5;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // .sonet.timeline.TimelineMetadata metadata = 2;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::sonet::timeline::TimelineMetadata& metadata() const;
  PROTOBUF_NODISCARD ::sonet::timeline::TimelineMetadata* release_metadata();
  ::sonet::timeline::TimelineMetadata* mutable_metadata();
  void set_allocated_metadata(::sonet::timeline::TimelineMetadata* metadata);
  private:
  const ::sonet::timeline::TimelineMetadata& _internal_metadata() const;
  ::sonet::timeline::TimelineMetadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::sonet::timeline::TimelineMetadata* metadata);
  ::sonet::timeline::TimelineMetadata* unsafe_arena_release_metadata();

  // .sonet.common.PaginationResponse pagination = 3;
  bool has_pagination() const;
  private:
  bool _internal_has_pagination() const;
  public:
  void clear_pagination();
  const ::sonet::common::PaginationResponse& pagination() const;
  PROTOBUF_NODISCARD ::sonet::common::PaginationResponse* release_pagination();
  ::sonet::common::PaginationResponse* mutable_pagination();
  void set_allocated_pagination(::sonet::common::PaginationResponse* pagination);
  private:
  const ::sonet::common::PaginationResponse& _internal_pagination() const;
  ::sonet::common::PaginationResponse* _internal_mutable_pagination();
  public:
  void unsafe_arena_set_allocated_pagination(
      ::sonet::common::PaginationResponse* pagination);
  ::sonet::common::PaginationResponse* unsafe_arena_release_pagination();

  // bool success = 4;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.timeline.GetTimelineResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::timeline::TimelineItem > items_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    ::sonet::timeline::TimelineMetadata* metadata_;
    ::sonet::common::PaginationResponse* pagination_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2ftimeline_2eproto;
};
// -------------------------------------------------------------------

class GetUserTimelineRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.timeline.GetUserTimelineRequest) */ {
 public:
  inline GetUserTimelineRequest() : GetUserTimelineRequest(nullptr) {}
  ~GetUserTimelineRequest() override;
  explicit PROTOBUF_CONSTEXPR GetUserTimelineRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUserTimelineRequest(const GetUserTimelineRequest& from);
  GetUserTimelineRequest(GetUserTimelineRequest&& from) noexcept
    : GetUserTimelineRequest() {
    *this = ::std::move(from);
  }

  inline GetUserTimelineRequest& operator=(const GetUserTimelineRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserTimelineRequest& operator=(GetUserTimelineRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUserTimelineRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserTimelineRequest* internal_default_instance() {
    return reinterpret_cast<const GetUserTimelineRequest*>(
               &_GetUserTimelineRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetUserTimelineRequest& a, GetUserTimelineRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserTimelineRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserTimelineRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserTimelineRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUserTimelineRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetUserTimelineRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetUserTimelineRequest& from) {
    GetUserTimelineRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUserTimelineRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.timeline.GetUserTimelineRequest";
  }
  protected:
  explicit GetUserTimelineRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetUserIdFieldNumber = 1,
    kRequestingUserIdFieldNumber = 2,
    kPaginationFieldNumber = 3,
    kIncludeRepliesFieldNumber = 4,
    kIncludeRenotesFieldNumber = 5,
  };
  // string target_user_id = 1;
  void clear_target_user_id();
  const std::string& target_user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_target_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_target_user_id();
  PROTOBUF_NODISCARD std::string* release_target_user_id();
  void set_allocated_target_user_id(std::string* target_user_id);
  private:
  const std::string& _internal_target_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_user_id(const std::string& value);
  std::string* _internal_mutable_target_user_id();
  public:

  // string requesting_user_id = 2;
  void clear_requesting_user_id();
  const std::string& requesting_user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_requesting_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_requesting_user_id();
  PROTOBUF_NODISCARD std::string* release_requesting_user_id();
  void set_allocated_requesting_user_id(std::string* requesting_user_id);
  private:
  const std::string& _internal_requesting_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_requesting_user_id(const std::string& value);
  std::string* _internal_mutable_requesting_user_id();
  public:

  // .sonet.common.PaginationRequest pagination = 3;
  bool has_pagination() const;
  private:
  bool _internal_has_pagination() const;
  public:
  void clear_pagination();
  const ::sonet::common::PaginationRequest& pagination() const;
  PROTOBUF_NODISCARD ::sonet::common::PaginationRequest* release_pagination();
  ::sonet::common::PaginationRequest* mutable_pagination();
  void set_allocated_pagination(::sonet::common::PaginationRequest* pagination);
  private:
  const ::sonet::common::PaginationRequest& _internal_pagination() const;
  ::sonet::common::PaginationRequest* _internal_mutable_pagination();
  public:
  void unsafe_arena_set_allocated_pagination(
      ::sonet::common::PaginationRequest* pagination);
  ::sonet::common::PaginationRequest* unsafe_arena_release_pagination();

  // bool include_replies = 4;
  void clear_include_replies();
  bool include_replies() const;
  void set_include_replies(bool value);
  private:
  bool _internal_include_replies() const;
  void _internal_set_include_replies(bool value);
  public:

  // bool include_renotes = 5;
  void clear_include_renotes();
  bool include_renotes() const;
  void set_include_renotes(bool value);
  private:
  bool _internal_include_renotes() const;
  void _internal_set_include_renotes(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.timeline.GetUserTimelineRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr requesting_user_id_;
    ::sonet::common::PaginationRequest* pagination_;
    bool include_replies_;
    bool include_renotes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2ftimeline_2eproto;
};
// -------------------------------------------------------------------

class GetUserTimelineResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.timeline.GetUserTimelineResponse) */ {
 public:
  inline GetUserTimelineResponse() : GetUserTimelineResponse(nullptr) {}
  ~GetUserTimelineResponse() override;
  explicit PROTOBUF_CONSTEXPR GetUserTimelineResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUserTimelineResponse(const GetUserTimelineResponse& from);
  GetUserTimelineResponse(GetUserTimelineResponse&& from) noexcept
    : GetUserTimelineResponse() {
    *this = ::std::move(from);
  }

  inline GetUserTimelineResponse& operator=(const GetUserTimelineResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserTimelineResponse& operator=(GetUserTimelineResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUserTimelineResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserTimelineResponse* internal_default_instance() {
    return reinterpret_cast<const GetUserTimelineResponse*>(
               &_GetUserTimelineResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GetUserTimelineResponse& a, GetUserTimelineResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserTimelineResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserTimelineResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserTimelineResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUserTimelineResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetUserTimelineResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetUserTimelineResponse& from) {
    GetUserTimelineResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUserTimelineResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.timeline.GetUserTimelineResponse";
  }
  protected:
  explicit GetUserTimelineResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
    kErrorMessageFieldNumber = 4,
    kPaginationFieldNumber = 2,
    kSuccessFieldNumber = 3,
  };
  // repeated .sonet.timeline.TimelineItem items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::sonet::timeline::TimelineItem* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::timeline::TimelineItem >*
      mutable_items();
  private:
  const ::sonet::timeline::TimelineItem& _internal_items(int index) const;
  ::sonet::timeline::TimelineItem* _internal_add_items();
  public:
  const ::sonet::timeline::TimelineItem& items(int index) const;
  ::sonet::timeline::TimelineItem* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::timeline::TimelineItem >&
      items() const;

  // string error_message = 4;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // .sonet.common.PaginationResponse pagination = 2;
  bool has_pagination() const;
  private:
  bool _internal_has_pagination() const;
  public:
  void clear_pagination();
  const ::sonet::common::PaginationResponse& pagination() const;
  PROTOBUF_NODISCARD ::sonet::common::PaginationResponse* release_pagination();
  ::sonet::common::PaginationResponse* mutable_pagination();
  void set_allocated_pagination(::sonet::common::PaginationResponse* pagination);
  private:
  const ::sonet::common::PaginationResponse& _internal_pagination() const;
  ::sonet::common::PaginationResponse* _internal_mutable_pagination();
  public:
  void unsafe_arena_set_allocated_pagination(
      ::sonet::common::PaginationResponse* pagination);
  ::sonet::common::PaginationResponse* unsafe_arena_release_pagination();

  // bool success = 3;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.timeline.GetUserTimelineResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::timeline::TimelineItem > items_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    ::sonet::common::PaginationResponse* pagination_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2ftimeline_2eproto;
};
// -------------------------------------------------------------------

class RefreshTimelineRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.timeline.RefreshTimelineRequest) */ {
 public:
  inline RefreshTimelineRequest() : RefreshTimelineRequest(nullptr) {}
  ~RefreshTimelineRequest() override;
  explicit PROTOBUF_CONSTEXPR RefreshTimelineRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefreshTimelineRequest(const RefreshTimelineRequest& from);
  RefreshTimelineRequest(RefreshTimelineRequest&& from) noexcept
    : RefreshTimelineRequest() {
    *this = ::std::move(from);
  }

  inline RefreshTimelineRequest& operator=(const RefreshTimelineRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshTimelineRequest& operator=(RefreshTimelineRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefreshTimelineRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshTimelineRequest* internal_default_instance() {
    return reinterpret_cast<const RefreshTimelineRequest*>(
               &_RefreshTimelineRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RefreshTimelineRequest& a, RefreshTimelineRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshTimelineRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshTimelineRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshTimelineRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshTimelineRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RefreshTimelineRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RefreshTimelineRequest& from) {
    RefreshTimelineRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RefreshTimelineRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.timeline.RefreshTimelineRequest";
  }
  protected:
  explicit RefreshTimelineRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kSinceFieldNumber = 2,
    kMaxItemsFieldNumber = 3,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // .sonet.common.Timestamp since = 2;
  bool has_since() const;
  private:
  bool _internal_has_since() const;
  public:
  void clear_since();
  const ::sonet::common::Timestamp& since() const;
  PROTOBUF_NODISCARD ::sonet::common::Timestamp* release_since();
  ::sonet::common::Timestamp* mutable_since();
  void set_allocated_since(::sonet::common::Timestamp* since);
  private:
  const ::sonet::common::Timestamp& _internal_since() const;
  ::sonet::common::Timestamp* _internal_mutable_since();
  public:
  void unsafe_arena_set_allocated_since(
      ::sonet::common::Timestamp* since);
  ::sonet::common::Timestamp* unsafe_arena_release_since();

  // int32 max_items = 3;
  void clear_max_items();
  int32_t max_items() const;
  void set_max_items(int32_t value);
  private:
  int32_t _internal_max_items() const;
  void _internal_set_max_items(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.timeline.RefreshTimelineRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::sonet::common::Timestamp* since_;
    int32_t max_items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2ftimeline_2eproto;
};
// -------------------------------------------------------------------

class RefreshTimelineResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.timeline.RefreshTimelineResponse) */ {
 public:
  inline RefreshTimelineResponse() : RefreshTimelineResponse(nullptr) {}
  ~RefreshTimelineResponse() override;
  explicit PROTOBUF_CONSTEXPR RefreshTimelineResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefreshTimelineResponse(const RefreshTimelineResponse& from);
  RefreshTimelineResponse(RefreshTimelineResponse&& from) noexcept
    : RefreshTimelineResponse() {
    *this = ::std::move(from);
  }

  inline RefreshTimelineResponse& operator=(const RefreshTimelineResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshTimelineResponse& operator=(RefreshTimelineResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefreshTimelineResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshTimelineResponse* internal_default_instance() {
    return reinterpret_cast<const RefreshTimelineResponse*>(
               &_RefreshTimelineResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(RefreshTimelineResponse& a, RefreshTimelineResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshTimelineResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshTimelineResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshTimelineResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshTimelineResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RefreshTimelineResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RefreshTimelineResponse& from) {
    RefreshTimelineResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RefreshTimelineResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.timeline.RefreshTimelineResponse";
  }
  protected:
  explicit RefreshTimelineResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewItemsFieldNumber = 1,
    kErrorMessageFieldNumber = 5,
    kTotalNewItemsFieldNumber = 2,
    kHasMoreFieldNumber = 3,
    kSuccessFieldNumber = 4,
  };
  // repeated .sonet.timeline.TimelineItem new_items = 1;
  int new_items_size() const;
  private:
  int _internal_new_items_size() const;
  public:
  void clear_new_items();
  ::sonet::timeline::TimelineItem* mutable_new_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::timeline::TimelineItem >*
      mutable_new_items();
  private:
  const ::sonet::timeline::TimelineItem& _internal_new_items(int index) const;
  ::sonet::timeline::TimelineItem* _internal_add_new_items();
  public:
  const ::sonet::timeline::TimelineItem& new_items(int index) const;
  ::sonet::timeline::TimelineItem* add_new_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::timeline::TimelineItem >&
      new_items() const;

  // string error_message = 5;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // int32 total_new_items = 2;
  void clear_total_new_items();
  int32_t total_new_items() const;
  void set_total_new_items(int32_t value);
  private:
  int32_t _internal_total_new_items() const;
  void _internal_set_total_new_items(int32_t value);
  public:

  // bool has_more = 3;
  void clear_has_more();
  bool has_more() const;
  void set_has_more(bool value);
  private:
  bool _internal_has_more() const;
  void _internal_set_has_more(bool value);
  public:

  // bool success = 4;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.timeline.RefreshTimelineResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::timeline::TimelineItem > new_items_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    int32_t total_new_items_;
    bool has_more_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2ftimeline_2eproto;
};
// -------------------------------------------------------------------

class MarkTimelineReadRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.timeline.MarkTimelineReadRequest) */ {
 public:
  inline MarkTimelineReadRequest() : MarkTimelineReadRequest(nullptr) {}
  ~MarkTimelineReadRequest() override;
  explicit PROTOBUF_CONSTEXPR MarkTimelineReadRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarkTimelineReadRequest(const MarkTimelineReadRequest& from);
  MarkTimelineReadRequest(MarkTimelineReadRequest&& from) noexcept
    : MarkTimelineReadRequest() {
    *this = ::std::move(from);
  }

  inline MarkTimelineReadRequest& operator=(const MarkTimelineReadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarkTimelineReadRequest& operator=(MarkTimelineReadRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarkTimelineReadRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarkTimelineReadRequest* internal_default_instance() {
    return reinterpret_cast<const MarkTimelineReadRequest*>(
               &_MarkTimelineReadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(MarkTimelineReadRequest& a, MarkTimelineReadRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MarkTimelineReadRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarkTimelineReadRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarkTimelineReadRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarkTimelineReadRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarkTimelineReadRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MarkTimelineReadRequest& from) {
    MarkTimelineReadRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarkTimelineReadRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.timeline.MarkTimelineReadRequest";
  }
  protected:
  explicit MarkTimelineReadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kReadUntilFieldNumber = 2,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // .sonet.common.Timestamp read_until = 2;
  bool has_read_until() const;
  private:
  bool _internal_has_read_until() const;
  public:
  void clear_read_until();
  const ::sonet::common::Timestamp& read_until() const;
  PROTOBUF_NODISCARD ::sonet::common::Timestamp* release_read_until();
  ::sonet::common::Timestamp* mutable_read_until();
  void set_allocated_read_until(::sonet::common::Timestamp* read_until);
  private:
  const ::sonet::common::Timestamp& _internal_read_until() const;
  ::sonet::common::Timestamp* _internal_mutable_read_until();
  public:
  void unsafe_arena_set_allocated_read_until(
      ::sonet::common::Timestamp* read_until);
  ::sonet::common::Timestamp* unsafe_arena_release_read_until();

  // @@protoc_insertion_point(class_scope:sonet.timeline.MarkTimelineReadRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::sonet::common::Timestamp* read_until_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2ftimeline_2eproto;
};
// -------------------------------------------------------------------

class MarkTimelineReadResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.timeline.MarkTimelineReadResponse) */ {
 public:
  inline MarkTimelineReadResponse() : MarkTimelineReadResponse(nullptr) {}
  ~MarkTimelineReadResponse() override;
  explicit PROTOBUF_CONSTEXPR MarkTimelineReadResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarkTimelineReadResponse(const MarkTimelineReadResponse& from);
  MarkTimelineReadResponse(MarkTimelineReadResponse&& from) noexcept
    : MarkTimelineReadResponse() {
    *this = ::std::move(from);
  }

  inline MarkTimelineReadResponse& operator=(const MarkTimelineReadResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarkTimelineReadResponse& operator=(MarkTimelineReadResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarkTimelineReadResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarkTimelineReadResponse* internal_default_instance() {
    return reinterpret_cast<const MarkTimelineReadResponse*>(
               &_MarkTimelineReadResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(MarkTimelineReadResponse& a, MarkTimelineReadResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MarkTimelineReadResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarkTimelineReadResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarkTimelineReadResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarkTimelineReadResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarkTimelineReadResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MarkTimelineReadResponse& from) {
    MarkTimelineReadResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarkTimelineReadResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.timeline.MarkTimelineReadResponse";
  }
  protected:
  explicit MarkTimelineReadResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string error_message = 2;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.timeline.MarkTimelineReadResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2ftimeline_2eproto;
};
// -------------------------------------------------------------------

class UpdateTimelinePreferencesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.timeline.UpdateTimelinePreferencesRequest) */ {
 public:
  inline UpdateTimelinePreferencesRequest() : UpdateTimelinePreferencesRequest(nullptr) {}
  ~UpdateTimelinePreferencesRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateTimelinePreferencesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateTimelinePreferencesRequest(const UpdateTimelinePreferencesRequest& from);
  UpdateTimelinePreferencesRequest(UpdateTimelinePreferencesRequest&& from) noexcept
    : UpdateTimelinePreferencesRequest() {
    *this = ::std::move(from);
  }

  inline UpdateTimelinePreferencesRequest& operator=(const UpdateTimelinePreferencesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateTimelinePreferencesRequest& operator=(UpdateTimelinePreferencesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateTimelinePreferencesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateTimelinePreferencesRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateTimelinePreferencesRequest*>(
               &_UpdateTimelinePreferencesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(UpdateTimelinePreferencesRequest& a, UpdateTimelinePreferencesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateTimelinePreferencesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateTimelinePreferencesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateTimelinePreferencesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateTimelinePreferencesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateTimelinePreferencesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateTimelinePreferencesRequest& from) {
    UpdateTimelinePreferencesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateTimelinePreferencesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.timeline.UpdateTimelinePreferencesRequest";
  }
  protected:
  explicit UpdateTimelinePreferencesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kPreferencesFieldNumber = 2,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // .sonet.timeline.TimelinePreferences preferences = 2;
  bool has_preferences() const;
  private:
  bool _internal_has_preferences() const;
  public:
  void clear_preferences();
  const ::sonet::timeline::TimelinePreferences& preferences() const;
  PROTOBUF_NODISCARD ::sonet::timeline::TimelinePreferences* release_preferences();
  ::sonet::timeline::TimelinePreferences* mutable_preferences();
  void set_allocated_preferences(::sonet::timeline::TimelinePreferences* preferences);
  private:
  const ::sonet::timeline::TimelinePreferences& _internal_preferences() const;
  ::sonet::timeline::TimelinePreferences* _internal_mutable_preferences();
  public:
  void unsafe_arena_set_allocated_preferences(
      ::sonet::timeline::TimelinePreferences* preferences);
  ::sonet::timeline::TimelinePreferences* unsafe_arena_release_preferences();

  // @@protoc_insertion_point(class_scope:sonet.timeline.UpdateTimelinePreferencesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::sonet::timeline::TimelinePreferences* preferences_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2ftimeline_2eproto;
};
// -------------------------------------------------------------------

class UpdateTimelinePreferencesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.timeline.UpdateTimelinePreferencesResponse) */ {
 public:
  inline UpdateTimelinePreferencesResponse() : UpdateTimelinePreferencesResponse(nullptr) {}
  ~UpdateTimelinePreferencesResponse() override;
  explicit PROTOBUF_CONSTEXPR UpdateTimelinePreferencesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateTimelinePreferencesResponse(const UpdateTimelinePreferencesResponse& from);
  UpdateTimelinePreferencesResponse(UpdateTimelinePreferencesResponse&& from) noexcept
    : UpdateTimelinePreferencesResponse() {
    *this = ::std::move(from);
  }

  inline UpdateTimelinePreferencesResponse& operator=(const UpdateTimelinePreferencesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateTimelinePreferencesResponse& operator=(UpdateTimelinePreferencesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateTimelinePreferencesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateTimelinePreferencesResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateTimelinePreferencesResponse*>(
               &_UpdateTimelinePreferencesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(UpdateTimelinePreferencesResponse& a, UpdateTimelinePreferencesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateTimelinePreferencesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateTimelinePreferencesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateTimelinePreferencesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateTimelinePreferencesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateTimelinePreferencesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateTimelinePreferencesResponse& from) {
    UpdateTimelinePreferencesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateTimelinePreferencesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.timeline.UpdateTimelinePreferencesResponse";
  }
  protected:
  explicit UpdateTimelinePreferencesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string error_message = 2;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.timeline.UpdateTimelinePreferencesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2ftimeline_2eproto;
};
// -------------------------------------------------------------------

class GetTimelinePreferencesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.timeline.GetTimelinePreferencesRequest) */ {
 public:
  inline GetTimelinePreferencesRequest() : GetTimelinePreferencesRequest(nullptr) {}
  ~GetTimelinePreferencesRequest() override;
  explicit PROTOBUF_CONSTEXPR GetTimelinePreferencesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTimelinePreferencesRequest(const GetTimelinePreferencesRequest& from);
  GetTimelinePreferencesRequest(GetTimelinePreferencesRequest&& from) noexcept
    : GetTimelinePreferencesRequest() {
    *this = ::std::move(from);
  }

  inline GetTimelinePreferencesRequest& operator=(const GetTimelinePreferencesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTimelinePreferencesRequest& operator=(GetTimelinePreferencesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTimelinePreferencesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTimelinePreferencesRequest* internal_default_instance() {
    return reinterpret_cast<const GetTimelinePreferencesRequest*>(
               &_GetTimelinePreferencesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GetTimelinePreferencesRequest& a, GetTimelinePreferencesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTimelinePreferencesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTimelinePreferencesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTimelinePreferencesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTimelinePreferencesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTimelinePreferencesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetTimelinePreferencesRequest& from) {
    GetTimelinePreferencesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTimelinePreferencesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.timeline.GetTimelinePreferencesRequest";
  }
  protected:
  explicit GetTimelinePreferencesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // @@protoc_insertion_point(class_scope:sonet.timeline.GetTimelinePreferencesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2ftimeline_2eproto;
};
// -------------------------------------------------------------------

class GetTimelinePreferencesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.timeline.GetTimelinePreferencesResponse) */ {
 public:
  inline GetTimelinePreferencesResponse() : GetTimelinePreferencesResponse(nullptr) {}
  ~GetTimelinePreferencesResponse() override;
  explicit PROTOBUF_CONSTEXPR GetTimelinePreferencesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTimelinePreferencesResponse(const GetTimelinePreferencesResponse& from);
  GetTimelinePreferencesResponse(GetTimelinePreferencesResponse&& from) noexcept
    : GetTimelinePreferencesResponse() {
    *this = ::std::move(from);
  }

  inline GetTimelinePreferencesResponse& operator=(const GetTimelinePreferencesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTimelinePreferencesResponse& operator=(GetTimelinePreferencesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTimelinePreferencesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTimelinePreferencesResponse* internal_default_instance() {
    return reinterpret_cast<const GetTimelinePreferencesResponse*>(
               &_GetTimelinePreferencesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(GetTimelinePreferencesResponse& a, GetTimelinePreferencesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTimelinePreferencesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTimelinePreferencesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTimelinePreferencesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTimelinePreferencesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTimelinePreferencesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetTimelinePreferencesResponse& from) {
    GetTimelinePreferencesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTimelinePreferencesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.timeline.GetTimelinePreferencesResponse";
  }
  protected:
  explicit GetTimelinePreferencesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 3,
    kPreferencesFieldNumber = 1,
    kSuccessFieldNumber = 2,
  };
  // string error_message = 3;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // .sonet.timeline.TimelinePreferences preferences = 1;
  bool has_preferences() const;
  private:
  bool _internal_has_preferences() const;
  public:
  void clear_preferences();
  const ::sonet::timeline::TimelinePreferences& preferences() const;
  PROTOBUF_NODISCARD ::sonet::timeline::TimelinePreferences* release_preferences();
  ::sonet::timeline::TimelinePreferences* mutable_preferences();
  void set_allocated_preferences(::sonet::timeline::TimelinePreferences* preferences);
  private:
  const ::sonet::timeline::TimelinePreferences& _internal_preferences() const;
  ::sonet::timeline::TimelinePreferences* _internal_mutable_preferences();
  public:
  void unsafe_arena_set_allocated_preferences(
      ::sonet::timeline::TimelinePreferences* preferences);
  ::sonet::timeline::TimelinePreferences* unsafe_arena_release_preferences();

  // bool success = 2;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.timeline.GetTimelinePreferencesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    ::sonet::timeline::TimelinePreferences* preferences_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2ftimeline_2eproto;
};
// -------------------------------------------------------------------

class SubscribeTimelineUpdatesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.timeline.SubscribeTimelineUpdatesRequest) */ {
 public:
  inline SubscribeTimelineUpdatesRequest() : SubscribeTimelineUpdatesRequest(nullptr) {}
  ~SubscribeTimelineUpdatesRequest() override;
  explicit PROTOBUF_CONSTEXPR SubscribeTimelineUpdatesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeTimelineUpdatesRequest(const SubscribeTimelineUpdatesRequest& from);
  SubscribeTimelineUpdatesRequest(SubscribeTimelineUpdatesRequest&& from) noexcept
    : SubscribeTimelineUpdatesRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeTimelineUpdatesRequest& operator=(const SubscribeTimelineUpdatesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeTimelineUpdatesRequest& operator=(SubscribeTimelineUpdatesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeTimelineUpdatesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeTimelineUpdatesRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeTimelineUpdatesRequest*>(
               &_SubscribeTimelineUpdatesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SubscribeTimelineUpdatesRequest& a, SubscribeTimelineUpdatesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeTimelineUpdatesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeTimelineUpdatesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeTimelineUpdatesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeTimelineUpdatesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscribeTimelineUpdatesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubscribeTimelineUpdatesRequest& from) {
    SubscribeTimelineUpdatesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribeTimelineUpdatesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.timeline.SubscribeTimelineUpdatesRequest";
  }
  protected:
  explicit SubscribeTimelineUpdatesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kIncludeMetadataFieldNumber = 2,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // bool include_metadata = 2;
  void clear_include_metadata();
  bool include_metadata() const;
  void set_include_metadata(bool value);
  private:
  bool _internal_include_metadata() const;
  void _internal_set_include_metadata(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.timeline.SubscribeTimelineUpdatesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    bool include_metadata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2ftimeline_2eproto;
};
// -------------------------------------------------------------------

class HealthCheckRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:sonet.timeline.HealthCheckRequest) */ {
 public:
  inline HealthCheckRequest() : HealthCheckRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR HealthCheckRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HealthCheckRequest(const HealthCheckRequest& from);
  HealthCheckRequest(HealthCheckRequest&& from) noexcept
    : HealthCheckRequest() {
    *this = ::std::move(from);
  }

  inline HealthCheckRequest& operator=(const HealthCheckRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealthCheckRequest& operator=(HealthCheckRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HealthCheckRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HealthCheckRequest* internal_default_instance() {
    return reinterpret_cast<const HealthCheckRequest*>(
               &_HealthCheckRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(HealthCheckRequest& a, HealthCheckRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HealthCheckRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealthCheckRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HealthCheckRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HealthCheckRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const HealthCheckRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const HealthCheckRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.timeline.HealthCheckRequest";
  }
  protected:
  explicit HealthCheckRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:sonet.timeline.HealthCheckRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_services_2ftimeline_2eproto;
};
// -------------------------------------------------------------------

class HealthCheckResponse_DetailsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<HealthCheckResponse_DetailsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<HealthCheckResponse_DetailsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  HealthCheckResponse_DetailsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR HealthCheckResponse_DetailsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit HealthCheckResponse_DetailsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const HealthCheckResponse_DetailsEntry_DoNotUse& other);
  static const HealthCheckResponse_DetailsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const HealthCheckResponse_DetailsEntry_DoNotUse*>(&_HealthCheckResponse_DetailsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "sonet.timeline.HealthCheckResponse.DetailsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "sonet.timeline.HealthCheckResponse.DetailsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_services_2ftimeline_2eproto;
};

// -------------------------------------------------------------------

class HealthCheckResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.timeline.HealthCheckResponse) */ {
 public:
  inline HealthCheckResponse() : HealthCheckResponse(nullptr) {}
  ~HealthCheckResponse() override;
  explicit PROTOBUF_CONSTEXPR HealthCheckResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HealthCheckResponse(const HealthCheckResponse& from);
  HealthCheckResponse(HealthCheckResponse&& from) noexcept
    : HealthCheckResponse() {
    *this = ::std::move(from);
  }

  inline HealthCheckResponse& operator=(const HealthCheckResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealthCheckResponse& operator=(HealthCheckResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HealthCheckResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HealthCheckResponse* internal_default_instance() {
    return reinterpret_cast<const HealthCheckResponse*>(
               &_HealthCheckResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(HealthCheckResponse& a, HealthCheckResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HealthCheckResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealthCheckResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HealthCheckResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HealthCheckResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HealthCheckResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HealthCheckResponse& from) {
    HealthCheckResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HealthCheckResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.timeline.HealthCheckResponse";
  }
  protected:
  explicit HealthCheckResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kDetailsFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // map<string, string> details = 2;
  int details_size() const;
  private:
  int _internal_details_size() const;
  public:
  void clear_details();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_details() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_details();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      details() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_details();

  // string status = 1;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:sonet.timeline.HealthCheckResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        HealthCheckResponse_DetailsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> details_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2ftimeline_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RankingSignals

// double author_affinity_score = 1;
inline void RankingSignals::clear_author_affinity_score() {
  _impl_.author_affinity_score_ = 0;
}
inline double RankingSignals::_internal_author_affinity_score() const {
  return _impl_.author_affinity_score_;
}
inline double RankingSignals::author_affinity_score() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.RankingSignals.author_affinity_score)
  return _internal_author_affinity_score();
}
inline void RankingSignals::_internal_set_author_affinity_score(double value) {
  
  _impl_.author_affinity_score_ = value;
}
inline void RankingSignals::set_author_affinity_score(double value) {
  _internal_set_author_affinity_score(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.RankingSignals.author_affinity_score)
}

// double content_quality_score = 2;
inline void RankingSignals::clear_content_quality_score() {
  _impl_.content_quality_score_ = 0;
}
inline double RankingSignals::_internal_content_quality_score() const {
  return _impl_.content_quality_score_;
}
inline double RankingSignals::content_quality_score() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.RankingSignals.content_quality_score)
  return _internal_content_quality_score();
}
inline void RankingSignals::_internal_set_content_quality_score(double value) {
  
  _impl_.content_quality_score_ = value;
}
inline void RankingSignals::set_content_quality_score(double value) {
  _internal_set_content_quality_score(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.RankingSignals.content_quality_score)
}

// double engagement_velocity = 3;
inline void RankingSignals::clear_engagement_velocity() {
  _impl_.engagement_velocity_ = 0;
}
inline double RankingSignals::_internal_engagement_velocity() const {
  return _impl_.engagement_velocity_;
}
inline double RankingSignals::engagement_velocity() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.RankingSignals.engagement_velocity)
  return _internal_engagement_velocity();
}
inline void RankingSignals::_internal_set_engagement_velocity(double value) {
  
  _impl_.engagement_velocity_ = value;
}
inline void RankingSignals::set_engagement_velocity(double value) {
  _internal_set_engagement_velocity(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.RankingSignals.engagement_velocity)
}

// double recency_score = 4;
inline void RankingSignals::clear_recency_score() {
  _impl_.recency_score_ = 0;
}
inline double RankingSignals::_internal_recency_score() const {
  return _impl_.recency_score_;
}
inline double RankingSignals::recency_score() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.RankingSignals.recency_score)
  return _internal_recency_score();
}
inline void RankingSignals::_internal_set_recency_score(double value) {
  
  _impl_.recency_score_ = value;
}
inline void RankingSignals::set_recency_score(double value) {
  _internal_set_recency_score(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.RankingSignals.recency_score)
}

// double personalization_score = 5;
inline void RankingSignals::clear_personalization_score() {
  _impl_.personalization_score_ = 0;
}
inline double RankingSignals::_internal_personalization_score() const {
  return _impl_.personalization_score_;
}
inline double RankingSignals::personalization_score() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.RankingSignals.personalization_score)
  return _internal_personalization_score();
}
inline void RankingSignals::_internal_set_personalization_score(double value) {
  
  _impl_.personalization_score_ = value;
}
inline void RankingSignals::set_personalization_score(double value) {
  _internal_set_personalization_score(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.RankingSignals.personalization_score)
}

// double diversity_score = 6;
inline void RankingSignals::clear_diversity_score() {
  _impl_.diversity_score_ = 0;
}
inline double RankingSignals::_internal_diversity_score() const {
  return _impl_.diversity_score_;
}
inline double RankingSignals::diversity_score() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.RankingSignals.diversity_score)
  return _internal_diversity_score();
}
inline void RankingSignals::_internal_set_diversity_score(double value) {
  
  _impl_.diversity_score_ = value;
}
inline void RankingSignals::set_diversity_score(double value) {
  _internal_set_diversity_score(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.RankingSignals.diversity_score)
}

// bool is_reply_to_following = 7;
inline void RankingSignals::clear_is_reply_to_following() {
  _impl_.is_reply_to_following_ = false;
}
inline bool RankingSignals::_internal_is_reply_to_following() const {
  return _impl_.is_reply_to_following_;
}
inline bool RankingSignals::is_reply_to_following() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.RankingSignals.is_reply_to_following)
  return _internal_is_reply_to_following();
}
inline void RankingSignals::_internal_set_is_reply_to_following(bool value) {
  
  _impl_.is_reply_to_following_ = value;
}
inline void RankingSignals::set_is_reply_to_following(bool value) {
  _internal_set_is_reply_to_following(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.RankingSignals.is_reply_to_following)
}

// int32 mutual_follower_interactions = 8;
inline void RankingSignals::clear_mutual_follower_interactions() {
  _impl_.mutual_follower_interactions_ = 0;
}
inline int32_t RankingSignals::_internal_mutual_follower_interactions() const {
  return _impl_.mutual_follower_interactions_;
}
inline int32_t RankingSignals::mutual_follower_interactions() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.RankingSignals.mutual_follower_interactions)
  return _internal_mutual_follower_interactions();
}
inline void RankingSignals::_internal_set_mutual_follower_interactions(int32_t value) {
  
  _impl_.mutual_follower_interactions_ = value;
}
inline void RankingSignals::set_mutual_follower_interactions(int32_t value) {
  _internal_set_mutual_follower_interactions(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.RankingSignals.mutual_follower_interactions)
}

// -------------------------------------------------------------------

// TimelineItem

// .sonet.note.Note note = 1;
inline bool TimelineItem::_internal_has_note() const {
  return this != internal_default_instance() && _impl_.note_ != nullptr;
}
inline bool TimelineItem::has_note() const {
  return _internal_has_note();
}
inline const ::sonet::note::Note& TimelineItem::_internal_note() const {
  const ::sonet::note::Note* p = _impl_.note_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::note::Note&>(
      ::sonet::note::_Note_default_instance_);
}
inline const ::sonet::note::Note& TimelineItem::note() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.TimelineItem.note)
  return _internal_note();
}
inline void TimelineItem::unsafe_arena_set_allocated_note(
    ::sonet::note::Note* note) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.note_);
  }
  _impl_.note_ = note;
  if (note) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.timeline.TimelineItem.note)
}
inline ::sonet::note::Note* TimelineItem::release_note() {
  
  ::sonet::note::Note* temp = _impl_.note_;
  _impl_.note_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::note::Note* TimelineItem::unsafe_arena_release_note() {
  // @@protoc_insertion_point(field_release:sonet.timeline.TimelineItem.note)
  
  ::sonet::note::Note* temp = _impl_.note_;
  _impl_.note_ = nullptr;
  return temp;
}
inline ::sonet::note::Note* TimelineItem::_internal_mutable_note() {
  
  if (_impl_.note_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::note::Note>(GetArenaForAllocation());
    _impl_.note_ = p;
  }
  return _impl_.note_;
}
inline ::sonet::note::Note* TimelineItem::mutable_note() {
  ::sonet::note::Note* _msg = _internal_mutable_note();
  // @@protoc_insertion_point(field_mutable:sonet.timeline.TimelineItem.note)
  return _msg;
}
inline void TimelineItem::set_allocated_note(::sonet::note::Note* note) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.note_);
  }
  if (note) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(note));
    if (message_arena != submessage_arena) {
      note = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, note, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.note_ = note;
  // @@protoc_insertion_point(field_set_allocated:sonet.timeline.TimelineItem.note)
}

// .sonet.timeline.ContentSource source = 2;
inline void TimelineItem::clear_source() {
  _impl_.source_ = 0;
}
inline ::sonet::timeline::ContentSource TimelineItem::_internal_source() const {
  return static_cast< ::sonet::timeline::ContentSource >(_impl_.source_);
}
inline ::sonet::timeline::ContentSource TimelineItem::source() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.TimelineItem.source)
  return _internal_source();
}
inline void TimelineItem::_internal_set_source(::sonet::timeline::ContentSource value) {
  
  _impl_.source_ = value;
}
inline void TimelineItem::set_source(::sonet::timeline::ContentSource value) {
  _internal_set_source(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.TimelineItem.source)
}

// .sonet.timeline.RankingSignals ranking_signals = 3;
inline bool TimelineItem::_internal_has_ranking_signals() const {
  return this != internal_default_instance() && _impl_.ranking_signals_ != nullptr;
}
inline bool TimelineItem::has_ranking_signals() const {
  return _internal_has_ranking_signals();
}
inline void TimelineItem::clear_ranking_signals() {
  if (GetArenaForAllocation() == nullptr && _impl_.ranking_signals_ != nullptr) {
    delete _impl_.ranking_signals_;
  }
  _impl_.ranking_signals_ = nullptr;
}
inline const ::sonet::timeline::RankingSignals& TimelineItem::_internal_ranking_signals() const {
  const ::sonet::timeline::RankingSignals* p = _impl_.ranking_signals_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::timeline::RankingSignals&>(
      ::sonet::timeline::_RankingSignals_default_instance_);
}
inline const ::sonet::timeline::RankingSignals& TimelineItem::ranking_signals() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.TimelineItem.ranking_signals)
  return _internal_ranking_signals();
}
inline void TimelineItem::unsafe_arena_set_allocated_ranking_signals(
    ::sonet::timeline::RankingSignals* ranking_signals) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ranking_signals_);
  }
  _impl_.ranking_signals_ = ranking_signals;
  if (ranking_signals) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.timeline.TimelineItem.ranking_signals)
}
inline ::sonet::timeline::RankingSignals* TimelineItem::release_ranking_signals() {
  
  ::sonet::timeline::RankingSignals* temp = _impl_.ranking_signals_;
  _impl_.ranking_signals_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::timeline::RankingSignals* TimelineItem::unsafe_arena_release_ranking_signals() {
  // @@protoc_insertion_point(field_release:sonet.timeline.TimelineItem.ranking_signals)
  
  ::sonet::timeline::RankingSignals* temp = _impl_.ranking_signals_;
  _impl_.ranking_signals_ = nullptr;
  return temp;
}
inline ::sonet::timeline::RankingSignals* TimelineItem::_internal_mutable_ranking_signals() {
  
  if (_impl_.ranking_signals_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::timeline::RankingSignals>(GetArenaForAllocation());
    _impl_.ranking_signals_ = p;
  }
  return _impl_.ranking_signals_;
}
inline ::sonet::timeline::RankingSignals* TimelineItem::mutable_ranking_signals() {
  ::sonet::timeline::RankingSignals* _msg = _internal_mutable_ranking_signals();
  // @@protoc_insertion_point(field_mutable:sonet.timeline.TimelineItem.ranking_signals)
  return _msg;
}
inline void TimelineItem::set_allocated_ranking_signals(::sonet::timeline::RankingSignals* ranking_signals) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ranking_signals_;
  }
  if (ranking_signals) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ranking_signals);
    if (message_arena != submessage_arena) {
      ranking_signals = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ranking_signals, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ranking_signals_ = ranking_signals;
  // @@protoc_insertion_point(field_set_allocated:sonet.timeline.TimelineItem.ranking_signals)
}

// .sonet.common.Timestamp injected_at = 4;
inline bool TimelineItem::_internal_has_injected_at() const {
  return this != internal_default_instance() && _impl_.injected_at_ != nullptr;
}
inline bool TimelineItem::has_injected_at() const {
  return _internal_has_injected_at();
}
inline const ::sonet::common::Timestamp& TimelineItem::_internal_injected_at() const {
  const ::sonet::common::Timestamp* p = _impl_.injected_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Timestamp&>(
      ::sonet::common::_Timestamp_default_instance_);
}
inline const ::sonet::common::Timestamp& TimelineItem::injected_at() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.TimelineItem.injected_at)
  return _internal_injected_at();
}
inline void TimelineItem::unsafe_arena_set_allocated_injected_at(
    ::sonet::common::Timestamp* injected_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.injected_at_);
  }
  _impl_.injected_at_ = injected_at;
  if (injected_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.timeline.TimelineItem.injected_at)
}
inline ::sonet::common::Timestamp* TimelineItem::release_injected_at() {
  
  ::sonet::common::Timestamp* temp = _impl_.injected_at_;
  _impl_.injected_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Timestamp* TimelineItem::unsafe_arena_release_injected_at() {
  // @@protoc_insertion_point(field_release:sonet.timeline.TimelineItem.injected_at)
  
  ::sonet::common::Timestamp* temp = _impl_.injected_at_;
  _impl_.injected_at_ = nullptr;
  return temp;
}
inline ::sonet::common::Timestamp* TimelineItem::_internal_mutable_injected_at() {
  
  if (_impl_.injected_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Timestamp>(GetArenaForAllocation());
    _impl_.injected_at_ = p;
  }
  return _impl_.injected_at_;
}
inline ::sonet::common::Timestamp* TimelineItem::mutable_injected_at() {
  ::sonet::common::Timestamp* _msg = _internal_mutable_injected_at();
  // @@protoc_insertion_point(field_mutable:sonet.timeline.TimelineItem.injected_at)
  return _msg;
}
inline void TimelineItem::set_allocated_injected_at(::sonet::common::Timestamp* injected_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.injected_at_);
  }
  if (injected_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(injected_at));
    if (message_arena != submessage_arena) {
      injected_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, injected_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.injected_at_ = injected_at;
  // @@protoc_insertion_point(field_set_allocated:sonet.timeline.TimelineItem.injected_at)
}

// double final_score = 5;
inline void TimelineItem::clear_final_score() {
  _impl_.final_score_ = 0;
}
inline double TimelineItem::_internal_final_score() const {
  return _impl_.final_score_;
}
inline double TimelineItem::final_score() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.TimelineItem.final_score)
  return _internal_final_score();
}
inline void TimelineItem::_internal_set_final_score(double value) {
  
  _impl_.final_score_ = value;
}
inline void TimelineItem::set_final_score(double value) {
  _internal_set_final_score(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.TimelineItem.final_score)
}

// string injection_reason = 6;
inline void TimelineItem::clear_injection_reason() {
  _impl_.injection_reason_.ClearToEmpty();
}
inline const std::string& TimelineItem::injection_reason() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.TimelineItem.injection_reason)
  return _internal_injection_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TimelineItem::set_injection_reason(ArgT0&& arg0, ArgT... args) {
 
 _impl_.injection_reason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.timeline.TimelineItem.injection_reason)
}
inline std::string* TimelineItem::mutable_injection_reason() {
  std::string* _s = _internal_mutable_injection_reason();
  // @@protoc_insertion_point(field_mutable:sonet.timeline.TimelineItem.injection_reason)
  return _s;
}
inline const std::string& TimelineItem::_internal_injection_reason() const {
  return _impl_.injection_reason_.Get();
}
inline void TimelineItem::_internal_set_injection_reason(const std::string& value) {
  
  _impl_.injection_reason_.Set(value, GetArenaForAllocation());
}
inline std::string* TimelineItem::_internal_mutable_injection_reason() {
  
  return _impl_.injection_reason_.Mutable(GetArenaForAllocation());
}
inline std::string* TimelineItem::release_injection_reason() {
  // @@protoc_insertion_point(field_release:sonet.timeline.TimelineItem.injection_reason)
  return _impl_.injection_reason_.Release();
}
inline void TimelineItem::set_allocated_injection_reason(std::string* injection_reason) {
  if (injection_reason != nullptr) {
    
  } else {
    
  }
  _impl_.injection_reason_.SetAllocated(injection_reason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.injection_reason_.IsDefault()) {
    _impl_.injection_reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.timeline.TimelineItem.injection_reason)
}

// int32 position_in_timeline = 7;
inline void TimelineItem::clear_position_in_timeline() {
  _impl_.position_in_timeline_ = 0;
}
inline int32_t TimelineItem::_internal_position_in_timeline() const {
  return _impl_.position_in_timeline_;
}
inline int32_t TimelineItem::position_in_timeline() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.TimelineItem.position_in_timeline)
  return _internal_position_in_timeline();
}
inline void TimelineItem::_internal_set_position_in_timeline(int32_t value) {
  
  _impl_.position_in_timeline_ = value;
}
inline void TimelineItem::set_position_in_timeline(int32_t value) {
  _internal_set_position_in_timeline(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.TimelineItem.position_in_timeline)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TimelineMetadata

// int32 total_items = 1;
inline void TimelineMetadata::clear_total_items() {
  _impl_.total_items_ = 0;
}
inline int32_t TimelineMetadata::_internal_total_items() const {
  return _impl_.total_items_;
}
inline int32_t TimelineMetadata::total_items() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.TimelineMetadata.total_items)
  return _internal_total_items();
}
inline void TimelineMetadata::_internal_set_total_items(int32_t value) {
  
  _impl_.total_items_ = value;
}
inline void TimelineMetadata::set_total_items(int32_t value) {
  _internal_set_total_items(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.TimelineMetadata.total_items)
}

// int32 new_items_since_last_fetch = 2;
inline void TimelineMetadata::clear_new_items_since_last_fetch() {
  _impl_.new_items_since_last_fetch_ = 0;
}
inline int32_t TimelineMetadata::_internal_new_items_since_last_fetch() const {
  return _impl_.new_items_since_last_fetch_;
}
inline int32_t TimelineMetadata::new_items_since_last_fetch() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.TimelineMetadata.new_items_since_last_fetch)
  return _internal_new_items_since_last_fetch();
}
inline void TimelineMetadata::_internal_set_new_items_since_last_fetch(int32_t value) {
  
  _impl_.new_items_since_last_fetch_ = value;
}
inline void TimelineMetadata::set_new_items_since_last_fetch(int32_t value) {
  _internal_set_new_items_since_last_fetch(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.TimelineMetadata.new_items_since_last_fetch)
}

// .sonet.common.Timestamp last_updated = 3;
inline bool TimelineMetadata::_internal_has_last_updated() const {
  return this != internal_default_instance() && _impl_.last_updated_ != nullptr;
}
inline bool TimelineMetadata::has_last_updated() const {
  return _internal_has_last_updated();
}
inline const ::sonet::common::Timestamp& TimelineMetadata::_internal_last_updated() const {
  const ::sonet::common::Timestamp* p = _impl_.last_updated_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Timestamp&>(
      ::sonet::common::_Timestamp_default_instance_);
}
inline const ::sonet::common::Timestamp& TimelineMetadata::last_updated() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.TimelineMetadata.last_updated)
  return _internal_last_updated();
}
inline void TimelineMetadata::unsafe_arena_set_allocated_last_updated(
    ::sonet::common::Timestamp* last_updated) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_updated_);
  }
  _impl_.last_updated_ = last_updated;
  if (last_updated) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.timeline.TimelineMetadata.last_updated)
}
inline ::sonet::common::Timestamp* TimelineMetadata::release_last_updated() {
  
  ::sonet::common::Timestamp* temp = _impl_.last_updated_;
  _impl_.last_updated_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Timestamp* TimelineMetadata::unsafe_arena_release_last_updated() {
  // @@protoc_insertion_point(field_release:sonet.timeline.TimelineMetadata.last_updated)
  
  ::sonet::common::Timestamp* temp = _impl_.last_updated_;
  _impl_.last_updated_ = nullptr;
  return temp;
}
inline ::sonet::common::Timestamp* TimelineMetadata::_internal_mutable_last_updated() {
  
  if (_impl_.last_updated_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Timestamp>(GetArenaForAllocation());
    _impl_.last_updated_ = p;
  }
  return _impl_.last_updated_;
}
inline ::sonet::common::Timestamp* TimelineMetadata::mutable_last_updated() {
  ::sonet::common::Timestamp* _msg = _internal_mutable_last_updated();
  // @@protoc_insertion_point(field_mutable:sonet.timeline.TimelineMetadata.last_updated)
  return _msg;
}
inline void TimelineMetadata::set_allocated_last_updated(::sonet::common::Timestamp* last_updated) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_updated_);
  }
  if (last_updated) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_updated));
    if (message_arena != submessage_arena) {
      last_updated = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_updated, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.last_updated_ = last_updated;
  // @@protoc_insertion_point(field_set_allocated:sonet.timeline.TimelineMetadata.last_updated)
}

// .sonet.common.Timestamp last_user_read = 4;
inline bool TimelineMetadata::_internal_has_last_user_read() const {
  return this != internal_default_instance() && _impl_.last_user_read_ != nullptr;
}
inline bool TimelineMetadata::has_last_user_read() const {
  return _internal_has_last_user_read();
}
inline const ::sonet::common::Timestamp& TimelineMetadata::_internal_last_user_read() const {
  const ::sonet::common::Timestamp* p = _impl_.last_user_read_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Timestamp&>(
      ::sonet::common::_Timestamp_default_instance_);
}
inline const ::sonet::common::Timestamp& TimelineMetadata::last_user_read() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.TimelineMetadata.last_user_read)
  return _internal_last_user_read();
}
inline void TimelineMetadata::unsafe_arena_set_allocated_last_user_read(
    ::sonet::common::Timestamp* last_user_read) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_user_read_);
  }
  _impl_.last_user_read_ = last_user_read;
  if (last_user_read) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.timeline.TimelineMetadata.last_user_read)
}
inline ::sonet::common::Timestamp* TimelineMetadata::release_last_user_read() {
  
  ::sonet::common::Timestamp* temp = _impl_.last_user_read_;
  _impl_.last_user_read_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Timestamp* TimelineMetadata::unsafe_arena_release_last_user_read() {
  // @@protoc_insertion_point(field_release:sonet.timeline.TimelineMetadata.last_user_read)
  
  ::sonet::common::Timestamp* temp = _impl_.last_user_read_;
  _impl_.last_user_read_ = nullptr;
  return temp;
}
inline ::sonet::common::Timestamp* TimelineMetadata::_internal_mutable_last_user_read() {
  
  if (_impl_.last_user_read_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Timestamp>(GetArenaForAllocation());
    _impl_.last_user_read_ = p;
  }
  return _impl_.last_user_read_;
}
inline ::sonet::common::Timestamp* TimelineMetadata::mutable_last_user_read() {
  ::sonet::common::Timestamp* _msg = _internal_mutable_last_user_read();
  // @@protoc_insertion_point(field_mutable:sonet.timeline.TimelineMetadata.last_user_read)
  return _msg;
}
inline void TimelineMetadata::set_allocated_last_user_read(::sonet::common::Timestamp* last_user_read) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_user_read_);
  }
  if (last_user_read) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_user_read));
    if (message_arena != submessage_arena) {
      last_user_read = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_user_read, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.last_user_read_ = last_user_read;
  // @@protoc_insertion_point(field_set_allocated:sonet.timeline.TimelineMetadata.last_user_read)
}

// .sonet.timeline.TimelineAlgorithm algorithm_used = 5;
inline void TimelineMetadata::clear_algorithm_used() {
  _impl_.algorithm_used_ = 0;
}
inline ::sonet::timeline::TimelineAlgorithm TimelineMetadata::_internal_algorithm_used() const {
  return static_cast< ::sonet::timeline::TimelineAlgorithm >(_impl_.algorithm_used_);
}
inline ::sonet::timeline::TimelineAlgorithm TimelineMetadata::algorithm_used() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.TimelineMetadata.algorithm_used)
  return _internal_algorithm_used();
}
inline void TimelineMetadata::_internal_set_algorithm_used(::sonet::timeline::TimelineAlgorithm value) {
  
  _impl_.algorithm_used_ = value;
}
inline void TimelineMetadata::set_algorithm_used(::sonet::timeline::TimelineAlgorithm value) {
  _internal_set_algorithm_used(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.TimelineMetadata.algorithm_used)
}

// string timeline_version = 6;
inline void TimelineMetadata::clear_timeline_version() {
  _impl_.timeline_version_.ClearToEmpty();
}
inline const std::string& TimelineMetadata::timeline_version() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.TimelineMetadata.timeline_version)
  return _internal_timeline_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TimelineMetadata::set_timeline_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.timeline_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.timeline.TimelineMetadata.timeline_version)
}
inline std::string* TimelineMetadata::mutable_timeline_version() {
  std::string* _s = _internal_mutable_timeline_version();
  // @@protoc_insertion_point(field_mutable:sonet.timeline.TimelineMetadata.timeline_version)
  return _s;
}
inline const std::string& TimelineMetadata::_internal_timeline_version() const {
  return _impl_.timeline_version_.Get();
}
inline void TimelineMetadata::_internal_set_timeline_version(const std::string& value) {
  
  _impl_.timeline_version_.Set(value, GetArenaForAllocation());
}
inline std::string* TimelineMetadata::_internal_mutable_timeline_version() {
  
  return _impl_.timeline_version_.Mutable(GetArenaForAllocation());
}
inline std::string* TimelineMetadata::release_timeline_version() {
  // @@protoc_insertion_point(field_release:sonet.timeline.TimelineMetadata.timeline_version)
  return _impl_.timeline_version_.Release();
}
inline void TimelineMetadata::set_allocated_timeline_version(std::string* timeline_version) {
  if (timeline_version != nullptr) {
    
  } else {
    
  }
  _impl_.timeline_version_.SetAllocated(timeline_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.timeline_version_.IsDefault()) {
    _impl_.timeline_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.timeline.TimelineMetadata.timeline_version)
}

// map<string, double> algorithm_params = 7;
inline int TimelineMetadata::_internal_algorithm_params_size() const {
  return _impl_.algorithm_params_.size();
}
inline int TimelineMetadata::algorithm_params_size() const {
  return _internal_algorithm_params_size();
}
inline void TimelineMetadata::clear_algorithm_params() {
  _impl_.algorithm_params_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
TimelineMetadata::_internal_algorithm_params() const {
  return _impl_.algorithm_params_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
TimelineMetadata::algorithm_params() const {
  // @@protoc_insertion_point(field_map:sonet.timeline.TimelineMetadata.algorithm_params)
  return _internal_algorithm_params();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
TimelineMetadata::_internal_mutable_algorithm_params() {
  return _impl_.algorithm_params_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
TimelineMetadata::mutable_algorithm_params() {
  // @@protoc_insertion_point(field_mutable_map:sonet.timeline.TimelineMetadata.algorithm_params)
  return _internal_mutable_algorithm_params();
}

// -------------------------------------------------------------------

// TimelinePreferences

// .sonet.timeline.TimelineAlgorithm preferred_algorithm = 1;
inline void TimelinePreferences::clear_preferred_algorithm() {
  _impl_.preferred_algorithm_ = 0;
}
inline ::sonet::timeline::TimelineAlgorithm TimelinePreferences::_internal_preferred_algorithm() const {
  return static_cast< ::sonet::timeline::TimelineAlgorithm >(_impl_.preferred_algorithm_);
}
inline ::sonet::timeline::TimelineAlgorithm TimelinePreferences::preferred_algorithm() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.TimelinePreferences.preferred_algorithm)
  return _internal_preferred_algorithm();
}
inline void TimelinePreferences::_internal_set_preferred_algorithm(::sonet::timeline::TimelineAlgorithm value) {
  
  _impl_.preferred_algorithm_ = value;
}
inline void TimelinePreferences::set_preferred_algorithm(::sonet::timeline::TimelineAlgorithm value) {
  _internal_set_preferred_algorithm(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.TimelinePreferences.preferred_algorithm)
}

// bool show_replies = 2;
inline void TimelinePreferences::clear_show_replies() {
  _impl_.show_replies_ = false;
}
inline bool TimelinePreferences::_internal_show_replies() const {
  return _impl_.show_replies_;
}
inline bool TimelinePreferences::show_replies() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.TimelinePreferences.show_replies)
  return _internal_show_replies();
}
inline void TimelinePreferences::_internal_set_show_replies(bool value) {
  
  _impl_.show_replies_ = value;
}
inline void TimelinePreferences::set_show_replies(bool value) {
  _internal_set_show_replies(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.TimelinePreferences.show_replies)
}

// bool show_renotes = 3;
inline void TimelinePreferences::clear_show_renotes() {
  _impl_.show_renotes_ = false;
}
inline bool TimelinePreferences::_internal_show_renotes() const {
  return _impl_.show_renotes_;
}
inline bool TimelinePreferences::show_renotes() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.TimelinePreferences.show_renotes)
  return _internal_show_renotes();
}
inline void TimelinePreferences::_internal_set_show_renotes(bool value) {
  
  _impl_.show_renotes_ = value;
}
inline void TimelinePreferences::set_show_renotes(bool value) {
  _internal_set_show_renotes(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.TimelinePreferences.show_renotes)
}

// bool show_recommended_content = 4;
inline void TimelinePreferences::clear_show_recommended_content() {
  _impl_.show_recommended_content_ = false;
}
inline bool TimelinePreferences::_internal_show_recommended_content() const {
  return _impl_.show_recommended_content_;
}
inline bool TimelinePreferences::show_recommended_content() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.TimelinePreferences.show_recommended_content)
  return _internal_show_recommended_content();
}
inline void TimelinePreferences::_internal_set_show_recommended_content(bool value) {
  
  _impl_.show_recommended_content_ = value;
}
inline void TimelinePreferences::set_show_recommended_content(bool value) {
  _internal_set_show_recommended_content(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.TimelinePreferences.show_recommended_content)
}

// bool show_trending_content = 5;
inline void TimelinePreferences::clear_show_trending_content() {
  _impl_.show_trending_content_ = false;
}
inline bool TimelinePreferences::_internal_show_trending_content() const {
  return _impl_.show_trending_content_;
}
inline bool TimelinePreferences::show_trending_content() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.TimelinePreferences.show_trending_content)
  return _internal_show_trending_content();
}
inline void TimelinePreferences::_internal_set_show_trending_content(bool value) {
  
  _impl_.show_trending_content_ = value;
}
inline void TimelinePreferences::set_show_trending_content(bool value) {
  _internal_set_show_trending_content(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.TimelinePreferences.show_trending_content)
}

// bool sensitive_content_warning = 6;
inline void TimelinePreferences::clear_sensitive_content_warning() {
  _impl_.sensitive_content_warning_ = false;
}
inline bool TimelinePreferences::_internal_sensitive_content_warning() const {
  return _impl_.sensitive_content_warning_;
}
inline bool TimelinePreferences::sensitive_content_warning() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.TimelinePreferences.sensitive_content_warning)
  return _internal_sensitive_content_warning();
}
inline void TimelinePreferences::_internal_set_sensitive_content_warning(bool value) {
  
  _impl_.sensitive_content_warning_ = value;
}
inline void TimelinePreferences::set_sensitive_content_warning(bool value) {
  _internal_set_sensitive_content_warning(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.TimelinePreferences.sensitive_content_warning)
}

// repeated string muted_keywords = 7;
inline int TimelinePreferences::_internal_muted_keywords_size() const {
  return _impl_.muted_keywords_.size();
}
inline int TimelinePreferences::muted_keywords_size() const {
  return _internal_muted_keywords_size();
}
inline void TimelinePreferences::clear_muted_keywords() {
  _impl_.muted_keywords_.Clear();
}
inline std::string* TimelinePreferences::add_muted_keywords() {
  std::string* _s = _internal_add_muted_keywords();
  // @@protoc_insertion_point(field_add_mutable:sonet.timeline.TimelinePreferences.muted_keywords)
  return _s;
}
inline const std::string& TimelinePreferences::_internal_muted_keywords(int index) const {
  return _impl_.muted_keywords_.Get(index);
}
inline const std::string& TimelinePreferences::muted_keywords(int index) const {
  // @@protoc_insertion_point(field_get:sonet.timeline.TimelinePreferences.muted_keywords)
  return _internal_muted_keywords(index);
}
inline std::string* TimelinePreferences::mutable_muted_keywords(int index) {
  // @@protoc_insertion_point(field_mutable:sonet.timeline.TimelinePreferences.muted_keywords)
  return _impl_.muted_keywords_.Mutable(index);
}
inline void TimelinePreferences::set_muted_keywords(int index, const std::string& value) {
  _impl_.muted_keywords_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.TimelinePreferences.muted_keywords)
}
inline void TimelinePreferences::set_muted_keywords(int index, std::string&& value) {
  _impl_.muted_keywords_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sonet.timeline.TimelinePreferences.muted_keywords)
}
inline void TimelinePreferences::set_muted_keywords(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.muted_keywords_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sonet.timeline.TimelinePreferences.muted_keywords)
}
inline void TimelinePreferences::set_muted_keywords(int index, const char* value, size_t size) {
  _impl_.muted_keywords_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sonet.timeline.TimelinePreferences.muted_keywords)
}
inline std::string* TimelinePreferences::_internal_add_muted_keywords() {
  return _impl_.muted_keywords_.Add();
}
inline void TimelinePreferences::add_muted_keywords(const std::string& value) {
  _impl_.muted_keywords_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sonet.timeline.TimelinePreferences.muted_keywords)
}
inline void TimelinePreferences::add_muted_keywords(std::string&& value) {
  _impl_.muted_keywords_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sonet.timeline.TimelinePreferences.muted_keywords)
}
inline void TimelinePreferences::add_muted_keywords(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.muted_keywords_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sonet.timeline.TimelinePreferences.muted_keywords)
}
inline void TimelinePreferences::add_muted_keywords(const char* value, size_t size) {
  _impl_.muted_keywords_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sonet.timeline.TimelinePreferences.muted_keywords)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TimelinePreferences::muted_keywords() const {
  // @@protoc_insertion_point(field_list:sonet.timeline.TimelinePreferences.muted_keywords)
  return _impl_.muted_keywords_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TimelinePreferences::mutable_muted_keywords() {
  // @@protoc_insertion_point(field_mutable_list:sonet.timeline.TimelinePreferences.muted_keywords)
  return &_impl_.muted_keywords_;
}

// repeated string muted_users = 8;
inline int TimelinePreferences::_internal_muted_users_size() const {
  return _impl_.muted_users_.size();
}
inline int TimelinePreferences::muted_users_size() const {
  return _internal_muted_users_size();
}
inline void TimelinePreferences::clear_muted_users() {
  _impl_.muted_users_.Clear();
}
inline std::string* TimelinePreferences::add_muted_users() {
  std::string* _s = _internal_add_muted_users();
  // @@protoc_insertion_point(field_add_mutable:sonet.timeline.TimelinePreferences.muted_users)
  return _s;
}
inline const std::string& TimelinePreferences::_internal_muted_users(int index) const {
  return _impl_.muted_users_.Get(index);
}
inline const std::string& TimelinePreferences::muted_users(int index) const {
  // @@protoc_insertion_point(field_get:sonet.timeline.TimelinePreferences.muted_users)
  return _internal_muted_users(index);
}
inline std::string* TimelinePreferences::mutable_muted_users(int index) {
  // @@protoc_insertion_point(field_mutable:sonet.timeline.TimelinePreferences.muted_users)
  return _impl_.muted_users_.Mutable(index);
}
inline void TimelinePreferences::set_muted_users(int index, const std::string& value) {
  _impl_.muted_users_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.TimelinePreferences.muted_users)
}
inline void TimelinePreferences::set_muted_users(int index, std::string&& value) {
  _impl_.muted_users_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sonet.timeline.TimelinePreferences.muted_users)
}
inline void TimelinePreferences::set_muted_users(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.muted_users_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sonet.timeline.TimelinePreferences.muted_users)
}
inline void TimelinePreferences::set_muted_users(int index, const char* value, size_t size) {
  _impl_.muted_users_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sonet.timeline.TimelinePreferences.muted_users)
}
inline std::string* TimelinePreferences::_internal_add_muted_users() {
  return _impl_.muted_users_.Add();
}
inline void TimelinePreferences::add_muted_users(const std::string& value) {
  _impl_.muted_users_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sonet.timeline.TimelinePreferences.muted_users)
}
inline void TimelinePreferences::add_muted_users(std::string&& value) {
  _impl_.muted_users_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sonet.timeline.TimelinePreferences.muted_users)
}
inline void TimelinePreferences::add_muted_users(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.muted_users_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sonet.timeline.TimelinePreferences.muted_users)
}
inline void TimelinePreferences::add_muted_users(const char* value, size_t size) {
  _impl_.muted_users_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sonet.timeline.TimelinePreferences.muted_users)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TimelinePreferences::muted_users() const {
  // @@protoc_insertion_point(field_list:sonet.timeline.TimelinePreferences.muted_users)
  return _impl_.muted_users_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TimelinePreferences::mutable_muted_users() {
  // @@protoc_insertion_point(field_mutable_list:sonet.timeline.TimelinePreferences.muted_users)
  return &_impl_.muted_users_;
}

// repeated string preferred_languages = 9;
inline int TimelinePreferences::_internal_preferred_languages_size() const {
  return _impl_.preferred_languages_.size();
}
inline int TimelinePreferences::preferred_languages_size() const {
  return _internal_preferred_languages_size();
}
inline void TimelinePreferences::clear_preferred_languages() {
  _impl_.preferred_languages_.Clear();
}
inline std::string* TimelinePreferences::add_preferred_languages() {
  std::string* _s = _internal_add_preferred_languages();
  // @@protoc_insertion_point(field_add_mutable:sonet.timeline.TimelinePreferences.preferred_languages)
  return _s;
}
inline const std::string& TimelinePreferences::_internal_preferred_languages(int index) const {
  return _impl_.preferred_languages_.Get(index);
}
inline const std::string& TimelinePreferences::preferred_languages(int index) const {
  // @@protoc_insertion_point(field_get:sonet.timeline.TimelinePreferences.preferred_languages)
  return _internal_preferred_languages(index);
}
inline std::string* TimelinePreferences::mutable_preferred_languages(int index) {
  // @@protoc_insertion_point(field_mutable:sonet.timeline.TimelinePreferences.preferred_languages)
  return _impl_.preferred_languages_.Mutable(index);
}
inline void TimelinePreferences::set_preferred_languages(int index, const std::string& value) {
  _impl_.preferred_languages_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.TimelinePreferences.preferred_languages)
}
inline void TimelinePreferences::set_preferred_languages(int index, std::string&& value) {
  _impl_.preferred_languages_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sonet.timeline.TimelinePreferences.preferred_languages)
}
inline void TimelinePreferences::set_preferred_languages(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.preferred_languages_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sonet.timeline.TimelinePreferences.preferred_languages)
}
inline void TimelinePreferences::set_preferred_languages(int index, const char* value, size_t size) {
  _impl_.preferred_languages_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sonet.timeline.TimelinePreferences.preferred_languages)
}
inline std::string* TimelinePreferences::_internal_add_preferred_languages() {
  return _impl_.preferred_languages_.Add();
}
inline void TimelinePreferences::add_preferred_languages(const std::string& value) {
  _impl_.preferred_languages_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sonet.timeline.TimelinePreferences.preferred_languages)
}
inline void TimelinePreferences::add_preferred_languages(std::string&& value) {
  _impl_.preferred_languages_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sonet.timeline.TimelinePreferences.preferred_languages)
}
inline void TimelinePreferences::add_preferred_languages(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.preferred_languages_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sonet.timeline.TimelinePreferences.preferred_languages)
}
inline void TimelinePreferences::add_preferred_languages(const char* value, size_t size) {
  _impl_.preferred_languages_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sonet.timeline.TimelinePreferences.preferred_languages)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TimelinePreferences::preferred_languages() const {
  // @@protoc_insertion_point(field_list:sonet.timeline.TimelinePreferences.preferred_languages)
  return _impl_.preferred_languages_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TimelinePreferences::mutable_preferred_languages() {
  // @@protoc_insertion_point(field_mutable_list:sonet.timeline.TimelinePreferences.preferred_languages)
  return &_impl_.preferred_languages_;
}

// int32 timeline_refresh_minutes = 10;
inline void TimelinePreferences::clear_timeline_refresh_minutes() {
  _impl_.timeline_refresh_minutes_ = 0;
}
inline int32_t TimelinePreferences::_internal_timeline_refresh_minutes() const {
  return _impl_.timeline_refresh_minutes_;
}
inline int32_t TimelinePreferences::timeline_refresh_minutes() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.TimelinePreferences.timeline_refresh_minutes)
  return _internal_timeline_refresh_minutes();
}
inline void TimelinePreferences::_internal_set_timeline_refresh_minutes(int32_t value) {
  
  _impl_.timeline_refresh_minutes_ = value;
}
inline void TimelinePreferences::set_timeline_refresh_minutes(int32_t value) {
  _internal_set_timeline_refresh_minutes(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.TimelinePreferences.timeline_refresh_minutes)
}

// -------------------------------------------------------------------

// TimelineUpdate

// .sonet.timeline.TimelineUpdate.UpdateType type = 1;
inline void TimelineUpdate::clear_type() {
  _impl_.type_ = 0;
}
inline ::sonet::timeline::TimelineUpdate_UpdateType TimelineUpdate::_internal_type() const {
  return static_cast< ::sonet::timeline::TimelineUpdate_UpdateType >(_impl_.type_);
}
inline ::sonet::timeline::TimelineUpdate_UpdateType TimelineUpdate::type() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.TimelineUpdate.type)
  return _internal_type();
}
inline void TimelineUpdate::_internal_set_type(::sonet::timeline::TimelineUpdate_UpdateType value) {
  
  _impl_.type_ = value;
}
inline void TimelineUpdate::set_type(::sonet::timeline::TimelineUpdate_UpdateType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.TimelineUpdate.type)
}

// repeated .sonet.timeline.TimelineItem new_items = 2;
inline int TimelineUpdate::_internal_new_items_size() const {
  return _impl_.new_items_.size();
}
inline int TimelineUpdate::new_items_size() const {
  return _internal_new_items_size();
}
inline void TimelineUpdate::clear_new_items() {
  _impl_.new_items_.Clear();
}
inline ::sonet::timeline::TimelineItem* TimelineUpdate::mutable_new_items(int index) {
  // @@protoc_insertion_point(field_mutable:sonet.timeline.TimelineUpdate.new_items)
  return _impl_.new_items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::timeline::TimelineItem >*
TimelineUpdate::mutable_new_items() {
  // @@protoc_insertion_point(field_mutable_list:sonet.timeline.TimelineUpdate.new_items)
  return &_impl_.new_items_;
}
inline const ::sonet::timeline::TimelineItem& TimelineUpdate::_internal_new_items(int index) const {
  return _impl_.new_items_.Get(index);
}
inline const ::sonet::timeline::TimelineItem& TimelineUpdate::new_items(int index) const {
  // @@protoc_insertion_point(field_get:sonet.timeline.TimelineUpdate.new_items)
  return _internal_new_items(index);
}
inline ::sonet::timeline::TimelineItem* TimelineUpdate::_internal_add_new_items() {
  return _impl_.new_items_.Add();
}
inline ::sonet::timeline::TimelineItem* TimelineUpdate::add_new_items() {
  ::sonet::timeline::TimelineItem* _add = _internal_add_new_items();
  // @@protoc_insertion_point(field_add:sonet.timeline.TimelineUpdate.new_items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::timeline::TimelineItem >&
TimelineUpdate::new_items() const {
  // @@protoc_insertion_point(field_list:sonet.timeline.TimelineUpdate.new_items)
  return _impl_.new_items_;
}

// repeated string updated_item_ids = 3;
inline int TimelineUpdate::_internal_updated_item_ids_size() const {
  return _impl_.updated_item_ids_.size();
}
inline int TimelineUpdate::updated_item_ids_size() const {
  return _internal_updated_item_ids_size();
}
inline void TimelineUpdate::clear_updated_item_ids() {
  _impl_.updated_item_ids_.Clear();
}
inline std::string* TimelineUpdate::add_updated_item_ids() {
  std::string* _s = _internal_add_updated_item_ids();
  // @@protoc_insertion_point(field_add_mutable:sonet.timeline.TimelineUpdate.updated_item_ids)
  return _s;
}
inline const std::string& TimelineUpdate::_internal_updated_item_ids(int index) const {
  return _impl_.updated_item_ids_.Get(index);
}
inline const std::string& TimelineUpdate::updated_item_ids(int index) const {
  // @@protoc_insertion_point(field_get:sonet.timeline.TimelineUpdate.updated_item_ids)
  return _internal_updated_item_ids(index);
}
inline std::string* TimelineUpdate::mutable_updated_item_ids(int index) {
  // @@protoc_insertion_point(field_mutable:sonet.timeline.TimelineUpdate.updated_item_ids)
  return _impl_.updated_item_ids_.Mutable(index);
}
inline void TimelineUpdate::set_updated_item_ids(int index, const std::string& value) {
  _impl_.updated_item_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.TimelineUpdate.updated_item_ids)
}
inline void TimelineUpdate::set_updated_item_ids(int index, std::string&& value) {
  _impl_.updated_item_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sonet.timeline.TimelineUpdate.updated_item_ids)
}
inline void TimelineUpdate::set_updated_item_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.updated_item_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sonet.timeline.TimelineUpdate.updated_item_ids)
}
inline void TimelineUpdate::set_updated_item_ids(int index, const char* value, size_t size) {
  _impl_.updated_item_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sonet.timeline.TimelineUpdate.updated_item_ids)
}
inline std::string* TimelineUpdate::_internal_add_updated_item_ids() {
  return _impl_.updated_item_ids_.Add();
}
inline void TimelineUpdate::add_updated_item_ids(const std::string& value) {
  _impl_.updated_item_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sonet.timeline.TimelineUpdate.updated_item_ids)
}
inline void TimelineUpdate::add_updated_item_ids(std::string&& value) {
  _impl_.updated_item_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sonet.timeline.TimelineUpdate.updated_item_ids)
}
inline void TimelineUpdate::add_updated_item_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.updated_item_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sonet.timeline.TimelineUpdate.updated_item_ids)
}
inline void TimelineUpdate::add_updated_item_ids(const char* value, size_t size) {
  _impl_.updated_item_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sonet.timeline.TimelineUpdate.updated_item_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TimelineUpdate::updated_item_ids() const {
  // @@protoc_insertion_point(field_list:sonet.timeline.TimelineUpdate.updated_item_ids)
  return _impl_.updated_item_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TimelineUpdate::mutable_updated_item_ids() {
  // @@protoc_insertion_point(field_mutable_list:sonet.timeline.TimelineUpdate.updated_item_ids)
  return &_impl_.updated_item_ids_;
}

// repeated string deleted_item_ids = 4;
inline int TimelineUpdate::_internal_deleted_item_ids_size() const {
  return _impl_.deleted_item_ids_.size();
}
inline int TimelineUpdate::deleted_item_ids_size() const {
  return _internal_deleted_item_ids_size();
}
inline void TimelineUpdate::clear_deleted_item_ids() {
  _impl_.deleted_item_ids_.Clear();
}
inline std::string* TimelineUpdate::add_deleted_item_ids() {
  std::string* _s = _internal_add_deleted_item_ids();
  // @@protoc_insertion_point(field_add_mutable:sonet.timeline.TimelineUpdate.deleted_item_ids)
  return _s;
}
inline const std::string& TimelineUpdate::_internal_deleted_item_ids(int index) const {
  return _impl_.deleted_item_ids_.Get(index);
}
inline const std::string& TimelineUpdate::deleted_item_ids(int index) const {
  // @@protoc_insertion_point(field_get:sonet.timeline.TimelineUpdate.deleted_item_ids)
  return _internal_deleted_item_ids(index);
}
inline std::string* TimelineUpdate::mutable_deleted_item_ids(int index) {
  // @@protoc_insertion_point(field_mutable:sonet.timeline.TimelineUpdate.deleted_item_ids)
  return _impl_.deleted_item_ids_.Mutable(index);
}
inline void TimelineUpdate::set_deleted_item_ids(int index, const std::string& value) {
  _impl_.deleted_item_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.TimelineUpdate.deleted_item_ids)
}
inline void TimelineUpdate::set_deleted_item_ids(int index, std::string&& value) {
  _impl_.deleted_item_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sonet.timeline.TimelineUpdate.deleted_item_ids)
}
inline void TimelineUpdate::set_deleted_item_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.deleted_item_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sonet.timeline.TimelineUpdate.deleted_item_ids)
}
inline void TimelineUpdate::set_deleted_item_ids(int index, const char* value, size_t size) {
  _impl_.deleted_item_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sonet.timeline.TimelineUpdate.deleted_item_ids)
}
inline std::string* TimelineUpdate::_internal_add_deleted_item_ids() {
  return _impl_.deleted_item_ids_.Add();
}
inline void TimelineUpdate::add_deleted_item_ids(const std::string& value) {
  _impl_.deleted_item_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sonet.timeline.TimelineUpdate.deleted_item_ids)
}
inline void TimelineUpdate::add_deleted_item_ids(std::string&& value) {
  _impl_.deleted_item_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sonet.timeline.TimelineUpdate.deleted_item_ids)
}
inline void TimelineUpdate::add_deleted_item_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.deleted_item_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sonet.timeline.TimelineUpdate.deleted_item_ids)
}
inline void TimelineUpdate::add_deleted_item_ids(const char* value, size_t size) {
  _impl_.deleted_item_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sonet.timeline.TimelineUpdate.deleted_item_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TimelineUpdate::deleted_item_ids() const {
  // @@protoc_insertion_point(field_list:sonet.timeline.TimelineUpdate.deleted_item_ids)
  return _impl_.deleted_item_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TimelineUpdate::mutable_deleted_item_ids() {
  // @@protoc_insertion_point(field_mutable_list:sonet.timeline.TimelineUpdate.deleted_item_ids)
  return &_impl_.deleted_item_ids_;
}

// int32 total_new_items = 5;
inline void TimelineUpdate::clear_total_new_items() {
  _impl_.total_new_items_ = 0;
}
inline int32_t TimelineUpdate::_internal_total_new_items() const {
  return _impl_.total_new_items_;
}
inline int32_t TimelineUpdate::total_new_items() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.TimelineUpdate.total_new_items)
  return _internal_total_new_items();
}
inline void TimelineUpdate::_internal_set_total_new_items(int32_t value) {
  
  _impl_.total_new_items_ = value;
}
inline void TimelineUpdate::set_total_new_items(int32_t value) {
  _internal_set_total_new_items(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.TimelineUpdate.total_new_items)
}

// .sonet.common.Timestamp update_timestamp = 6;
inline bool TimelineUpdate::_internal_has_update_timestamp() const {
  return this != internal_default_instance() && _impl_.update_timestamp_ != nullptr;
}
inline bool TimelineUpdate::has_update_timestamp() const {
  return _internal_has_update_timestamp();
}
inline const ::sonet::common::Timestamp& TimelineUpdate::_internal_update_timestamp() const {
  const ::sonet::common::Timestamp* p = _impl_.update_timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Timestamp&>(
      ::sonet::common::_Timestamp_default_instance_);
}
inline const ::sonet::common::Timestamp& TimelineUpdate::update_timestamp() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.TimelineUpdate.update_timestamp)
  return _internal_update_timestamp();
}
inline void TimelineUpdate::unsafe_arena_set_allocated_update_timestamp(
    ::sonet::common::Timestamp* update_timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_timestamp_);
  }
  _impl_.update_timestamp_ = update_timestamp;
  if (update_timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.timeline.TimelineUpdate.update_timestamp)
}
inline ::sonet::common::Timestamp* TimelineUpdate::release_update_timestamp() {
  
  ::sonet::common::Timestamp* temp = _impl_.update_timestamp_;
  _impl_.update_timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Timestamp* TimelineUpdate::unsafe_arena_release_update_timestamp() {
  // @@protoc_insertion_point(field_release:sonet.timeline.TimelineUpdate.update_timestamp)
  
  ::sonet::common::Timestamp* temp = _impl_.update_timestamp_;
  _impl_.update_timestamp_ = nullptr;
  return temp;
}
inline ::sonet::common::Timestamp* TimelineUpdate::_internal_mutable_update_timestamp() {
  
  if (_impl_.update_timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Timestamp>(GetArenaForAllocation());
    _impl_.update_timestamp_ = p;
  }
  return _impl_.update_timestamp_;
}
inline ::sonet::common::Timestamp* TimelineUpdate::mutable_update_timestamp() {
  ::sonet::common::Timestamp* _msg = _internal_mutable_update_timestamp();
  // @@protoc_insertion_point(field_mutable:sonet.timeline.TimelineUpdate.update_timestamp)
  return _msg;
}
inline void TimelineUpdate::set_allocated_update_timestamp(::sonet::common::Timestamp* update_timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_timestamp_);
  }
  if (update_timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_timestamp));
    if (message_arena != submessage_arena) {
      update_timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.update_timestamp_ = update_timestamp;
  // @@protoc_insertion_point(field_set_allocated:sonet.timeline.TimelineUpdate.update_timestamp)
}

// -------------------------------------------------------------------

// GetTimelineRequest

// string user_id = 1;
inline void GetTimelineRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& GetTimelineRequest::user_id() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.GetTimelineRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTimelineRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.timeline.GetTimelineRequest.user_id)
}
inline std::string* GetTimelineRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:sonet.timeline.GetTimelineRequest.user_id)
  return _s;
}
inline const std::string& GetTimelineRequest::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void GetTimelineRequest::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTimelineRequest::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetTimelineRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:sonet.timeline.GetTimelineRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void GetTimelineRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.timeline.GetTimelineRequest.user_id)
}

// .sonet.timeline.TimelineAlgorithm algorithm = 2;
inline void GetTimelineRequest::clear_algorithm() {
  _impl_.algorithm_ = 0;
}
inline ::sonet::timeline::TimelineAlgorithm GetTimelineRequest::_internal_algorithm() const {
  return static_cast< ::sonet::timeline::TimelineAlgorithm >(_impl_.algorithm_);
}
inline ::sonet::timeline::TimelineAlgorithm GetTimelineRequest::algorithm() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.GetTimelineRequest.algorithm)
  return _internal_algorithm();
}
inline void GetTimelineRequest::_internal_set_algorithm(::sonet::timeline::TimelineAlgorithm value) {
  
  _impl_.algorithm_ = value;
}
inline void GetTimelineRequest::set_algorithm(::sonet::timeline::TimelineAlgorithm value) {
  _internal_set_algorithm(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.GetTimelineRequest.algorithm)
}

// .sonet.common.PaginationRequest pagination = 3;
inline bool GetTimelineRequest::_internal_has_pagination() const {
  return this != internal_default_instance() && _impl_.pagination_ != nullptr;
}
inline bool GetTimelineRequest::has_pagination() const {
  return _internal_has_pagination();
}
inline const ::sonet::common::PaginationRequest& GetTimelineRequest::_internal_pagination() const {
  const ::sonet::common::PaginationRequest* p = _impl_.pagination_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::PaginationRequest&>(
      ::sonet::common::_PaginationRequest_default_instance_);
}
inline const ::sonet::common::PaginationRequest& GetTimelineRequest::pagination() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.GetTimelineRequest.pagination)
  return _internal_pagination();
}
inline void GetTimelineRequest::unsafe_arena_set_allocated_pagination(
    ::sonet::common::PaginationRequest* pagination) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  _impl_.pagination_ = pagination;
  if (pagination) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.timeline.GetTimelineRequest.pagination)
}
inline ::sonet::common::PaginationRequest* GetTimelineRequest::release_pagination() {
  
  ::sonet::common::PaginationRequest* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::PaginationRequest* GetTimelineRequest::unsafe_arena_release_pagination() {
  // @@protoc_insertion_point(field_release:sonet.timeline.GetTimelineRequest.pagination)
  
  ::sonet::common::PaginationRequest* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
  return temp;
}
inline ::sonet::common::PaginationRequest* GetTimelineRequest::_internal_mutable_pagination() {
  
  if (_impl_.pagination_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::PaginationRequest>(GetArenaForAllocation());
    _impl_.pagination_ = p;
  }
  return _impl_.pagination_;
}
inline ::sonet::common::PaginationRequest* GetTimelineRequest::mutable_pagination() {
  ::sonet::common::PaginationRequest* _msg = _internal_mutable_pagination();
  // @@protoc_insertion_point(field_mutable:sonet.timeline.GetTimelineRequest.pagination)
  return _msg;
}
inline void GetTimelineRequest::set_allocated_pagination(::sonet::common::PaginationRequest* pagination) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  if (pagination) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pagination));
    if (message_arena != submessage_arena) {
      pagination = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pagination, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pagination_ = pagination;
  // @@protoc_insertion_point(field_set_allocated:sonet.timeline.GetTimelineRequest.pagination)
}

// bool include_ranking_signals = 4;
inline void GetTimelineRequest::clear_include_ranking_signals() {
  _impl_.include_ranking_signals_ = false;
}
inline bool GetTimelineRequest::_internal_include_ranking_signals() const {
  return _impl_.include_ranking_signals_;
}
inline bool GetTimelineRequest::include_ranking_signals() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.GetTimelineRequest.include_ranking_signals)
  return _internal_include_ranking_signals();
}
inline void GetTimelineRequest::_internal_set_include_ranking_signals(bool value) {
  
  _impl_.include_ranking_signals_ = value;
}
inline void GetTimelineRequest::set_include_ranking_signals(bool value) {
  _internal_set_include_ranking_signals(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.GetTimelineRequest.include_ranking_signals)
}

// bool real_time_updates = 5;
inline void GetTimelineRequest::clear_real_time_updates() {
  _impl_.real_time_updates_ = false;
}
inline bool GetTimelineRequest::_internal_real_time_updates() const {
  return _impl_.real_time_updates_;
}
inline bool GetTimelineRequest::real_time_updates() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.GetTimelineRequest.real_time_updates)
  return _internal_real_time_updates();
}
inline void GetTimelineRequest::_internal_set_real_time_updates(bool value) {
  
  _impl_.real_time_updates_ = value;
}
inline void GetTimelineRequest::set_real_time_updates(bool value) {
  _internal_set_real_time_updates(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.GetTimelineRequest.real_time_updates)
}

// -------------------------------------------------------------------

// GetTimelineResponse

// repeated .sonet.timeline.TimelineItem items = 1;
inline int GetTimelineResponse::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int GetTimelineResponse::items_size() const {
  return _internal_items_size();
}
inline void GetTimelineResponse::clear_items() {
  _impl_.items_.Clear();
}
inline ::sonet::timeline::TimelineItem* GetTimelineResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:sonet.timeline.GetTimelineResponse.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::timeline::TimelineItem >*
GetTimelineResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:sonet.timeline.GetTimelineResponse.items)
  return &_impl_.items_;
}
inline const ::sonet::timeline::TimelineItem& GetTimelineResponse::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::sonet::timeline::TimelineItem& GetTimelineResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:sonet.timeline.GetTimelineResponse.items)
  return _internal_items(index);
}
inline ::sonet::timeline::TimelineItem* GetTimelineResponse::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::sonet::timeline::TimelineItem* GetTimelineResponse::add_items() {
  ::sonet::timeline::TimelineItem* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:sonet.timeline.GetTimelineResponse.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::timeline::TimelineItem >&
GetTimelineResponse::items() const {
  // @@protoc_insertion_point(field_list:sonet.timeline.GetTimelineResponse.items)
  return _impl_.items_;
}

// .sonet.timeline.TimelineMetadata metadata = 2;
inline bool GetTimelineResponse::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool GetTimelineResponse::has_metadata() const {
  return _internal_has_metadata();
}
inline void GetTimelineResponse::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && _impl_.metadata_ != nullptr) {
    delete _impl_.metadata_;
  }
  _impl_.metadata_ = nullptr;
}
inline const ::sonet::timeline::TimelineMetadata& GetTimelineResponse::_internal_metadata() const {
  const ::sonet::timeline::TimelineMetadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::timeline::TimelineMetadata&>(
      ::sonet::timeline::_TimelineMetadata_default_instance_);
}
inline const ::sonet::timeline::TimelineMetadata& GetTimelineResponse::metadata() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.GetTimelineResponse.metadata)
  return _internal_metadata();
}
inline void GetTimelineResponse::unsafe_arena_set_allocated_metadata(
    ::sonet::timeline::TimelineMetadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.timeline.GetTimelineResponse.metadata)
}
inline ::sonet::timeline::TimelineMetadata* GetTimelineResponse::release_metadata() {
  
  ::sonet::timeline::TimelineMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::timeline::TimelineMetadata* GetTimelineResponse::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:sonet.timeline.GetTimelineResponse.metadata)
  
  ::sonet::timeline::TimelineMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::sonet::timeline::TimelineMetadata* GetTimelineResponse::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::timeline::TimelineMetadata>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::sonet::timeline::TimelineMetadata* GetTimelineResponse::mutable_metadata() {
  ::sonet::timeline::TimelineMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:sonet.timeline.GetTimelineResponse.metadata)
  return _msg;
}
inline void GetTimelineResponse::set_allocated_metadata(::sonet::timeline::TimelineMetadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:sonet.timeline.GetTimelineResponse.metadata)
}

// .sonet.common.PaginationResponse pagination = 3;
inline bool GetTimelineResponse::_internal_has_pagination() const {
  return this != internal_default_instance() && _impl_.pagination_ != nullptr;
}
inline bool GetTimelineResponse::has_pagination() const {
  return _internal_has_pagination();
}
inline const ::sonet::common::PaginationResponse& GetTimelineResponse::_internal_pagination() const {
  const ::sonet::common::PaginationResponse* p = _impl_.pagination_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::PaginationResponse&>(
      ::sonet::common::_PaginationResponse_default_instance_);
}
inline const ::sonet::common::PaginationResponse& GetTimelineResponse::pagination() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.GetTimelineResponse.pagination)
  return _internal_pagination();
}
inline void GetTimelineResponse::unsafe_arena_set_allocated_pagination(
    ::sonet::common::PaginationResponse* pagination) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  _impl_.pagination_ = pagination;
  if (pagination) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.timeline.GetTimelineResponse.pagination)
}
inline ::sonet::common::PaginationResponse* GetTimelineResponse::release_pagination() {
  
  ::sonet::common::PaginationResponse* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::PaginationResponse* GetTimelineResponse::unsafe_arena_release_pagination() {
  // @@protoc_insertion_point(field_release:sonet.timeline.GetTimelineResponse.pagination)
  
  ::sonet::common::PaginationResponse* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
  return temp;
}
inline ::sonet::common::PaginationResponse* GetTimelineResponse::_internal_mutable_pagination() {
  
  if (_impl_.pagination_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::PaginationResponse>(GetArenaForAllocation());
    _impl_.pagination_ = p;
  }
  return _impl_.pagination_;
}
inline ::sonet::common::PaginationResponse* GetTimelineResponse::mutable_pagination() {
  ::sonet::common::PaginationResponse* _msg = _internal_mutable_pagination();
  // @@protoc_insertion_point(field_mutable:sonet.timeline.GetTimelineResponse.pagination)
  return _msg;
}
inline void GetTimelineResponse::set_allocated_pagination(::sonet::common::PaginationResponse* pagination) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  if (pagination) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pagination));
    if (message_arena != submessage_arena) {
      pagination = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pagination, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pagination_ = pagination;
  // @@protoc_insertion_point(field_set_allocated:sonet.timeline.GetTimelineResponse.pagination)
}

// bool success = 4;
inline void GetTimelineResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool GetTimelineResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool GetTimelineResponse::success() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.GetTimelineResponse.success)
  return _internal_success();
}
inline void GetTimelineResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void GetTimelineResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.GetTimelineResponse.success)
}

// string error_message = 5;
inline void GetTimelineResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& GetTimelineResponse::error_message() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.GetTimelineResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTimelineResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.timeline.GetTimelineResponse.error_message)
}
inline std::string* GetTimelineResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:sonet.timeline.GetTimelineResponse.error_message)
  return _s;
}
inline const std::string& GetTimelineResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void GetTimelineResponse::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTimelineResponse::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* GetTimelineResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:sonet.timeline.GetTimelineResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void GetTimelineResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.timeline.GetTimelineResponse.error_message)
}

// -------------------------------------------------------------------

// GetUserTimelineRequest

// string target_user_id = 1;
inline void GetUserTimelineRequest::clear_target_user_id() {
  _impl_.target_user_id_.ClearToEmpty();
}
inline const std::string& GetUserTimelineRequest::target_user_id() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.GetUserTimelineRequest.target_user_id)
  return _internal_target_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetUserTimelineRequest::set_target_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.target_user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.timeline.GetUserTimelineRequest.target_user_id)
}
inline std::string* GetUserTimelineRequest::mutable_target_user_id() {
  std::string* _s = _internal_mutable_target_user_id();
  // @@protoc_insertion_point(field_mutable:sonet.timeline.GetUserTimelineRequest.target_user_id)
  return _s;
}
inline const std::string& GetUserTimelineRequest::_internal_target_user_id() const {
  return _impl_.target_user_id_.Get();
}
inline void GetUserTimelineRequest::_internal_set_target_user_id(const std::string& value) {
  
  _impl_.target_user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetUserTimelineRequest::_internal_mutable_target_user_id() {
  
  return _impl_.target_user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetUserTimelineRequest::release_target_user_id() {
  // @@protoc_insertion_point(field_release:sonet.timeline.GetUserTimelineRequest.target_user_id)
  return _impl_.target_user_id_.Release();
}
inline void GetUserTimelineRequest::set_allocated_target_user_id(std::string* target_user_id) {
  if (target_user_id != nullptr) {
    
  } else {
    
  }
  _impl_.target_user_id_.SetAllocated(target_user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.target_user_id_.IsDefault()) {
    _impl_.target_user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.timeline.GetUserTimelineRequest.target_user_id)
}

// string requesting_user_id = 2;
inline void GetUserTimelineRequest::clear_requesting_user_id() {
  _impl_.requesting_user_id_.ClearToEmpty();
}
inline const std::string& GetUserTimelineRequest::requesting_user_id() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.GetUserTimelineRequest.requesting_user_id)
  return _internal_requesting_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetUserTimelineRequest::set_requesting_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.requesting_user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.timeline.GetUserTimelineRequest.requesting_user_id)
}
inline std::string* GetUserTimelineRequest::mutable_requesting_user_id() {
  std::string* _s = _internal_mutable_requesting_user_id();
  // @@protoc_insertion_point(field_mutable:sonet.timeline.GetUserTimelineRequest.requesting_user_id)
  return _s;
}
inline const std::string& GetUserTimelineRequest::_internal_requesting_user_id() const {
  return _impl_.requesting_user_id_.Get();
}
inline void GetUserTimelineRequest::_internal_set_requesting_user_id(const std::string& value) {
  
  _impl_.requesting_user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetUserTimelineRequest::_internal_mutable_requesting_user_id() {
  
  return _impl_.requesting_user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetUserTimelineRequest::release_requesting_user_id() {
  // @@protoc_insertion_point(field_release:sonet.timeline.GetUserTimelineRequest.requesting_user_id)
  return _impl_.requesting_user_id_.Release();
}
inline void GetUserTimelineRequest::set_allocated_requesting_user_id(std::string* requesting_user_id) {
  if (requesting_user_id != nullptr) {
    
  } else {
    
  }
  _impl_.requesting_user_id_.SetAllocated(requesting_user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.requesting_user_id_.IsDefault()) {
    _impl_.requesting_user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.timeline.GetUserTimelineRequest.requesting_user_id)
}

// .sonet.common.PaginationRequest pagination = 3;
inline bool GetUserTimelineRequest::_internal_has_pagination() const {
  return this != internal_default_instance() && _impl_.pagination_ != nullptr;
}
inline bool GetUserTimelineRequest::has_pagination() const {
  return _internal_has_pagination();
}
inline const ::sonet::common::PaginationRequest& GetUserTimelineRequest::_internal_pagination() const {
  const ::sonet::common::PaginationRequest* p = _impl_.pagination_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::PaginationRequest&>(
      ::sonet::common::_PaginationRequest_default_instance_);
}
inline const ::sonet::common::PaginationRequest& GetUserTimelineRequest::pagination() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.GetUserTimelineRequest.pagination)
  return _internal_pagination();
}
inline void GetUserTimelineRequest::unsafe_arena_set_allocated_pagination(
    ::sonet::common::PaginationRequest* pagination) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  _impl_.pagination_ = pagination;
  if (pagination) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.timeline.GetUserTimelineRequest.pagination)
}
inline ::sonet::common::PaginationRequest* GetUserTimelineRequest::release_pagination() {
  
  ::sonet::common::PaginationRequest* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::PaginationRequest* GetUserTimelineRequest::unsafe_arena_release_pagination() {
  // @@protoc_insertion_point(field_release:sonet.timeline.GetUserTimelineRequest.pagination)
  
  ::sonet::common::PaginationRequest* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
  return temp;
}
inline ::sonet::common::PaginationRequest* GetUserTimelineRequest::_internal_mutable_pagination() {
  
  if (_impl_.pagination_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::PaginationRequest>(GetArenaForAllocation());
    _impl_.pagination_ = p;
  }
  return _impl_.pagination_;
}
inline ::sonet::common::PaginationRequest* GetUserTimelineRequest::mutable_pagination() {
  ::sonet::common::PaginationRequest* _msg = _internal_mutable_pagination();
  // @@protoc_insertion_point(field_mutable:sonet.timeline.GetUserTimelineRequest.pagination)
  return _msg;
}
inline void GetUserTimelineRequest::set_allocated_pagination(::sonet::common::PaginationRequest* pagination) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  if (pagination) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pagination));
    if (message_arena != submessage_arena) {
      pagination = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pagination, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pagination_ = pagination;
  // @@protoc_insertion_point(field_set_allocated:sonet.timeline.GetUserTimelineRequest.pagination)
}

// bool include_replies = 4;
inline void GetUserTimelineRequest::clear_include_replies() {
  _impl_.include_replies_ = false;
}
inline bool GetUserTimelineRequest::_internal_include_replies() const {
  return _impl_.include_replies_;
}
inline bool GetUserTimelineRequest::include_replies() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.GetUserTimelineRequest.include_replies)
  return _internal_include_replies();
}
inline void GetUserTimelineRequest::_internal_set_include_replies(bool value) {
  
  _impl_.include_replies_ = value;
}
inline void GetUserTimelineRequest::set_include_replies(bool value) {
  _internal_set_include_replies(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.GetUserTimelineRequest.include_replies)
}

// bool include_renotes = 5;
inline void GetUserTimelineRequest::clear_include_renotes() {
  _impl_.include_renotes_ = false;
}
inline bool GetUserTimelineRequest::_internal_include_renotes() const {
  return _impl_.include_renotes_;
}
inline bool GetUserTimelineRequest::include_renotes() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.GetUserTimelineRequest.include_renotes)
  return _internal_include_renotes();
}
inline void GetUserTimelineRequest::_internal_set_include_renotes(bool value) {
  
  _impl_.include_renotes_ = value;
}
inline void GetUserTimelineRequest::set_include_renotes(bool value) {
  _internal_set_include_renotes(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.GetUserTimelineRequest.include_renotes)
}

// -------------------------------------------------------------------

// GetUserTimelineResponse

// repeated .sonet.timeline.TimelineItem items = 1;
inline int GetUserTimelineResponse::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int GetUserTimelineResponse::items_size() const {
  return _internal_items_size();
}
inline void GetUserTimelineResponse::clear_items() {
  _impl_.items_.Clear();
}
inline ::sonet::timeline::TimelineItem* GetUserTimelineResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:sonet.timeline.GetUserTimelineResponse.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::timeline::TimelineItem >*
GetUserTimelineResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:sonet.timeline.GetUserTimelineResponse.items)
  return &_impl_.items_;
}
inline const ::sonet::timeline::TimelineItem& GetUserTimelineResponse::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::sonet::timeline::TimelineItem& GetUserTimelineResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:sonet.timeline.GetUserTimelineResponse.items)
  return _internal_items(index);
}
inline ::sonet::timeline::TimelineItem* GetUserTimelineResponse::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::sonet::timeline::TimelineItem* GetUserTimelineResponse::add_items() {
  ::sonet::timeline::TimelineItem* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:sonet.timeline.GetUserTimelineResponse.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::timeline::TimelineItem >&
GetUserTimelineResponse::items() const {
  // @@protoc_insertion_point(field_list:sonet.timeline.GetUserTimelineResponse.items)
  return _impl_.items_;
}

// .sonet.common.PaginationResponse pagination = 2;
inline bool GetUserTimelineResponse::_internal_has_pagination() const {
  return this != internal_default_instance() && _impl_.pagination_ != nullptr;
}
inline bool GetUserTimelineResponse::has_pagination() const {
  return _internal_has_pagination();
}
inline const ::sonet::common::PaginationResponse& GetUserTimelineResponse::_internal_pagination() const {
  const ::sonet::common::PaginationResponse* p = _impl_.pagination_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::PaginationResponse&>(
      ::sonet::common::_PaginationResponse_default_instance_);
}
inline const ::sonet::common::PaginationResponse& GetUserTimelineResponse::pagination() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.GetUserTimelineResponse.pagination)
  return _internal_pagination();
}
inline void GetUserTimelineResponse::unsafe_arena_set_allocated_pagination(
    ::sonet::common::PaginationResponse* pagination) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  _impl_.pagination_ = pagination;
  if (pagination) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.timeline.GetUserTimelineResponse.pagination)
}
inline ::sonet::common::PaginationResponse* GetUserTimelineResponse::release_pagination() {
  
  ::sonet::common::PaginationResponse* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::PaginationResponse* GetUserTimelineResponse::unsafe_arena_release_pagination() {
  // @@protoc_insertion_point(field_release:sonet.timeline.GetUserTimelineResponse.pagination)
  
  ::sonet::common::PaginationResponse* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
  return temp;
}
inline ::sonet::common::PaginationResponse* GetUserTimelineResponse::_internal_mutable_pagination() {
  
  if (_impl_.pagination_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::PaginationResponse>(GetArenaForAllocation());
    _impl_.pagination_ = p;
  }
  return _impl_.pagination_;
}
inline ::sonet::common::PaginationResponse* GetUserTimelineResponse::mutable_pagination() {
  ::sonet::common::PaginationResponse* _msg = _internal_mutable_pagination();
  // @@protoc_insertion_point(field_mutable:sonet.timeline.GetUserTimelineResponse.pagination)
  return _msg;
}
inline void GetUserTimelineResponse::set_allocated_pagination(::sonet::common::PaginationResponse* pagination) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  if (pagination) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pagination));
    if (message_arena != submessage_arena) {
      pagination = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pagination, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pagination_ = pagination;
  // @@protoc_insertion_point(field_set_allocated:sonet.timeline.GetUserTimelineResponse.pagination)
}

// bool success = 3;
inline void GetUserTimelineResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool GetUserTimelineResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool GetUserTimelineResponse::success() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.GetUserTimelineResponse.success)
  return _internal_success();
}
inline void GetUserTimelineResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void GetUserTimelineResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.GetUserTimelineResponse.success)
}

// string error_message = 4;
inline void GetUserTimelineResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& GetUserTimelineResponse::error_message() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.GetUserTimelineResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetUserTimelineResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.timeline.GetUserTimelineResponse.error_message)
}
inline std::string* GetUserTimelineResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:sonet.timeline.GetUserTimelineResponse.error_message)
  return _s;
}
inline const std::string& GetUserTimelineResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void GetUserTimelineResponse::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* GetUserTimelineResponse::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* GetUserTimelineResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:sonet.timeline.GetUserTimelineResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void GetUserTimelineResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.timeline.GetUserTimelineResponse.error_message)
}

// -------------------------------------------------------------------

// RefreshTimelineRequest

// string user_id = 1;
inline void RefreshTimelineRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& RefreshTimelineRequest::user_id() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.RefreshTimelineRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RefreshTimelineRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.timeline.RefreshTimelineRequest.user_id)
}
inline std::string* RefreshTimelineRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:sonet.timeline.RefreshTimelineRequest.user_id)
  return _s;
}
inline const std::string& RefreshTimelineRequest::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void RefreshTimelineRequest::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RefreshTimelineRequest::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RefreshTimelineRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:sonet.timeline.RefreshTimelineRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void RefreshTimelineRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.timeline.RefreshTimelineRequest.user_id)
}

// .sonet.common.Timestamp since = 2;
inline bool RefreshTimelineRequest::_internal_has_since() const {
  return this != internal_default_instance() && _impl_.since_ != nullptr;
}
inline bool RefreshTimelineRequest::has_since() const {
  return _internal_has_since();
}
inline const ::sonet::common::Timestamp& RefreshTimelineRequest::_internal_since() const {
  const ::sonet::common::Timestamp* p = _impl_.since_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Timestamp&>(
      ::sonet::common::_Timestamp_default_instance_);
}
inline const ::sonet::common::Timestamp& RefreshTimelineRequest::since() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.RefreshTimelineRequest.since)
  return _internal_since();
}
inline void RefreshTimelineRequest::unsafe_arena_set_allocated_since(
    ::sonet::common::Timestamp* since) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.since_);
  }
  _impl_.since_ = since;
  if (since) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.timeline.RefreshTimelineRequest.since)
}
inline ::sonet::common::Timestamp* RefreshTimelineRequest::release_since() {
  
  ::sonet::common::Timestamp* temp = _impl_.since_;
  _impl_.since_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Timestamp* RefreshTimelineRequest::unsafe_arena_release_since() {
  // @@protoc_insertion_point(field_release:sonet.timeline.RefreshTimelineRequest.since)
  
  ::sonet::common::Timestamp* temp = _impl_.since_;
  _impl_.since_ = nullptr;
  return temp;
}
inline ::sonet::common::Timestamp* RefreshTimelineRequest::_internal_mutable_since() {
  
  if (_impl_.since_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Timestamp>(GetArenaForAllocation());
    _impl_.since_ = p;
  }
  return _impl_.since_;
}
inline ::sonet::common::Timestamp* RefreshTimelineRequest::mutable_since() {
  ::sonet::common::Timestamp* _msg = _internal_mutable_since();
  // @@protoc_insertion_point(field_mutable:sonet.timeline.RefreshTimelineRequest.since)
  return _msg;
}
inline void RefreshTimelineRequest::set_allocated_since(::sonet::common::Timestamp* since) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.since_);
  }
  if (since) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(since));
    if (message_arena != submessage_arena) {
      since = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, since, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.since_ = since;
  // @@protoc_insertion_point(field_set_allocated:sonet.timeline.RefreshTimelineRequest.since)
}

// int32 max_items = 3;
inline void RefreshTimelineRequest::clear_max_items() {
  _impl_.max_items_ = 0;
}
inline int32_t RefreshTimelineRequest::_internal_max_items() const {
  return _impl_.max_items_;
}
inline int32_t RefreshTimelineRequest::max_items() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.RefreshTimelineRequest.max_items)
  return _internal_max_items();
}
inline void RefreshTimelineRequest::_internal_set_max_items(int32_t value) {
  
  _impl_.max_items_ = value;
}
inline void RefreshTimelineRequest::set_max_items(int32_t value) {
  _internal_set_max_items(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.RefreshTimelineRequest.max_items)
}

// -------------------------------------------------------------------

// RefreshTimelineResponse

// repeated .sonet.timeline.TimelineItem new_items = 1;
inline int RefreshTimelineResponse::_internal_new_items_size() const {
  return _impl_.new_items_.size();
}
inline int RefreshTimelineResponse::new_items_size() const {
  return _internal_new_items_size();
}
inline void RefreshTimelineResponse::clear_new_items() {
  _impl_.new_items_.Clear();
}
inline ::sonet::timeline::TimelineItem* RefreshTimelineResponse::mutable_new_items(int index) {
  // @@protoc_insertion_point(field_mutable:sonet.timeline.RefreshTimelineResponse.new_items)
  return _impl_.new_items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::timeline::TimelineItem >*
RefreshTimelineResponse::mutable_new_items() {
  // @@protoc_insertion_point(field_mutable_list:sonet.timeline.RefreshTimelineResponse.new_items)
  return &_impl_.new_items_;
}
inline const ::sonet::timeline::TimelineItem& RefreshTimelineResponse::_internal_new_items(int index) const {
  return _impl_.new_items_.Get(index);
}
inline const ::sonet::timeline::TimelineItem& RefreshTimelineResponse::new_items(int index) const {
  // @@protoc_insertion_point(field_get:sonet.timeline.RefreshTimelineResponse.new_items)
  return _internal_new_items(index);
}
inline ::sonet::timeline::TimelineItem* RefreshTimelineResponse::_internal_add_new_items() {
  return _impl_.new_items_.Add();
}
inline ::sonet::timeline::TimelineItem* RefreshTimelineResponse::add_new_items() {
  ::sonet::timeline::TimelineItem* _add = _internal_add_new_items();
  // @@protoc_insertion_point(field_add:sonet.timeline.RefreshTimelineResponse.new_items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::timeline::TimelineItem >&
RefreshTimelineResponse::new_items() const {
  // @@protoc_insertion_point(field_list:sonet.timeline.RefreshTimelineResponse.new_items)
  return _impl_.new_items_;
}

// int32 total_new_items = 2;
inline void RefreshTimelineResponse::clear_total_new_items() {
  _impl_.total_new_items_ = 0;
}
inline int32_t RefreshTimelineResponse::_internal_total_new_items() const {
  return _impl_.total_new_items_;
}
inline int32_t RefreshTimelineResponse::total_new_items() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.RefreshTimelineResponse.total_new_items)
  return _internal_total_new_items();
}
inline void RefreshTimelineResponse::_internal_set_total_new_items(int32_t value) {
  
  _impl_.total_new_items_ = value;
}
inline void RefreshTimelineResponse::set_total_new_items(int32_t value) {
  _internal_set_total_new_items(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.RefreshTimelineResponse.total_new_items)
}

// bool has_more = 3;
inline void RefreshTimelineResponse::clear_has_more() {
  _impl_.has_more_ = false;
}
inline bool RefreshTimelineResponse::_internal_has_more() const {
  return _impl_.has_more_;
}
inline bool RefreshTimelineResponse::has_more() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.RefreshTimelineResponse.has_more)
  return _internal_has_more();
}
inline void RefreshTimelineResponse::_internal_set_has_more(bool value) {
  
  _impl_.has_more_ = value;
}
inline void RefreshTimelineResponse::set_has_more(bool value) {
  _internal_set_has_more(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.RefreshTimelineResponse.has_more)
}

// bool success = 4;
inline void RefreshTimelineResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool RefreshTimelineResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool RefreshTimelineResponse::success() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.RefreshTimelineResponse.success)
  return _internal_success();
}
inline void RefreshTimelineResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void RefreshTimelineResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.RefreshTimelineResponse.success)
}

// string error_message = 5;
inline void RefreshTimelineResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& RefreshTimelineResponse::error_message() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.RefreshTimelineResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RefreshTimelineResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.timeline.RefreshTimelineResponse.error_message)
}
inline std::string* RefreshTimelineResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:sonet.timeline.RefreshTimelineResponse.error_message)
  return _s;
}
inline const std::string& RefreshTimelineResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void RefreshTimelineResponse::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* RefreshTimelineResponse::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* RefreshTimelineResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:sonet.timeline.RefreshTimelineResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void RefreshTimelineResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.timeline.RefreshTimelineResponse.error_message)
}

// -------------------------------------------------------------------

// MarkTimelineReadRequest

// string user_id = 1;
inline void MarkTimelineReadRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& MarkTimelineReadRequest::user_id() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.MarkTimelineReadRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarkTimelineReadRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.timeline.MarkTimelineReadRequest.user_id)
}
inline std::string* MarkTimelineReadRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:sonet.timeline.MarkTimelineReadRequest.user_id)
  return _s;
}
inline const std::string& MarkTimelineReadRequest::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void MarkTimelineReadRequest::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MarkTimelineReadRequest::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* MarkTimelineReadRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:sonet.timeline.MarkTimelineReadRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void MarkTimelineReadRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.timeline.MarkTimelineReadRequest.user_id)
}

// .sonet.common.Timestamp read_until = 2;
inline bool MarkTimelineReadRequest::_internal_has_read_until() const {
  return this != internal_default_instance() && _impl_.read_until_ != nullptr;
}
inline bool MarkTimelineReadRequest::has_read_until() const {
  return _internal_has_read_until();
}
inline const ::sonet::common::Timestamp& MarkTimelineReadRequest::_internal_read_until() const {
  const ::sonet::common::Timestamp* p = _impl_.read_until_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Timestamp&>(
      ::sonet::common::_Timestamp_default_instance_);
}
inline const ::sonet::common::Timestamp& MarkTimelineReadRequest::read_until() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.MarkTimelineReadRequest.read_until)
  return _internal_read_until();
}
inline void MarkTimelineReadRequest::unsafe_arena_set_allocated_read_until(
    ::sonet::common::Timestamp* read_until) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.read_until_);
  }
  _impl_.read_until_ = read_until;
  if (read_until) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.timeline.MarkTimelineReadRequest.read_until)
}
inline ::sonet::common::Timestamp* MarkTimelineReadRequest::release_read_until() {
  
  ::sonet::common::Timestamp* temp = _impl_.read_until_;
  _impl_.read_until_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Timestamp* MarkTimelineReadRequest::unsafe_arena_release_read_until() {
  // @@protoc_insertion_point(field_release:sonet.timeline.MarkTimelineReadRequest.read_until)
  
  ::sonet::common::Timestamp* temp = _impl_.read_until_;
  _impl_.read_until_ = nullptr;
  return temp;
}
inline ::sonet::common::Timestamp* MarkTimelineReadRequest::_internal_mutable_read_until() {
  
  if (_impl_.read_until_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Timestamp>(GetArenaForAllocation());
    _impl_.read_until_ = p;
  }
  return _impl_.read_until_;
}
inline ::sonet::common::Timestamp* MarkTimelineReadRequest::mutable_read_until() {
  ::sonet::common::Timestamp* _msg = _internal_mutable_read_until();
  // @@protoc_insertion_point(field_mutable:sonet.timeline.MarkTimelineReadRequest.read_until)
  return _msg;
}
inline void MarkTimelineReadRequest::set_allocated_read_until(::sonet::common::Timestamp* read_until) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.read_until_);
  }
  if (read_until) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(read_until));
    if (message_arena != submessage_arena) {
      read_until = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, read_until, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.read_until_ = read_until;
  // @@protoc_insertion_point(field_set_allocated:sonet.timeline.MarkTimelineReadRequest.read_until)
}

// -------------------------------------------------------------------

// MarkTimelineReadResponse

// bool success = 1;
inline void MarkTimelineReadResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool MarkTimelineReadResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool MarkTimelineReadResponse::success() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.MarkTimelineReadResponse.success)
  return _internal_success();
}
inline void MarkTimelineReadResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void MarkTimelineReadResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.MarkTimelineReadResponse.success)
}

// string error_message = 2;
inline void MarkTimelineReadResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& MarkTimelineReadResponse::error_message() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.MarkTimelineReadResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarkTimelineReadResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.timeline.MarkTimelineReadResponse.error_message)
}
inline std::string* MarkTimelineReadResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:sonet.timeline.MarkTimelineReadResponse.error_message)
  return _s;
}
inline const std::string& MarkTimelineReadResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void MarkTimelineReadResponse::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* MarkTimelineReadResponse::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* MarkTimelineReadResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:sonet.timeline.MarkTimelineReadResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void MarkTimelineReadResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.timeline.MarkTimelineReadResponse.error_message)
}

// -------------------------------------------------------------------

// UpdateTimelinePreferencesRequest

// string user_id = 1;
inline void UpdateTimelinePreferencesRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& UpdateTimelinePreferencesRequest::user_id() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.UpdateTimelinePreferencesRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateTimelinePreferencesRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.timeline.UpdateTimelinePreferencesRequest.user_id)
}
inline std::string* UpdateTimelinePreferencesRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:sonet.timeline.UpdateTimelinePreferencesRequest.user_id)
  return _s;
}
inline const std::string& UpdateTimelinePreferencesRequest::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void UpdateTimelinePreferencesRequest::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateTimelinePreferencesRequest::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateTimelinePreferencesRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:sonet.timeline.UpdateTimelinePreferencesRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void UpdateTimelinePreferencesRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.timeline.UpdateTimelinePreferencesRequest.user_id)
}

// .sonet.timeline.TimelinePreferences preferences = 2;
inline bool UpdateTimelinePreferencesRequest::_internal_has_preferences() const {
  return this != internal_default_instance() && _impl_.preferences_ != nullptr;
}
inline bool UpdateTimelinePreferencesRequest::has_preferences() const {
  return _internal_has_preferences();
}
inline void UpdateTimelinePreferencesRequest::clear_preferences() {
  if (GetArenaForAllocation() == nullptr && _impl_.preferences_ != nullptr) {
    delete _impl_.preferences_;
  }
  _impl_.preferences_ = nullptr;
}
inline const ::sonet::timeline::TimelinePreferences& UpdateTimelinePreferencesRequest::_internal_preferences() const {
  const ::sonet::timeline::TimelinePreferences* p = _impl_.preferences_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::timeline::TimelinePreferences&>(
      ::sonet::timeline::_TimelinePreferences_default_instance_);
}
inline const ::sonet::timeline::TimelinePreferences& UpdateTimelinePreferencesRequest::preferences() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.UpdateTimelinePreferencesRequest.preferences)
  return _internal_preferences();
}
inline void UpdateTimelinePreferencesRequest::unsafe_arena_set_allocated_preferences(
    ::sonet::timeline::TimelinePreferences* preferences) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.preferences_);
  }
  _impl_.preferences_ = preferences;
  if (preferences) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.timeline.UpdateTimelinePreferencesRequest.preferences)
}
inline ::sonet::timeline::TimelinePreferences* UpdateTimelinePreferencesRequest::release_preferences() {
  
  ::sonet::timeline::TimelinePreferences* temp = _impl_.preferences_;
  _impl_.preferences_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::timeline::TimelinePreferences* UpdateTimelinePreferencesRequest::unsafe_arena_release_preferences() {
  // @@protoc_insertion_point(field_release:sonet.timeline.UpdateTimelinePreferencesRequest.preferences)
  
  ::sonet::timeline::TimelinePreferences* temp = _impl_.preferences_;
  _impl_.preferences_ = nullptr;
  return temp;
}
inline ::sonet::timeline::TimelinePreferences* UpdateTimelinePreferencesRequest::_internal_mutable_preferences() {
  
  if (_impl_.preferences_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::timeline::TimelinePreferences>(GetArenaForAllocation());
    _impl_.preferences_ = p;
  }
  return _impl_.preferences_;
}
inline ::sonet::timeline::TimelinePreferences* UpdateTimelinePreferencesRequest::mutable_preferences() {
  ::sonet::timeline::TimelinePreferences* _msg = _internal_mutable_preferences();
  // @@protoc_insertion_point(field_mutable:sonet.timeline.UpdateTimelinePreferencesRequest.preferences)
  return _msg;
}
inline void UpdateTimelinePreferencesRequest::set_allocated_preferences(::sonet::timeline::TimelinePreferences* preferences) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.preferences_;
  }
  if (preferences) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(preferences);
    if (message_arena != submessage_arena) {
      preferences = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, preferences, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.preferences_ = preferences;
  // @@protoc_insertion_point(field_set_allocated:sonet.timeline.UpdateTimelinePreferencesRequest.preferences)
}

// -------------------------------------------------------------------

// UpdateTimelinePreferencesResponse

// bool success = 1;
inline void UpdateTimelinePreferencesResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool UpdateTimelinePreferencesResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool UpdateTimelinePreferencesResponse::success() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.UpdateTimelinePreferencesResponse.success)
  return _internal_success();
}
inline void UpdateTimelinePreferencesResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void UpdateTimelinePreferencesResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.UpdateTimelinePreferencesResponse.success)
}

// string error_message = 2;
inline void UpdateTimelinePreferencesResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& UpdateTimelinePreferencesResponse::error_message() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.UpdateTimelinePreferencesResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateTimelinePreferencesResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.timeline.UpdateTimelinePreferencesResponse.error_message)
}
inline std::string* UpdateTimelinePreferencesResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:sonet.timeline.UpdateTimelinePreferencesResponse.error_message)
  return _s;
}
inline const std::string& UpdateTimelinePreferencesResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void UpdateTimelinePreferencesResponse::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateTimelinePreferencesResponse::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateTimelinePreferencesResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:sonet.timeline.UpdateTimelinePreferencesResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void UpdateTimelinePreferencesResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.timeline.UpdateTimelinePreferencesResponse.error_message)
}

// -------------------------------------------------------------------

// GetTimelinePreferencesRequest

// string user_id = 1;
inline void GetTimelinePreferencesRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& GetTimelinePreferencesRequest::user_id() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.GetTimelinePreferencesRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTimelinePreferencesRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.timeline.GetTimelinePreferencesRequest.user_id)
}
inline std::string* GetTimelinePreferencesRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:sonet.timeline.GetTimelinePreferencesRequest.user_id)
  return _s;
}
inline const std::string& GetTimelinePreferencesRequest::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void GetTimelinePreferencesRequest::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTimelinePreferencesRequest::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetTimelinePreferencesRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:sonet.timeline.GetTimelinePreferencesRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void GetTimelinePreferencesRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.timeline.GetTimelinePreferencesRequest.user_id)
}

// -------------------------------------------------------------------

// GetTimelinePreferencesResponse

// .sonet.timeline.TimelinePreferences preferences = 1;
inline bool GetTimelinePreferencesResponse::_internal_has_preferences() const {
  return this != internal_default_instance() && _impl_.preferences_ != nullptr;
}
inline bool GetTimelinePreferencesResponse::has_preferences() const {
  return _internal_has_preferences();
}
inline void GetTimelinePreferencesResponse::clear_preferences() {
  if (GetArenaForAllocation() == nullptr && _impl_.preferences_ != nullptr) {
    delete _impl_.preferences_;
  }
  _impl_.preferences_ = nullptr;
}
inline const ::sonet::timeline::TimelinePreferences& GetTimelinePreferencesResponse::_internal_preferences() const {
  const ::sonet::timeline::TimelinePreferences* p = _impl_.preferences_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::timeline::TimelinePreferences&>(
      ::sonet::timeline::_TimelinePreferences_default_instance_);
}
inline const ::sonet::timeline::TimelinePreferences& GetTimelinePreferencesResponse::preferences() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.GetTimelinePreferencesResponse.preferences)
  return _internal_preferences();
}
inline void GetTimelinePreferencesResponse::unsafe_arena_set_allocated_preferences(
    ::sonet::timeline::TimelinePreferences* preferences) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.preferences_);
  }
  _impl_.preferences_ = preferences;
  if (preferences) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.timeline.GetTimelinePreferencesResponse.preferences)
}
inline ::sonet::timeline::TimelinePreferences* GetTimelinePreferencesResponse::release_preferences() {
  
  ::sonet::timeline::TimelinePreferences* temp = _impl_.preferences_;
  _impl_.preferences_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::timeline::TimelinePreferences* GetTimelinePreferencesResponse::unsafe_arena_release_preferences() {
  // @@protoc_insertion_point(field_release:sonet.timeline.GetTimelinePreferencesResponse.preferences)
  
  ::sonet::timeline::TimelinePreferences* temp = _impl_.preferences_;
  _impl_.preferences_ = nullptr;
  return temp;
}
inline ::sonet::timeline::TimelinePreferences* GetTimelinePreferencesResponse::_internal_mutable_preferences() {
  
  if (_impl_.preferences_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::timeline::TimelinePreferences>(GetArenaForAllocation());
    _impl_.preferences_ = p;
  }
  return _impl_.preferences_;
}
inline ::sonet::timeline::TimelinePreferences* GetTimelinePreferencesResponse::mutable_preferences() {
  ::sonet::timeline::TimelinePreferences* _msg = _internal_mutable_preferences();
  // @@protoc_insertion_point(field_mutable:sonet.timeline.GetTimelinePreferencesResponse.preferences)
  return _msg;
}
inline void GetTimelinePreferencesResponse::set_allocated_preferences(::sonet::timeline::TimelinePreferences* preferences) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.preferences_;
  }
  if (preferences) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(preferences);
    if (message_arena != submessage_arena) {
      preferences = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, preferences, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.preferences_ = preferences;
  // @@protoc_insertion_point(field_set_allocated:sonet.timeline.GetTimelinePreferencesResponse.preferences)
}

// bool success = 2;
inline void GetTimelinePreferencesResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool GetTimelinePreferencesResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool GetTimelinePreferencesResponse::success() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.GetTimelinePreferencesResponse.success)
  return _internal_success();
}
inline void GetTimelinePreferencesResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void GetTimelinePreferencesResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.GetTimelinePreferencesResponse.success)
}

// string error_message = 3;
inline void GetTimelinePreferencesResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& GetTimelinePreferencesResponse::error_message() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.GetTimelinePreferencesResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTimelinePreferencesResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.timeline.GetTimelinePreferencesResponse.error_message)
}
inline std::string* GetTimelinePreferencesResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:sonet.timeline.GetTimelinePreferencesResponse.error_message)
  return _s;
}
inline const std::string& GetTimelinePreferencesResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void GetTimelinePreferencesResponse::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTimelinePreferencesResponse::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* GetTimelinePreferencesResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:sonet.timeline.GetTimelinePreferencesResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void GetTimelinePreferencesResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.timeline.GetTimelinePreferencesResponse.error_message)
}

// -------------------------------------------------------------------

// SubscribeTimelineUpdatesRequest

// string user_id = 1;
inline void SubscribeTimelineUpdatesRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& SubscribeTimelineUpdatesRequest::user_id() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.SubscribeTimelineUpdatesRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscribeTimelineUpdatesRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.timeline.SubscribeTimelineUpdatesRequest.user_id)
}
inline std::string* SubscribeTimelineUpdatesRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:sonet.timeline.SubscribeTimelineUpdatesRequest.user_id)
  return _s;
}
inline const std::string& SubscribeTimelineUpdatesRequest::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void SubscribeTimelineUpdatesRequest::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SubscribeTimelineUpdatesRequest::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SubscribeTimelineUpdatesRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:sonet.timeline.SubscribeTimelineUpdatesRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void SubscribeTimelineUpdatesRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.timeline.SubscribeTimelineUpdatesRequest.user_id)
}

// bool include_metadata = 2;
inline void SubscribeTimelineUpdatesRequest::clear_include_metadata() {
  _impl_.include_metadata_ = false;
}
inline bool SubscribeTimelineUpdatesRequest::_internal_include_metadata() const {
  return _impl_.include_metadata_;
}
inline bool SubscribeTimelineUpdatesRequest::include_metadata() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.SubscribeTimelineUpdatesRequest.include_metadata)
  return _internal_include_metadata();
}
inline void SubscribeTimelineUpdatesRequest::_internal_set_include_metadata(bool value) {
  
  _impl_.include_metadata_ = value;
}
inline void SubscribeTimelineUpdatesRequest::set_include_metadata(bool value) {
  _internal_set_include_metadata(value);
  // @@protoc_insertion_point(field_set:sonet.timeline.SubscribeTimelineUpdatesRequest.include_metadata)
}

// -------------------------------------------------------------------

// HealthCheckRequest

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// HealthCheckResponse

// string status = 1;
inline void HealthCheckResponse::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& HealthCheckResponse::status() const {
  // @@protoc_insertion_point(field_get:sonet.timeline.HealthCheckResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HealthCheckResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.timeline.HealthCheckResponse.status)
}
inline std::string* HealthCheckResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:sonet.timeline.HealthCheckResponse.status)
  return _s;
}
inline const std::string& HealthCheckResponse::_internal_status() const {
  return _impl_.status_.Get();
}
inline void HealthCheckResponse::_internal_set_status(const std::string& value) {
  
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* HealthCheckResponse::_internal_mutable_status() {
  
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* HealthCheckResponse::release_status() {
  // @@protoc_insertion_point(field_release:sonet.timeline.HealthCheckResponse.status)
  return _impl_.status_.Release();
}
inline void HealthCheckResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.timeline.HealthCheckResponse.status)
}

// map<string, string> details = 2;
inline int HealthCheckResponse::_internal_details_size() const {
  return _impl_.details_.size();
}
inline int HealthCheckResponse::details_size() const {
  return _internal_details_size();
}
inline void HealthCheckResponse::clear_details() {
  _impl_.details_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
HealthCheckResponse::_internal_details() const {
  return _impl_.details_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
HealthCheckResponse::details() const {
  // @@protoc_insertion_point(field_map:sonet.timeline.HealthCheckResponse.details)
  return _internal_details();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
HealthCheckResponse::_internal_mutable_details() {
  return _impl_.details_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
HealthCheckResponse::mutable_details() {
  // @@protoc_insertion_point(field_mutable_map:sonet.timeline.HealthCheckResponse.details)
  return _internal_mutable_details();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace timeline
}  // namespace sonet

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::sonet::timeline::TimelineUpdate_UpdateType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sonet::timeline::TimelineUpdate_UpdateType>() {
  return ::sonet::timeline::TimelineUpdate_UpdateType_descriptor();
}
template <> struct is_proto_enum< ::sonet::timeline::TimelineAlgorithm> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sonet::timeline::TimelineAlgorithm>() {
  return ::sonet::timeline::TimelineAlgorithm_descriptor();
}
template <> struct is_proto_enum< ::sonet::timeline::ContentSource> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sonet::timeline::ContentSource>() {
  return ::sonet::timeline::ContentSource_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_services_2ftimeline_2eproto
