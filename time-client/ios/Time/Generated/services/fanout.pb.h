// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: services/fanout.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_services_2ffanout_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_services_2ffanout_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common/timestamp.pb.h"
#include "services/note.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_services_2ffanout_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_services_2ffanout_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_services_2ffanout_2eproto;
namespace sonet {
namespace fanout {
class CancelFanoutJobRequest;
struct CancelFanoutJobRequestDefaultTypeInternal;
extern CancelFanoutJobRequestDefaultTypeInternal _CancelFanoutJobRequest_default_instance_;
class CancelFanoutJobResponse;
struct CancelFanoutJobResponseDefaultTypeInternal;
extern CancelFanoutJobResponseDefaultTypeInternal _CancelFanoutJobResponse_default_instance_;
class DeliveryTarget;
struct DeliveryTargetDefaultTypeInternal;
extern DeliveryTargetDefaultTypeInternal _DeliveryTarget_default_instance_;
class FanoutJob;
struct FanoutJobDefaultTypeInternal;
extern FanoutJobDefaultTypeInternal _FanoutJob_default_instance_;
class FanoutMetrics;
struct FanoutMetricsDefaultTypeInternal;
extern FanoutMetricsDefaultTypeInternal _FanoutMetrics_default_instance_;
class FanoutMetrics_DeliveryByTierEntry_DoNotUse;
struct FanoutMetrics_DeliveryByTierEntry_DoNotUseDefaultTypeInternal;
extern FanoutMetrics_DeliveryByTierEntry_DoNotUseDefaultTypeInternal _FanoutMetrics_DeliveryByTierEntry_DoNotUse_default_instance_;
class FollowerBatch;
struct FollowerBatchDefaultTypeInternal;
extern FollowerBatchDefaultTypeInternal _FollowerBatch_default_instance_;
class GetFanoutJobStatusRequest;
struct GetFanoutJobStatusRequestDefaultTypeInternal;
extern GetFanoutJobStatusRequestDefaultTypeInternal _GetFanoutJobStatusRequest_default_instance_;
class GetFanoutJobStatusResponse;
struct GetFanoutJobStatusResponseDefaultTypeInternal;
extern GetFanoutJobStatusResponseDefaultTypeInternal _GetFanoutJobStatusResponse_default_instance_;
class GetFanoutMetricsRequest;
struct GetFanoutMetricsRequestDefaultTypeInternal;
extern GetFanoutMetricsRequestDefaultTypeInternal _GetFanoutMetricsRequest_default_instance_;
class GetFanoutMetricsResponse;
struct GetFanoutMetricsResponseDefaultTypeInternal;
extern GetFanoutMetricsResponseDefaultTypeInternal _GetFanoutMetricsResponse_default_instance_;
class GetFanoutMetricsResponse_SummaryStatsEntry_DoNotUse;
struct GetFanoutMetricsResponse_SummaryStatsEntry_DoNotUseDefaultTypeInternal;
extern GetFanoutMetricsResponse_SummaryStatsEntry_DoNotUseDefaultTypeInternal _GetFanoutMetricsResponse_SummaryStatsEntry_DoNotUse_default_instance_;
class GetUserTierRequest;
struct GetUserTierRequestDefaultTypeInternal;
extern GetUserTierRequestDefaultTypeInternal _GetUserTierRequest_default_instance_;
class GetUserTierResponse;
struct GetUserTierResponseDefaultTypeInternal;
extern GetUserTierResponseDefaultTypeInternal _GetUserTierResponse_default_instance_;
class HealthCheckRequest;
struct HealthCheckRequestDefaultTypeInternal;
extern HealthCheckRequestDefaultTypeInternal _HealthCheckRequest_default_instance_;
class HealthCheckResponse;
struct HealthCheckResponseDefaultTypeInternal;
extern HealthCheckResponseDefaultTypeInternal _HealthCheckResponse_default_instance_;
class HealthCheckResponse_DetailsEntry_DoNotUse;
struct HealthCheckResponse_DetailsEntry_DoNotUseDefaultTypeInternal;
extern HealthCheckResponse_DetailsEntry_DoNotUseDefaultTypeInternal _HealthCheckResponse_DetailsEntry_DoNotUse_default_instance_;
class InitiateFanoutRequest;
struct InitiateFanoutRequestDefaultTypeInternal;
extern InitiateFanoutRequestDefaultTypeInternal _InitiateFanoutRequest_default_instance_;
class InitiateFanoutResponse;
struct InitiateFanoutResponseDefaultTypeInternal;
extern InitiateFanoutResponseDefaultTypeInternal _InitiateFanoutResponse_default_instance_;
class ProcessFollowerBatchRequest;
struct ProcessFollowerBatchRequestDefaultTypeInternal;
extern ProcessFollowerBatchRequestDefaultTypeInternal _ProcessFollowerBatchRequest_default_instance_;
class ProcessFollowerBatchResponse;
struct ProcessFollowerBatchResponseDefaultTypeInternal;
extern ProcessFollowerBatchResponseDefaultTypeInternal _ProcessFollowerBatchResponse_default_instance_;
}  // namespace fanout
}  // namespace sonet
PROTOBUF_NAMESPACE_OPEN
template<> ::sonet::fanout::CancelFanoutJobRequest* Arena::CreateMaybeMessage<::sonet::fanout::CancelFanoutJobRequest>(Arena*);
template<> ::sonet::fanout::CancelFanoutJobResponse* Arena::CreateMaybeMessage<::sonet::fanout::CancelFanoutJobResponse>(Arena*);
template<> ::sonet::fanout::DeliveryTarget* Arena::CreateMaybeMessage<::sonet::fanout::DeliveryTarget>(Arena*);
template<> ::sonet::fanout::FanoutJob* Arena::CreateMaybeMessage<::sonet::fanout::FanoutJob>(Arena*);
template<> ::sonet::fanout::FanoutMetrics* Arena::CreateMaybeMessage<::sonet::fanout::FanoutMetrics>(Arena*);
template<> ::sonet::fanout::FanoutMetrics_DeliveryByTierEntry_DoNotUse* Arena::CreateMaybeMessage<::sonet::fanout::FanoutMetrics_DeliveryByTierEntry_DoNotUse>(Arena*);
template<> ::sonet::fanout::FollowerBatch* Arena::CreateMaybeMessage<::sonet::fanout::FollowerBatch>(Arena*);
template<> ::sonet::fanout::GetFanoutJobStatusRequest* Arena::CreateMaybeMessage<::sonet::fanout::GetFanoutJobStatusRequest>(Arena*);
template<> ::sonet::fanout::GetFanoutJobStatusResponse* Arena::CreateMaybeMessage<::sonet::fanout::GetFanoutJobStatusResponse>(Arena*);
template<> ::sonet::fanout::GetFanoutMetricsRequest* Arena::CreateMaybeMessage<::sonet::fanout::GetFanoutMetricsRequest>(Arena*);
template<> ::sonet::fanout::GetFanoutMetricsResponse* Arena::CreateMaybeMessage<::sonet::fanout::GetFanoutMetricsResponse>(Arena*);
template<> ::sonet::fanout::GetFanoutMetricsResponse_SummaryStatsEntry_DoNotUse* Arena::CreateMaybeMessage<::sonet::fanout::GetFanoutMetricsResponse_SummaryStatsEntry_DoNotUse>(Arena*);
template<> ::sonet::fanout::GetUserTierRequest* Arena::CreateMaybeMessage<::sonet::fanout::GetUserTierRequest>(Arena*);
template<> ::sonet::fanout::GetUserTierResponse* Arena::CreateMaybeMessage<::sonet::fanout::GetUserTierResponse>(Arena*);
template<> ::sonet::fanout::HealthCheckRequest* Arena::CreateMaybeMessage<::sonet::fanout::HealthCheckRequest>(Arena*);
template<> ::sonet::fanout::HealthCheckResponse* Arena::CreateMaybeMessage<::sonet::fanout::HealthCheckResponse>(Arena*);
template<> ::sonet::fanout::HealthCheckResponse_DetailsEntry_DoNotUse* Arena::CreateMaybeMessage<::sonet::fanout::HealthCheckResponse_DetailsEntry_DoNotUse>(Arena*);
template<> ::sonet::fanout::InitiateFanoutRequest* Arena::CreateMaybeMessage<::sonet::fanout::InitiateFanoutRequest>(Arena*);
template<> ::sonet::fanout::InitiateFanoutResponse* Arena::CreateMaybeMessage<::sonet::fanout::InitiateFanoutResponse>(Arena*);
template<> ::sonet::fanout::ProcessFollowerBatchRequest* Arena::CreateMaybeMessage<::sonet::fanout::ProcessFollowerBatchRequest>(Arena*);
template<> ::sonet::fanout::ProcessFollowerBatchResponse* Arena::CreateMaybeMessage<::sonet::fanout::ProcessFollowerBatchResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sonet {
namespace fanout {

enum FanoutJob_JobStatus : int {
  FanoutJob_JobStatus_JOB_STATUS_UNKNOWN = 0,
  FanoutJob_JobStatus_JOB_STATUS_PENDING = 1,
  FanoutJob_JobStatus_JOB_STATUS_PROCESSING = 2,
  FanoutJob_JobStatus_JOB_STATUS_COMPLETED = 3,
  FanoutJob_JobStatus_JOB_STATUS_FAILED = 4,
  FanoutJob_JobStatus_JOB_STATUS_CANCELLED = 5,
  FanoutJob_JobStatus_FanoutJob_JobStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FanoutJob_JobStatus_FanoutJob_JobStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FanoutJob_JobStatus_IsValid(int value);
constexpr FanoutJob_JobStatus FanoutJob_JobStatus_JobStatus_MIN = FanoutJob_JobStatus_JOB_STATUS_UNKNOWN;
constexpr FanoutJob_JobStatus FanoutJob_JobStatus_JobStatus_MAX = FanoutJob_JobStatus_JOB_STATUS_CANCELLED;
constexpr int FanoutJob_JobStatus_JobStatus_ARRAYSIZE = FanoutJob_JobStatus_JobStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FanoutJob_JobStatus_descriptor();
template<typename T>
inline const std::string& FanoutJob_JobStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FanoutJob_JobStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FanoutJob_JobStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FanoutJob_JobStatus_descriptor(), enum_t_value);
}
inline bool FanoutJob_JobStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FanoutJob_JobStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FanoutJob_JobStatus>(
    FanoutJob_JobStatus_descriptor(), name, value);
}
enum FanoutStrategy : int {
  FANOUT_STRATEGY_UNKNOWN = 0,
  FANOUT_STRATEGY_PUSH = 1,
  FANOUT_STRATEGY_PULL = 2,
  FANOUT_STRATEGY_HYBRID = 3,
  FanoutStrategy_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FanoutStrategy_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FanoutStrategy_IsValid(int value);
constexpr FanoutStrategy FanoutStrategy_MIN = FANOUT_STRATEGY_UNKNOWN;
constexpr FanoutStrategy FanoutStrategy_MAX = FANOUT_STRATEGY_HYBRID;
constexpr int FanoutStrategy_ARRAYSIZE = FanoutStrategy_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FanoutStrategy_descriptor();
template<typename T>
inline const std::string& FanoutStrategy_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FanoutStrategy>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FanoutStrategy_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FanoutStrategy_descriptor(), enum_t_value);
}
inline bool FanoutStrategy_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FanoutStrategy* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FanoutStrategy>(
    FanoutStrategy_descriptor(), name, value);
}
enum UserTier : int {
  USER_TIER_UNKNOWN = 0,
  USER_TIER_REGULAR = 1,
  USER_TIER_POPULAR = 2,
  USER_TIER_CELEBRITY = 3,
  USER_TIER_VERIFIED = 4,
  UserTier_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UserTier_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UserTier_IsValid(int value);
constexpr UserTier UserTier_MIN = USER_TIER_UNKNOWN;
constexpr UserTier UserTier_MAX = USER_TIER_VERIFIED;
constexpr int UserTier_ARRAYSIZE = UserTier_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UserTier_descriptor();
template<typename T>
inline const std::string& UserTier_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UserTier>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UserTier_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UserTier_descriptor(), enum_t_value);
}
inline bool UserTier_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserTier* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UserTier>(
    UserTier_descriptor(), name, value);
}
// ===================================================================

class FanoutJob final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.fanout.FanoutJob) */ {
 public:
  inline FanoutJob() : FanoutJob(nullptr) {}
  ~FanoutJob() override;
  explicit PROTOBUF_CONSTEXPR FanoutJob(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FanoutJob(const FanoutJob& from);
  FanoutJob(FanoutJob&& from) noexcept
    : FanoutJob() {
    *this = ::std::move(from);
  }

  inline FanoutJob& operator=(const FanoutJob& from) {
    CopyFrom(from);
    return *this;
  }
  inline FanoutJob& operator=(FanoutJob&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FanoutJob& default_instance() {
    return *internal_default_instance();
  }
  static inline const FanoutJob* internal_default_instance() {
    return reinterpret_cast<const FanoutJob*>(
               &_FanoutJob_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FanoutJob& a, FanoutJob& b) {
    a.Swap(&b);
  }
  inline void Swap(FanoutJob* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FanoutJob* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FanoutJob* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FanoutJob>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FanoutJob& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FanoutJob& from) {
    FanoutJob::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FanoutJob* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.fanout.FanoutJob";
  }
  protected:
  explicit FanoutJob(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FanoutJob_JobStatus JobStatus;
  static constexpr JobStatus JOB_STATUS_UNKNOWN =
    FanoutJob_JobStatus_JOB_STATUS_UNKNOWN;
  static constexpr JobStatus JOB_STATUS_PENDING =
    FanoutJob_JobStatus_JOB_STATUS_PENDING;
  static constexpr JobStatus JOB_STATUS_PROCESSING =
    FanoutJob_JobStatus_JOB_STATUS_PROCESSING;
  static constexpr JobStatus JOB_STATUS_COMPLETED =
    FanoutJob_JobStatus_JOB_STATUS_COMPLETED;
  static constexpr JobStatus JOB_STATUS_FAILED =
    FanoutJob_JobStatus_JOB_STATUS_FAILED;
  static constexpr JobStatus JOB_STATUS_CANCELLED =
    FanoutJob_JobStatus_JOB_STATUS_CANCELLED;
  static inline bool JobStatus_IsValid(int value) {
    return FanoutJob_JobStatus_IsValid(value);
  }
  static constexpr JobStatus JobStatus_MIN =
    FanoutJob_JobStatus_JobStatus_MIN;
  static constexpr JobStatus JobStatus_MAX =
    FanoutJob_JobStatus_JobStatus_MAX;
  static constexpr int JobStatus_ARRAYSIZE =
    FanoutJob_JobStatus_JobStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  JobStatus_descriptor() {
    return FanoutJob_JobStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& JobStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, JobStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function JobStatus_Name.");
    return FanoutJob_JobStatus_Name(enum_t_value);
  }
  static inline bool JobStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      JobStatus* value) {
    return FanoutJob_JobStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kJobIdFieldNumber = 1,
    kNoteIdFieldNumber = 2,
    kAuthorIdFieldNumber = 3,
    kErrorMessageFieldNumber = 14,
    kCreatedAtFieldNumber = 6,
    kStartedAtFieldNumber = 7,
    kCompletedAtFieldNumber = 8,
    kAuthorTierFieldNumber = 4,
    kStrategyFieldNumber = 5,
    kStatusFieldNumber = 9,
    kTotalFollowersFieldNumber = 10,
    kProcessedFollowersFieldNumber = 11,
    kFailedDeliveriesFieldNumber = 12,
    kProcessingTimeMsFieldNumber = 13,
  };
  // string job_id = 1;
  void clear_job_id();
  const std::string& job_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_job_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_job_id();
  PROTOBUF_NODISCARD std::string* release_job_id();
  void set_allocated_job_id(std::string* job_id);
  private:
  const std::string& _internal_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_job_id(const std::string& value);
  std::string* _internal_mutable_job_id();
  public:

  // string note_id = 2;
  void clear_note_id();
  const std::string& note_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_note_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_note_id();
  PROTOBUF_NODISCARD std::string* release_note_id();
  void set_allocated_note_id(std::string* note_id);
  private:
  const std::string& _internal_note_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_note_id(const std::string& value);
  std::string* _internal_mutable_note_id();
  public:

  // string author_id = 3;
  void clear_author_id();
  const std::string& author_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_author_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_author_id();
  PROTOBUF_NODISCARD std::string* release_author_id();
  void set_allocated_author_id(std::string* author_id);
  private:
  const std::string& _internal_author_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_author_id(const std::string& value);
  std::string* _internal_mutable_author_id();
  public:

  // string error_message = 14;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // .sonet.common.Timestamp created_at = 6;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::sonet::common::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::sonet::common::Timestamp* release_created_at();
  ::sonet::common::Timestamp* mutable_created_at();
  void set_allocated_created_at(::sonet::common::Timestamp* created_at);
  private:
  const ::sonet::common::Timestamp& _internal_created_at() const;
  ::sonet::common::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::sonet::common::Timestamp* created_at);
  ::sonet::common::Timestamp* unsafe_arena_release_created_at();

  // .sonet.common.Timestamp started_at = 7;
  bool has_started_at() const;
  private:
  bool _internal_has_started_at() const;
  public:
  void clear_started_at();
  const ::sonet::common::Timestamp& started_at() const;
  PROTOBUF_NODISCARD ::sonet::common::Timestamp* release_started_at();
  ::sonet::common::Timestamp* mutable_started_at();
  void set_allocated_started_at(::sonet::common::Timestamp* started_at);
  private:
  const ::sonet::common::Timestamp& _internal_started_at() const;
  ::sonet::common::Timestamp* _internal_mutable_started_at();
  public:
  void unsafe_arena_set_allocated_started_at(
      ::sonet::common::Timestamp* started_at);
  ::sonet::common::Timestamp* unsafe_arena_release_started_at();

  // .sonet.common.Timestamp completed_at = 8;
  bool has_completed_at() const;
  private:
  bool _internal_has_completed_at() const;
  public:
  void clear_completed_at();
  const ::sonet::common::Timestamp& completed_at() const;
  PROTOBUF_NODISCARD ::sonet::common::Timestamp* release_completed_at();
  ::sonet::common::Timestamp* mutable_completed_at();
  void set_allocated_completed_at(::sonet::common::Timestamp* completed_at);
  private:
  const ::sonet::common::Timestamp& _internal_completed_at() const;
  ::sonet::common::Timestamp* _internal_mutable_completed_at();
  public:
  void unsafe_arena_set_allocated_completed_at(
      ::sonet::common::Timestamp* completed_at);
  ::sonet::common::Timestamp* unsafe_arena_release_completed_at();

  // .sonet.fanout.UserTier author_tier = 4;
  void clear_author_tier();
  ::sonet::fanout::UserTier author_tier() const;
  void set_author_tier(::sonet::fanout::UserTier value);
  private:
  ::sonet::fanout::UserTier _internal_author_tier() const;
  void _internal_set_author_tier(::sonet::fanout::UserTier value);
  public:

  // .sonet.fanout.FanoutStrategy strategy = 5;
  void clear_strategy();
  ::sonet::fanout::FanoutStrategy strategy() const;
  void set_strategy(::sonet::fanout::FanoutStrategy value);
  private:
  ::sonet::fanout::FanoutStrategy _internal_strategy() const;
  void _internal_set_strategy(::sonet::fanout::FanoutStrategy value);
  public:

  // .sonet.fanout.FanoutJob.JobStatus status = 9;
  void clear_status();
  ::sonet::fanout::FanoutJob_JobStatus status() const;
  void set_status(::sonet::fanout::FanoutJob_JobStatus value);
  private:
  ::sonet::fanout::FanoutJob_JobStatus _internal_status() const;
  void _internal_set_status(::sonet::fanout::FanoutJob_JobStatus value);
  public:

  // int32 total_followers = 10;
  void clear_total_followers();
  int32_t total_followers() const;
  void set_total_followers(int32_t value);
  private:
  int32_t _internal_total_followers() const;
  void _internal_set_total_followers(int32_t value);
  public:

  // int32 processed_followers = 11;
  void clear_processed_followers();
  int32_t processed_followers() const;
  void set_processed_followers(int32_t value);
  private:
  int32_t _internal_processed_followers() const;
  void _internal_set_processed_followers(int32_t value);
  public:

  // int32 failed_deliveries = 12;
  void clear_failed_deliveries();
  int32_t failed_deliveries() const;
  void set_failed_deliveries(int32_t value);
  private:
  int32_t _internal_failed_deliveries() const;
  void _internal_set_failed_deliveries(int32_t value);
  public:

  // double processing_time_ms = 13;
  void clear_processing_time_ms();
  double processing_time_ms() const;
  void set_processing_time_ms(double value);
  private:
  double _internal_processing_time_ms() const;
  void _internal_set_processing_time_ms(double value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.fanout.FanoutJob)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr job_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr note_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr author_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    ::sonet::common::Timestamp* created_at_;
    ::sonet::common::Timestamp* started_at_;
    ::sonet::common::Timestamp* completed_at_;
    int author_tier_;
    int strategy_;
    int status_;
    int32_t total_followers_;
    int32_t processed_followers_;
    int32_t failed_deliveries_;
    double processing_time_ms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2ffanout_2eproto;
};
// -------------------------------------------------------------------

class FollowerBatch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.fanout.FollowerBatch) */ {
 public:
  inline FollowerBatch() : FollowerBatch(nullptr) {}
  ~FollowerBatch() override;
  explicit PROTOBUF_CONSTEXPR FollowerBatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FollowerBatch(const FollowerBatch& from);
  FollowerBatch(FollowerBatch&& from) noexcept
    : FollowerBatch() {
    *this = ::std::move(from);
  }

  inline FollowerBatch& operator=(const FollowerBatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline FollowerBatch& operator=(FollowerBatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FollowerBatch& default_instance() {
    return *internal_default_instance();
  }
  static inline const FollowerBatch* internal_default_instance() {
    return reinterpret_cast<const FollowerBatch*>(
               &_FollowerBatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FollowerBatch& a, FollowerBatch& b) {
    a.Swap(&b);
  }
  inline void Swap(FollowerBatch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FollowerBatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FollowerBatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FollowerBatch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FollowerBatch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FollowerBatch& from) {
    FollowerBatch::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FollowerBatch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.fanout.FollowerBatch";
  }
  protected:
  explicit FollowerBatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFollowerIdsFieldNumber = 3,
    kBatchIdFieldNumber = 1,
    kJobIdFieldNumber = 2,
    kBatchSizeFieldNumber = 4,
    kBatchNumberFieldNumber = 5,
    kStrategyFieldNumber = 6,
  };
  // repeated string follower_ids = 3;
  int follower_ids_size() const;
  private:
  int _internal_follower_ids_size() const;
  public:
  void clear_follower_ids();
  const std::string& follower_ids(int index) const;
  std::string* mutable_follower_ids(int index);
  void set_follower_ids(int index, const std::string& value);
  void set_follower_ids(int index, std::string&& value);
  void set_follower_ids(int index, const char* value);
  void set_follower_ids(int index, const char* value, size_t size);
  std::string* add_follower_ids();
  void add_follower_ids(const std::string& value);
  void add_follower_ids(std::string&& value);
  void add_follower_ids(const char* value);
  void add_follower_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& follower_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_follower_ids();
  private:
  const std::string& _internal_follower_ids(int index) const;
  std::string* _internal_add_follower_ids();
  public:

  // string batch_id = 1;
  void clear_batch_id();
  const std::string& batch_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_batch_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_batch_id();
  PROTOBUF_NODISCARD std::string* release_batch_id();
  void set_allocated_batch_id(std::string* batch_id);
  private:
  const std::string& _internal_batch_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_batch_id(const std::string& value);
  std::string* _internal_mutable_batch_id();
  public:

  // string job_id = 2;
  void clear_job_id();
  const std::string& job_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_job_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_job_id();
  PROTOBUF_NODISCARD std::string* release_job_id();
  void set_allocated_job_id(std::string* job_id);
  private:
  const std::string& _internal_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_job_id(const std::string& value);
  std::string* _internal_mutable_job_id();
  public:

  // int32 batch_size = 4;
  void clear_batch_size();
  int32_t batch_size() const;
  void set_batch_size(int32_t value);
  private:
  int32_t _internal_batch_size() const;
  void _internal_set_batch_size(int32_t value);
  public:

  // int32 batch_number = 5;
  void clear_batch_number();
  int32_t batch_number() const;
  void set_batch_number(int32_t value);
  private:
  int32_t _internal_batch_number() const;
  void _internal_set_batch_number(int32_t value);
  public:

  // .sonet.fanout.FanoutStrategy strategy = 6;
  void clear_strategy();
  ::sonet::fanout::FanoutStrategy strategy() const;
  void set_strategy(::sonet::fanout::FanoutStrategy value);
  private:
  ::sonet::fanout::FanoutStrategy _internal_strategy() const;
  void _internal_set_strategy(::sonet::fanout::FanoutStrategy value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.fanout.FollowerBatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> follower_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr batch_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr job_id_;
    int32_t batch_size_;
    int32_t batch_number_;
    int strategy_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2ffanout_2eproto;
};
// -------------------------------------------------------------------

class DeliveryTarget final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.fanout.DeliveryTarget) */ {
 public:
  inline DeliveryTarget() : DeliveryTarget(nullptr) {}
  ~DeliveryTarget() override;
  explicit PROTOBUF_CONSTEXPR DeliveryTarget(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeliveryTarget(const DeliveryTarget& from);
  DeliveryTarget(DeliveryTarget&& from) noexcept
    : DeliveryTarget() {
    *this = ::std::move(from);
  }

  inline DeliveryTarget& operator=(const DeliveryTarget& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeliveryTarget& operator=(DeliveryTarget&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeliveryTarget& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeliveryTarget* internal_default_instance() {
    return reinterpret_cast<const DeliveryTarget*>(
               &_DeliveryTarget_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DeliveryTarget& a, DeliveryTarget& b) {
    a.Swap(&b);
  }
  inline void Swap(DeliveryTarget* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeliveryTarget* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeliveryTarget* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeliveryTarget>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeliveryTarget& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeliveryTarget& from) {
    DeliveryTarget::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeliveryTarget* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.fanout.DeliveryTarget";
  }
  protected:
  explicit DeliveryTarget(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kTimelineKeyFieldNumber = 2,
    kLastSeenFieldNumber = 4,
    kIsActiveUserFieldNumber = 3,
    kFollowerTierFieldNumber = 5,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string timeline_key = 2;
  void clear_timeline_key();
  const std::string& timeline_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_timeline_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_timeline_key();
  PROTOBUF_NODISCARD std::string* release_timeline_key();
  void set_allocated_timeline_key(std::string* timeline_key);
  private:
  const std::string& _internal_timeline_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timeline_key(const std::string& value);
  std::string* _internal_mutable_timeline_key();
  public:

  // .sonet.common.Timestamp last_seen = 4;
  bool has_last_seen() const;
  private:
  bool _internal_has_last_seen() const;
  public:
  void clear_last_seen();
  const ::sonet::common::Timestamp& last_seen() const;
  PROTOBUF_NODISCARD ::sonet::common::Timestamp* release_last_seen();
  ::sonet::common::Timestamp* mutable_last_seen();
  void set_allocated_last_seen(::sonet::common::Timestamp* last_seen);
  private:
  const ::sonet::common::Timestamp& _internal_last_seen() const;
  ::sonet::common::Timestamp* _internal_mutable_last_seen();
  public:
  void unsafe_arena_set_allocated_last_seen(
      ::sonet::common::Timestamp* last_seen);
  ::sonet::common::Timestamp* unsafe_arena_release_last_seen();

  // bool is_active_user = 3;
  void clear_is_active_user();
  bool is_active_user() const;
  void set_is_active_user(bool value);
  private:
  bool _internal_is_active_user() const;
  void _internal_set_is_active_user(bool value);
  public:

  // int32 follower_tier = 5;
  void clear_follower_tier();
  int32_t follower_tier() const;
  void set_follower_tier(int32_t value);
  private:
  int32_t _internal_follower_tier() const;
  void _internal_set_follower_tier(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.fanout.DeliveryTarget)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr timeline_key_;
    ::sonet::common::Timestamp* last_seen_;
    bool is_active_user_;
    int32_t follower_tier_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2ffanout_2eproto;
};
// -------------------------------------------------------------------

class FanoutMetrics_DeliveryByTierEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<FanoutMetrics_DeliveryByTierEntry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<FanoutMetrics_DeliveryByTierEntry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> SuperType;
  FanoutMetrics_DeliveryByTierEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR FanoutMetrics_DeliveryByTierEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit FanoutMetrics_DeliveryByTierEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const FanoutMetrics_DeliveryByTierEntry_DoNotUse& other);
  static const FanoutMetrics_DeliveryByTierEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const FanoutMetrics_DeliveryByTierEntry_DoNotUse*>(&_FanoutMetrics_DeliveryByTierEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "sonet.fanout.FanoutMetrics.DeliveryByTierEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_services_2ffanout_2eproto;
};

// -------------------------------------------------------------------

class FanoutMetrics final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.fanout.FanoutMetrics) */ {
 public:
  inline FanoutMetrics() : FanoutMetrics(nullptr) {}
  ~FanoutMetrics() override;
  explicit PROTOBUF_CONSTEXPR FanoutMetrics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FanoutMetrics(const FanoutMetrics& from);
  FanoutMetrics(FanoutMetrics&& from) noexcept
    : FanoutMetrics() {
    *this = ::std::move(from);
  }

  inline FanoutMetrics& operator=(const FanoutMetrics& from) {
    CopyFrom(from);
    return *this;
  }
  inline FanoutMetrics& operator=(FanoutMetrics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FanoutMetrics& default_instance() {
    return *internal_default_instance();
  }
  static inline const FanoutMetrics* internal_default_instance() {
    return reinterpret_cast<const FanoutMetrics*>(
               &_FanoutMetrics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FanoutMetrics& a, FanoutMetrics& b) {
    a.Swap(&b);
  }
  inline void Swap(FanoutMetrics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FanoutMetrics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FanoutMetrics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FanoutMetrics>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FanoutMetrics& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FanoutMetrics& from) {
    FanoutMetrics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FanoutMetrics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.fanout.FanoutMetrics";
  }
  protected:
  explicit FanoutMetrics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kDeliveryByTierFieldNumber = 7,
    kAuthorIdFieldNumber = 1,
    kNoteIdFieldNumber = 2,
    kCompletedAtFieldNumber = 8,
    kTotalDeliveriesFieldNumber = 3,
    kSuccessfulDeliveriesFieldNumber = 4,
    kFailedDeliveriesFieldNumber = 5,
    kAvgDeliveryTimeMsFieldNumber = 6,
  };
  // map<string, int64> delivery_by_tier = 7;
  int delivery_by_tier_size() const;
  private:
  int _internal_delivery_by_tier_size() const;
  public:
  void clear_delivery_by_tier();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      _internal_delivery_by_tier() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      _internal_mutable_delivery_by_tier();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      delivery_by_tier() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      mutable_delivery_by_tier();

  // string author_id = 1;
  void clear_author_id();
  const std::string& author_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_author_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_author_id();
  PROTOBUF_NODISCARD std::string* release_author_id();
  void set_allocated_author_id(std::string* author_id);
  private:
  const std::string& _internal_author_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_author_id(const std::string& value);
  std::string* _internal_mutable_author_id();
  public:

  // string note_id = 2;
  void clear_note_id();
  const std::string& note_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_note_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_note_id();
  PROTOBUF_NODISCARD std::string* release_note_id();
  void set_allocated_note_id(std::string* note_id);
  private:
  const std::string& _internal_note_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_note_id(const std::string& value);
  std::string* _internal_mutable_note_id();
  public:

  // .sonet.common.Timestamp completed_at = 8;
  bool has_completed_at() const;
  private:
  bool _internal_has_completed_at() const;
  public:
  void clear_completed_at();
  const ::sonet::common::Timestamp& completed_at() const;
  PROTOBUF_NODISCARD ::sonet::common::Timestamp* release_completed_at();
  ::sonet::common::Timestamp* mutable_completed_at();
  void set_allocated_completed_at(::sonet::common::Timestamp* completed_at);
  private:
  const ::sonet::common::Timestamp& _internal_completed_at() const;
  ::sonet::common::Timestamp* _internal_mutable_completed_at();
  public:
  void unsafe_arena_set_allocated_completed_at(
      ::sonet::common::Timestamp* completed_at);
  ::sonet::common::Timestamp* unsafe_arena_release_completed_at();

  // int64 total_deliveries = 3;
  void clear_total_deliveries();
  int64_t total_deliveries() const;
  void set_total_deliveries(int64_t value);
  private:
  int64_t _internal_total_deliveries() const;
  void _internal_set_total_deliveries(int64_t value);
  public:

  // int64 successful_deliveries = 4;
  void clear_successful_deliveries();
  int64_t successful_deliveries() const;
  void set_successful_deliveries(int64_t value);
  private:
  int64_t _internal_successful_deliveries() const;
  void _internal_set_successful_deliveries(int64_t value);
  public:

  // int64 failed_deliveries = 5;
  void clear_failed_deliveries();
  int64_t failed_deliveries() const;
  void set_failed_deliveries(int64_t value);
  private:
  int64_t _internal_failed_deliveries() const;
  void _internal_set_failed_deliveries(int64_t value);
  public:

  // double avg_delivery_time_ms = 6;
  void clear_avg_delivery_time_ms();
  double avg_delivery_time_ms() const;
  void set_avg_delivery_time_ms(double value);
  private:
  double _internal_avg_delivery_time_ms() const;
  void _internal_set_avg_delivery_time_ms(double value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.fanout.FanoutMetrics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        FanoutMetrics_DeliveryByTierEntry_DoNotUse,
        std::string, int64_t,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> delivery_by_tier_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr author_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr note_id_;
    ::sonet::common::Timestamp* completed_at_;
    int64_t total_deliveries_;
    int64_t successful_deliveries_;
    int64_t failed_deliveries_;
    double avg_delivery_time_ms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2ffanout_2eproto;
};
// -------------------------------------------------------------------

class InitiateFanoutRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.fanout.InitiateFanoutRequest) */ {
 public:
  inline InitiateFanoutRequest() : InitiateFanoutRequest(nullptr) {}
  ~InitiateFanoutRequest() override;
  explicit PROTOBUF_CONSTEXPR InitiateFanoutRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitiateFanoutRequest(const InitiateFanoutRequest& from);
  InitiateFanoutRequest(InitiateFanoutRequest&& from) noexcept
    : InitiateFanoutRequest() {
    *this = ::std::move(from);
  }

  inline InitiateFanoutRequest& operator=(const InitiateFanoutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitiateFanoutRequest& operator=(InitiateFanoutRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitiateFanoutRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitiateFanoutRequest* internal_default_instance() {
    return reinterpret_cast<const InitiateFanoutRequest*>(
               &_InitiateFanoutRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(InitiateFanoutRequest& a, InitiateFanoutRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InitiateFanoutRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitiateFanoutRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitiateFanoutRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitiateFanoutRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InitiateFanoutRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InitiateFanoutRequest& from) {
    InitiateFanoutRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitiateFanoutRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.fanout.InitiateFanoutRequest";
  }
  protected:
  explicit InitiateFanoutRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpecificFollowersFieldNumber = 4,
    kNoteFieldNumber = 1,
    kStrategyFieldNumber = 2,
    kUrgentFieldNumber = 3,
  };
  // repeated string specific_followers = 4;
  int specific_followers_size() const;
  private:
  int _internal_specific_followers_size() const;
  public:
  void clear_specific_followers();
  const std::string& specific_followers(int index) const;
  std::string* mutable_specific_followers(int index);
  void set_specific_followers(int index, const std::string& value);
  void set_specific_followers(int index, std::string&& value);
  void set_specific_followers(int index, const char* value);
  void set_specific_followers(int index, const char* value, size_t size);
  std::string* add_specific_followers();
  void add_specific_followers(const std::string& value);
  void add_specific_followers(std::string&& value);
  void add_specific_followers(const char* value);
  void add_specific_followers(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& specific_followers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_specific_followers();
  private:
  const std::string& _internal_specific_followers(int index) const;
  std::string* _internal_add_specific_followers();
  public:

  // .sonet.note.Note note = 1;
  bool has_note() const;
  private:
  bool _internal_has_note() const;
  public:
  void clear_note();
  const ::sonet::note::Note& note() const;
  PROTOBUF_NODISCARD ::sonet::note::Note* release_note();
  ::sonet::note::Note* mutable_note();
  void set_allocated_note(::sonet::note::Note* note);
  private:
  const ::sonet::note::Note& _internal_note() const;
  ::sonet::note::Note* _internal_mutable_note();
  public:
  void unsafe_arena_set_allocated_note(
      ::sonet::note::Note* note);
  ::sonet::note::Note* unsafe_arena_release_note();

  // .sonet.fanout.FanoutStrategy strategy = 2;
  void clear_strategy();
  ::sonet::fanout::FanoutStrategy strategy() const;
  void set_strategy(::sonet::fanout::FanoutStrategy value);
  private:
  ::sonet::fanout::FanoutStrategy _internal_strategy() const;
  void _internal_set_strategy(::sonet::fanout::FanoutStrategy value);
  public:

  // bool urgent = 3;
  void clear_urgent();
  bool urgent() const;
  void set_urgent(bool value);
  private:
  bool _internal_urgent() const;
  void _internal_set_urgent(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.fanout.InitiateFanoutRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> specific_followers_;
    ::sonet::note::Note* note_;
    int strategy_;
    bool urgent_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2ffanout_2eproto;
};
// -------------------------------------------------------------------

class InitiateFanoutResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.fanout.InitiateFanoutResponse) */ {
 public:
  inline InitiateFanoutResponse() : InitiateFanoutResponse(nullptr) {}
  ~InitiateFanoutResponse() override;
  explicit PROTOBUF_CONSTEXPR InitiateFanoutResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitiateFanoutResponse(const InitiateFanoutResponse& from);
  InitiateFanoutResponse(InitiateFanoutResponse&& from) noexcept
    : InitiateFanoutResponse() {
    *this = ::std::move(from);
  }

  inline InitiateFanoutResponse& operator=(const InitiateFanoutResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitiateFanoutResponse& operator=(InitiateFanoutResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitiateFanoutResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitiateFanoutResponse* internal_default_instance() {
    return reinterpret_cast<const InitiateFanoutResponse*>(
               &_InitiateFanoutResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(InitiateFanoutResponse& a, InitiateFanoutResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(InitiateFanoutResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitiateFanoutResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitiateFanoutResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitiateFanoutResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InitiateFanoutResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InitiateFanoutResponse& from) {
    InitiateFanoutResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitiateFanoutResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.fanout.InitiateFanoutResponse";
  }
  protected:
  explicit InitiateFanoutResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJobIdFieldNumber = 1,
    kErrorMessageFieldNumber = 6,
    kStrategyUsedFieldNumber = 2,
    kEstimatedDeliveriesFieldNumber = 3,
    kEstimatedCompletionTimeMsFieldNumber = 4,
    kSuccessFieldNumber = 5,
  };
  // string job_id = 1;
  void clear_job_id();
  const std::string& job_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_job_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_job_id();
  PROTOBUF_NODISCARD std::string* release_job_id();
  void set_allocated_job_id(std::string* job_id);
  private:
  const std::string& _internal_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_job_id(const std::string& value);
  std::string* _internal_mutable_job_id();
  public:

  // string error_message = 6;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // .sonet.fanout.FanoutStrategy strategy_used = 2;
  void clear_strategy_used();
  ::sonet::fanout::FanoutStrategy strategy_used() const;
  void set_strategy_used(::sonet::fanout::FanoutStrategy value);
  private:
  ::sonet::fanout::FanoutStrategy _internal_strategy_used() const;
  void _internal_set_strategy_used(::sonet::fanout::FanoutStrategy value);
  public:

  // int32 estimated_deliveries = 3;
  void clear_estimated_deliveries();
  int32_t estimated_deliveries() const;
  void set_estimated_deliveries(int32_t value);
  private:
  int32_t _internal_estimated_deliveries() const;
  void _internal_set_estimated_deliveries(int32_t value);
  public:

  // double estimated_completion_time_ms = 4;
  void clear_estimated_completion_time_ms();
  double estimated_completion_time_ms() const;
  void set_estimated_completion_time_ms(double value);
  private:
  double _internal_estimated_completion_time_ms() const;
  void _internal_set_estimated_completion_time_ms(double value);
  public:

  // bool success = 5;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.fanout.InitiateFanoutResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr job_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    int strategy_used_;
    int32_t estimated_deliveries_;
    double estimated_completion_time_ms_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2ffanout_2eproto;
};
// -------------------------------------------------------------------

class GetFanoutJobStatusRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.fanout.GetFanoutJobStatusRequest) */ {
 public:
  inline GetFanoutJobStatusRequest() : GetFanoutJobStatusRequest(nullptr) {}
  ~GetFanoutJobStatusRequest() override;
  explicit PROTOBUF_CONSTEXPR GetFanoutJobStatusRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFanoutJobStatusRequest(const GetFanoutJobStatusRequest& from);
  GetFanoutJobStatusRequest(GetFanoutJobStatusRequest&& from) noexcept
    : GetFanoutJobStatusRequest() {
    *this = ::std::move(from);
  }

  inline GetFanoutJobStatusRequest& operator=(const GetFanoutJobStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFanoutJobStatusRequest& operator=(GetFanoutJobStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFanoutJobStatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFanoutJobStatusRequest* internal_default_instance() {
    return reinterpret_cast<const GetFanoutJobStatusRequest*>(
               &_GetFanoutJobStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetFanoutJobStatusRequest& a, GetFanoutJobStatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFanoutJobStatusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFanoutJobStatusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFanoutJobStatusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFanoutJobStatusRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFanoutJobStatusRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetFanoutJobStatusRequest& from) {
    GetFanoutJobStatusRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFanoutJobStatusRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.fanout.GetFanoutJobStatusRequest";
  }
  protected:
  explicit GetFanoutJobStatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJobIdFieldNumber = 1,
  };
  // string job_id = 1;
  void clear_job_id();
  const std::string& job_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_job_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_job_id();
  PROTOBUF_NODISCARD std::string* release_job_id();
  void set_allocated_job_id(std::string* job_id);
  private:
  const std::string& _internal_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_job_id(const std::string& value);
  std::string* _internal_mutable_job_id();
  public:

  // @@protoc_insertion_point(class_scope:sonet.fanout.GetFanoutJobStatusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr job_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2ffanout_2eproto;
};
// -------------------------------------------------------------------

class GetFanoutJobStatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.fanout.GetFanoutJobStatusResponse) */ {
 public:
  inline GetFanoutJobStatusResponse() : GetFanoutJobStatusResponse(nullptr) {}
  ~GetFanoutJobStatusResponse() override;
  explicit PROTOBUF_CONSTEXPR GetFanoutJobStatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFanoutJobStatusResponse(const GetFanoutJobStatusResponse& from);
  GetFanoutJobStatusResponse(GetFanoutJobStatusResponse&& from) noexcept
    : GetFanoutJobStatusResponse() {
    *this = ::std::move(from);
  }

  inline GetFanoutJobStatusResponse& operator=(const GetFanoutJobStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFanoutJobStatusResponse& operator=(GetFanoutJobStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFanoutJobStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFanoutJobStatusResponse* internal_default_instance() {
    return reinterpret_cast<const GetFanoutJobStatusResponse*>(
               &_GetFanoutJobStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetFanoutJobStatusResponse& a, GetFanoutJobStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFanoutJobStatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFanoutJobStatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFanoutJobStatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFanoutJobStatusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFanoutJobStatusResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetFanoutJobStatusResponse& from) {
    GetFanoutJobStatusResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFanoutJobStatusResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.fanout.GetFanoutJobStatusResponse";
  }
  protected:
  explicit GetFanoutJobStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 3,
    kJobFieldNumber = 1,
    kSuccessFieldNumber = 2,
  };
  // string error_message = 3;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // .sonet.fanout.FanoutJob job = 1;
  bool has_job() const;
  private:
  bool _internal_has_job() const;
  public:
  void clear_job();
  const ::sonet::fanout::FanoutJob& job() const;
  PROTOBUF_NODISCARD ::sonet::fanout::FanoutJob* release_job();
  ::sonet::fanout::FanoutJob* mutable_job();
  void set_allocated_job(::sonet::fanout::FanoutJob* job);
  private:
  const ::sonet::fanout::FanoutJob& _internal_job() const;
  ::sonet::fanout::FanoutJob* _internal_mutable_job();
  public:
  void unsafe_arena_set_allocated_job(
      ::sonet::fanout::FanoutJob* job);
  ::sonet::fanout::FanoutJob* unsafe_arena_release_job();

  // bool success = 2;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.fanout.GetFanoutJobStatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    ::sonet::fanout::FanoutJob* job_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2ffanout_2eproto;
};
// -------------------------------------------------------------------

class CancelFanoutJobRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.fanout.CancelFanoutJobRequest) */ {
 public:
  inline CancelFanoutJobRequest() : CancelFanoutJobRequest(nullptr) {}
  ~CancelFanoutJobRequest() override;
  explicit PROTOBUF_CONSTEXPR CancelFanoutJobRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CancelFanoutJobRequest(const CancelFanoutJobRequest& from);
  CancelFanoutJobRequest(CancelFanoutJobRequest&& from) noexcept
    : CancelFanoutJobRequest() {
    *this = ::std::move(from);
  }

  inline CancelFanoutJobRequest& operator=(const CancelFanoutJobRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelFanoutJobRequest& operator=(CancelFanoutJobRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelFanoutJobRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelFanoutJobRequest* internal_default_instance() {
    return reinterpret_cast<const CancelFanoutJobRequest*>(
               &_CancelFanoutJobRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CancelFanoutJobRequest& a, CancelFanoutJobRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelFanoutJobRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelFanoutJobRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelFanoutJobRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CancelFanoutJobRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CancelFanoutJobRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CancelFanoutJobRequest& from) {
    CancelFanoutJobRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelFanoutJobRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.fanout.CancelFanoutJobRequest";
  }
  protected:
  explicit CancelFanoutJobRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJobIdFieldNumber = 1,
    kReasonFieldNumber = 2,
  };
  // string job_id = 1;
  void clear_job_id();
  const std::string& job_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_job_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_job_id();
  PROTOBUF_NODISCARD std::string* release_job_id();
  void set_allocated_job_id(std::string* job_id);
  private:
  const std::string& _internal_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_job_id(const std::string& value);
  std::string* _internal_mutable_job_id();
  public:

  // string reason = 2;
  void clear_reason();
  const std::string& reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // @@protoc_insertion_point(class_scope:sonet.fanout.CancelFanoutJobRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr job_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2ffanout_2eproto;
};
// -------------------------------------------------------------------

class CancelFanoutJobResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.fanout.CancelFanoutJobResponse) */ {
 public:
  inline CancelFanoutJobResponse() : CancelFanoutJobResponse(nullptr) {}
  ~CancelFanoutJobResponse() override;
  explicit PROTOBUF_CONSTEXPR CancelFanoutJobResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CancelFanoutJobResponse(const CancelFanoutJobResponse& from);
  CancelFanoutJobResponse(CancelFanoutJobResponse&& from) noexcept
    : CancelFanoutJobResponse() {
    *this = ::std::move(from);
  }

  inline CancelFanoutJobResponse& operator=(const CancelFanoutJobResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelFanoutJobResponse& operator=(CancelFanoutJobResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelFanoutJobResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelFanoutJobResponse* internal_default_instance() {
    return reinterpret_cast<const CancelFanoutJobResponse*>(
               &_CancelFanoutJobResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CancelFanoutJobResponse& a, CancelFanoutJobResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelFanoutJobResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelFanoutJobResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelFanoutJobResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CancelFanoutJobResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CancelFanoutJobResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CancelFanoutJobResponse& from) {
    CancelFanoutJobResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelFanoutJobResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.fanout.CancelFanoutJobResponse";
  }
  protected:
  explicit CancelFanoutJobResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string error_message = 2;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.fanout.CancelFanoutJobResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2ffanout_2eproto;
};
// -------------------------------------------------------------------

class GetUserTierRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.fanout.GetUserTierRequest) */ {
 public:
  inline GetUserTierRequest() : GetUserTierRequest(nullptr) {}
  ~GetUserTierRequest() override;
  explicit PROTOBUF_CONSTEXPR GetUserTierRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUserTierRequest(const GetUserTierRequest& from);
  GetUserTierRequest(GetUserTierRequest&& from) noexcept
    : GetUserTierRequest() {
    *this = ::std::move(from);
  }

  inline GetUserTierRequest& operator=(const GetUserTierRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserTierRequest& operator=(GetUserTierRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUserTierRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserTierRequest* internal_default_instance() {
    return reinterpret_cast<const GetUserTierRequest*>(
               &_GetUserTierRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetUserTierRequest& a, GetUserTierRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserTierRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserTierRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserTierRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUserTierRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetUserTierRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetUserTierRequest& from) {
    GetUserTierRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUserTierRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.fanout.GetUserTierRequest";
  }
  protected:
  explicit GetUserTierRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // @@protoc_insertion_point(class_scope:sonet.fanout.GetUserTierRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2ffanout_2eproto;
};
// -------------------------------------------------------------------

class GetUserTierResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.fanout.GetUserTierResponse) */ {
 public:
  inline GetUserTierResponse() : GetUserTierResponse(nullptr) {}
  ~GetUserTierResponse() override;
  explicit PROTOBUF_CONSTEXPR GetUserTierResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUserTierResponse(const GetUserTierResponse& from);
  GetUserTierResponse(GetUserTierResponse&& from) noexcept
    : GetUserTierResponse() {
    *this = ::std::move(from);
  }

  inline GetUserTierResponse& operator=(const GetUserTierResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserTierResponse& operator=(GetUserTierResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUserTierResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserTierResponse* internal_default_instance() {
    return reinterpret_cast<const GetUserTierResponse*>(
               &_GetUserTierResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetUserTierResponse& a, GetUserTierResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserTierResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserTierResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserTierResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUserTierResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetUserTierResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetUserTierResponse& from) {
    GetUserTierResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUserTierResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.fanout.GetUserTierResponse";
  }
  protected:
  explicit GetUserTierResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 5,
    kTierFieldNumber = 1,
    kFollowerCountFieldNumber = 2,
    kRecommendedStrategyFieldNumber = 3,
    kSuccessFieldNumber = 4,
  };
  // string error_message = 5;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // .sonet.fanout.UserTier tier = 1;
  void clear_tier();
  ::sonet::fanout::UserTier tier() const;
  void set_tier(::sonet::fanout::UserTier value);
  private:
  ::sonet::fanout::UserTier _internal_tier() const;
  void _internal_set_tier(::sonet::fanout::UserTier value);
  public:

  // int32 follower_count = 2;
  void clear_follower_count();
  int32_t follower_count() const;
  void set_follower_count(int32_t value);
  private:
  int32_t _internal_follower_count() const;
  void _internal_set_follower_count(int32_t value);
  public:

  // .sonet.fanout.FanoutStrategy recommended_strategy = 3;
  void clear_recommended_strategy();
  ::sonet::fanout::FanoutStrategy recommended_strategy() const;
  void set_recommended_strategy(::sonet::fanout::FanoutStrategy value);
  private:
  ::sonet::fanout::FanoutStrategy _internal_recommended_strategy() const;
  void _internal_set_recommended_strategy(::sonet::fanout::FanoutStrategy value);
  public:

  // bool success = 4;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.fanout.GetUserTierResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    int tier_;
    int32_t follower_count_;
    int recommended_strategy_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2ffanout_2eproto;
};
// -------------------------------------------------------------------

class ProcessFollowerBatchRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.fanout.ProcessFollowerBatchRequest) */ {
 public:
  inline ProcessFollowerBatchRequest() : ProcessFollowerBatchRequest(nullptr) {}
  ~ProcessFollowerBatchRequest() override;
  explicit PROTOBUF_CONSTEXPR ProcessFollowerBatchRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessFollowerBatchRequest(const ProcessFollowerBatchRequest& from);
  ProcessFollowerBatchRequest(ProcessFollowerBatchRequest&& from) noexcept
    : ProcessFollowerBatchRequest() {
    *this = ::std::move(from);
  }

  inline ProcessFollowerBatchRequest& operator=(const ProcessFollowerBatchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessFollowerBatchRequest& operator=(ProcessFollowerBatchRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessFollowerBatchRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessFollowerBatchRequest* internal_default_instance() {
    return reinterpret_cast<const ProcessFollowerBatchRequest*>(
               &_ProcessFollowerBatchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ProcessFollowerBatchRequest& a, ProcessFollowerBatchRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessFollowerBatchRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessFollowerBatchRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessFollowerBatchRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcessFollowerBatchRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcessFollowerBatchRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProcessFollowerBatchRequest& from) {
    ProcessFollowerBatchRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessFollowerBatchRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.fanout.ProcessFollowerBatchRequest";
  }
  protected:
  explicit ProcessFollowerBatchRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBatchFieldNumber = 1,
    kNoteFieldNumber = 2,
  };
  // .sonet.fanout.FollowerBatch batch = 1;
  bool has_batch() const;
  private:
  bool _internal_has_batch() const;
  public:
  void clear_batch();
  const ::sonet::fanout::FollowerBatch& batch() const;
  PROTOBUF_NODISCARD ::sonet::fanout::FollowerBatch* release_batch();
  ::sonet::fanout::FollowerBatch* mutable_batch();
  void set_allocated_batch(::sonet::fanout::FollowerBatch* batch);
  private:
  const ::sonet::fanout::FollowerBatch& _internal_batch() const;
  ::sonet::fanout::FollowerBatch* _internal_mutable_batch();
  public:
  void unsafe_arena_set_allocated_batch(
      ::sonet::fanout::FollowerBatch* batch);
  ::sonet::fanout::FollowerBatch* unsafe_arena_release_batch();

  // .sonet.note.Note note = 2;
  bool has_note() const;
  private:
  bool _internal_has_note() const;
  public:
  void clear_note();
  const ::sonet::note::Note& note() const;
  PROTOBUF_NODISCARD ::sonet::note::Note* release_note();
  ::sonet::note::Note* mutable_note();
  void set_allocated_note(::sonet::note::Note* note);
  private:
  const ::sonet::note::Note& _internal_note() const;
  ::sonet::note::Note* _internal_mutable_note();
  public:
  void unsafe_arena_set_allocated_note(
      ::sonet::note::Note* note);
  ::sonet::note::Note* unsafe_arena_release_note();

  // @@protoc_insertion_point(class_scope:sonet.fanout.ProcessFollowerBatchRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sonet::fanout::FollowerBatch* batch_;
    ::sonet::note::Note* note_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2ffanout_2eproto;
};
// -------------------------------------------------------------------

class ProcessFollowerBatchResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.fanout.ProcessFollowerBatchResponse) */ {
 public:
  inline ProcessFollowerBatchResponse() : ProcessFollowerBatchResponse(nullptr) {}
  ~ProcessFollowerBatchResponse() override;
  explicit PROTOBUF_CONSTEXPR ProcessFollowerBatchResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessFollowerBatchResponse(const ProcessFollowerBatchResponse& from);
  ProcessFollowerBatchResponse(ProcessFollowerBatchResponse&& from) noexcept
    : ProcessFollowerBatchResponse() {
    *this = ::std::move(from);
  }

  inline ProcessFollowerBatchResponse& operator=(const ProcessFollowerBatchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessFollowerBatchResponse& operator=(ProcessFollowerBatchResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessFollowerBatchResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessFollowerBatchResponse* internal_default_instance() {
    return reinterpret_cast<const ProcessFollowerBatchResponse*>(
               &_ProcessFollowerBatchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ProcessFollowerBatchResponse& a, ProcessFollowerBatchResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessFollowerBatchResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessFollowerBatchResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessFollowerBatchResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcessFollowerBatchResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcessFollowerBatchResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProcessFollowerBatchResponse& from) {
    ProcessFollowerBatchResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessFollowerBatchResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.fanout.ProcessFollowerBatchResponse";
  }
  protected:
  explicit ProcessFollowerBatchResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFailedUserIdsFieldNumber = 4,
    kBatchIdFieldNumber = 1,
    kErrorMessageFieldNumber = 6,
    kSuccessfulDeliveriesFieldNumber = 2,
    kFailedDeliveriesFieldNumber = 3,
    kSuccessFieldNumber = 5,
  };
  // repeated string failed_user_ids = 4;
  int failed_user_ids_size() const;
  private:
  int _internal_failed_user_ids_size() const;
  public:
  void clear_failed_user_ids();
  const std::string& failed_user_ids(int index) const;
  std::string* mutable_failed_user_ids(int index);
  void set_failed_user_ids(int index, const std::string& value);
  void set_failed_user_ids(int index, std::string&& value);
  void set_failed_user_ids(int index, const char* value);
  void set_failed_user_ids(int index, const char* value, size_t size);
  std::string* add_failed_user_ids();
  void add_failed_user_ids(const std::string& value);
  void add_failed_user_ids(std::string&& value);
  void add_failed_user_ids(const char* value);
  void add_failed_user_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& failed_user_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_failed_user_ids();
  private:
  const std::string& _internal_failed_user_ids(int index) const;
  std::string* _internal_add_failed_user_ids();
  public:

  // string batch_id = 1;
  void clear_batch_id();
  const std::string& batch_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_batch_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_batch_id();
  PROTOBUF_NODISCARD std::string* release_batch_id();
  void set_allocated_batch_id(std::string* batch_id);
  private:
  const std::string& _internal_batch_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_batch_id(const std::string& value);
  std::string* _internal_mutable_batch_id();
  public:

  // string error_message = 6;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // int32 successful_deliveries = 2;
  void clear_successful_deliveries();
  int32_t successful_deliveries() const;
  void set_successful_deliveries(int32_t value);
  private:
  int32_t _internal_successful_deliveries() const;
  void _internal_set_successful_deliveries(int32_t value);
  public:

  // int32 failed_deliveries = 3;
  void clear_failed_deliveries();
  int32_t failed_deliveries() const;
  void set_failed_deliveries(int32_t value);
  private:
  int32_t _internal_failed_deliveries() const;
  void _internal_set_failed_deliveries(int32_t value);
  public:

  // bool success = 5;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.fanout.ProcessFollowerBatchResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> failed_user_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr batch_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    int32_t successful_deliveries_;
    int32_t failed_deliveries_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2ffanout_2eproto;
};
// -------------------------------------------------------------------

class GetFanoutMetricsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.fanout.GetFanoutMetricsRequest) */ {
 public:
  inline GetFanoutMetricsRequest() : GetFanoutMetricsRequest(nullptr) {}
  ~GetFanoutMetricsRequest() override;
  explicit PROTOBUF_CONSTEXPR GetFanoutMetricsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFanoutMetricsRequest(const GetFanoutMetricsRequest& from);
  GetFanoutMetricsRequest(GetFanoutMetricsRequest&& from) noexcept
    : GetFanoutMetricsRequest() {
    *this = ::std::move(from);
  }

  inline GetFanoutMetricsRequest& operator=(const GetFanoutMetricsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFanoutMetricsRequest& operator=(GetFanoutMetricsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFanoutMetricsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFanoutMetricsRequest* internal_default_instance() {
    return reinterpret_cast<const GetFanoutMetricsRequest*>(
               &_GetFanoutMetricsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetFanoutMetricsRequest& a, GetFanoutMetricsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFanoutMetricsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFanoutMetricsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFanoutMetricsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFanoutMetricsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFanoutMetricsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetFanoutMetricsRequest& from) {
    GetFanoutMetricsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFanoutMetricsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.fanout.GetFanoutMetricsRequest";
  }
  protected:
  explicit GetFanoutMetricsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthorIdFieldNumber = 1,
    kNoteIdFieldNumber = 2,
    kSinceFieldNumber = 3,
    kUntilFieldNumber = 4,
  };
  // string author_id = 1;
  void clear_author_id();
  const std::string& author_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_author_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_author_id();
  PROTOBUF_NODISCARD std::string* release_author_id();
  void set_allocated_author_id(std::string* author_id);
  private:
  const std::string& _internal_author_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_author_id(const std::string& value);
  std::string* _internal_mutable_author_id();
  public:

  // string note_id = 2;
  void clear_note_id();
  const std::string& note_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_note_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_note_id();
  PROTOBUF_NODISCARD std::string* release_note_id();
  void set_allocated_note_id(std::string* note_id);
  private:
  const std::string& _internal_note_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_note_id(const std::string& value);
  std::string* _internal_mutable_note_id();
  public:

  // .sonet.common.Timestamp since = 3;
  bool has_since() const;
  private:
  bool _internal_has_since() const;
  public:
  void clear_since();
  const ::sonet::common::Timestamp& since() const;
  PROTOBUF_NODISCARD ::sonet::common::Timestamp* release_since();
  ::sonet::common::Timestamp* mutable_since();
  void set_allocated_since(::sonet::common::Timestamp* since);
  private:
  const ::sonet::common::Timestamp& _internal_since() const;
  ::sonet::common::Timestamp* _internal_mutable_since();
  public:
  void unsafe_arena_set_allocated_since(
      ::sonet::common::Timestamp* since);
  ::sonet::common::Timestamp* unsafe_arena_release_since();

  // .sonet.common.Timestamp until = 4;
  bool has_until() const;
  private:
  bool _internal_has_until() const;
  public:
  void clear_until();
  const ::sonet::common::Timestamp& until() const;
  PROTOBUF_NODISCARD ::sonet::common::Timestamp* release_until();
  ::sonet::common::Timestamp* mutable_until();
  void set_allocated_until(::sonet::common::Timestamp* until);
  private:
  const ::sonet::common::Timestamp& _internal_until() const;
  ::sonet::common::Timestamp* _internal_mutable_until();
  public:
  void unsafe_arena_set_allocated_until(
      ::sonet::common::Timestamp* until);
  ::sonet::common::Timestamp* unsafe_arena_release_until();

  // @@protoc_insertion_point(class_scope:sonet.fanout.GetFanoutMetricsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr author_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr note_id_;
    ::sonet::common::Timestamp* since_;
    ::sonet::common::Timestamp* until_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2ffanout_2eproto;
};
// -------------------------------------------------------------------

class GetFanoutMetricsResponse_SummaryStatsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetFanoutMetricsResponse_SummaryStatsEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetFanoutMetricsResponse_SummaryStatsEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> SuperType;
  GetFanoutMetricsResponse_SummaryStatsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR GetFanoutMetricsResponse_SummaryStatsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit GetFanoutMetricsResponse_SummaryStatsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetFanoutMetricsResponse_SummaryStatsEntry_DoNotUse& other);
  static const GetFanoutMetricsResponse_SummaryStatsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetFanoutMetricsResponse_SummaryStatsEntry_DoNotUse*>(&_GetFanoutMetricsResponse_SummaryStatsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "sonet.fanout.GetFanoutMetricsResponse.SummaryStatsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_services_2ffanout_2eproto;
};

// -------------------------------------------------------------------

class GetFanoutMetricsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.fanout.GetFanoutMetricsResponse) */ {
 public:
  inline GetFanoutMetricsResponse() : GetFanoutMetricsResponse(nullptr) {}
  ~GetFanoutMetricsResponse() override;
  explicit PROTOBUF_CONSTEXPR GetFanoutMetricsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFanoutMetricsResponse(const GetFanoutMetricsResponse& from);
  GetFanoutMetricsResponse(GetFanoutMetricsResponse&& from) noexcept
    : GetFanoutMetricsResponse() {
    *this = ::std::move(from);
  }

  inline GetFanoutMetricsResponse& operator=(const GetFanoutMetricsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFanoutMetricsResponse& operator=(GetFanoutMetricsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFanoutMetricsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFanoutMetricsResponse* internal_default_instance() {
    return reinterpret_cast<const GetFanoutMetricsResponse*>(
               &_GetFanoutMetricsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(GetFanoutMetricsResponse& a, GetFanoutMetricsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFanoutMetricsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFanoutMetricsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFanoutMetricsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFanoutMetricsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFanoutMetricsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetFanoutMetricsResponse& from) {
    GetFanoutMetricsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFanoutMetricsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.fanout.GetFanoutMetricsResponse";
  }
  protected:
  explicit GetFanoutMetricsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMetricsFieldNumber = 1,
    kSummaryStatsFieldNumber = 2,
    kErrorMessageFieldNumber = 4,
    kSuccessFieldNumber = 3,
  };
  // repeated .sonet.fanout.FanoutMetrics metrics = 1;
  int metrics_size() const;
  private:
  int _internal_metrics_size() const;
  public:
  void clear_metrics();
  ::sonet::fanout::FanoutMetrics* mutable_metrics(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::fanout::FanoutMetrics >*
      mutable_metrics();
  private:
  const ::sonet::fanout::FanoutMetrics& _internal_metrics(int index) const;
  ::sonet::fanout::FanoutMetrics* _internal_add_metrics();
  public:
  const ::sonet::fanout::FanoutMetrics& metrics(int index) const;
  ::sonet::fanout::FanoutMetrics* add_metrics();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::fanout::FanoutMetrics >&
      metrics() const;

  // map<string, double> summary_stats = 2;
  int summary_stats_size() const;
  private:
  int _internal_summary_stats_size() const;
  public:
  void clear_summary_stats();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_summary_stats() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_summary_stats();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      summary_stats() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_summary_stats();

  // string error_message = 4;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // bool success = 3;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.fanout.GetFanoutMetricsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::fanout::FanoutMetrics > metrics_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        GetFanoutMetricsResponse_SummaryStatsEntry_DoNotUse,
        std::string, double,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> summary_stats_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2ffanout_2eproto;
};
// -------------------------------------------------------------------

class HealthCheckRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:sonet.fanout.HealthCheckRequest) */ {
 public:
  inline HealthCheckRequest() : HealthCheckRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR HealthCheckRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HealthCheckRequest(const HealthCheckRequest& from);
  HealthCheckRequest(HealthCheckRequest&& from) noexcept
    : HealthCheckRequest() {
    *this = ::std::move(from);
  }

  inline HealthCheckRequest& operator=(const HealthCheckRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealthCheckRequest& operator=(HealthCheckRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HealthCheckRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HealthCheckRequest* internal_default_instance() {
    return reinterpret_cast<const HealthCheckRequest*>(
               &_HealthCheckRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(HealthCheckRequest& a, HealthCheckRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HealthCheckRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealthCheckRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HealthCheckRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HealthCheckRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const HealthCheckRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const HealthCheckRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.fanout.HealthCheckRequest";
  }
  protected:
  explicit HealthCheckRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:sonet.fanout.HealthCheckRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_services_2ffanout_2eproto;
};
// -------------------------------------------------------------------

class HealthCheckResponse_DetailsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<HealthCheckResponse_DetailsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<HealthCheckResponse_DetailsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  HealthCheckResponse_DetailsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR HealthCheckResponse_DetailsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit HealthCheckResponse_DetailsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const HealthCheckResponse_DetailsEntry_DoNotUse& other);
  static const HealthCheckResponse_DetailsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const HealthCheckResponse_DetailsEntry_DoNotUse*>(&_HealthCheckResponse_DetailsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "sonet.fanout.HealthCheckResponse.DetailsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "sonet.fanout.HealthCheckResponse.DetailsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_services_2ffanout_2eproto;
};

// -------------------------------------------------------------------

class HealthCheckResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.fanout.HealthCheckResponse) */ {
 public:
  inline HealthCheckResponse() : HealthCheckResponse(nullptr) {}
  ~HealthCheckResponse() override;
  explicit PROTOBUF_CONSTEXPR HealthCheckResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HealthCheckResponse(const HealthCheckResponse& from);
  HealthCheckResponse(HealthCheckResponse&& from) noexcept
    : HealthCheckResponse() {
    *this = ::std::move(from);
  }

  inline HealthCheckResponse& operator=(const HealthCheckResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealthCheckResponse& operator=(HealthCheckResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HealthCheckResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HealthCheckResponse* internal_default_instance() {
    return reinterpret_cast<const HealthCheckResponse*>(
               &_HealthCheckResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(HealthCheckResponse& a, HealthCheckResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HealthCheckResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealthCheckResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HealthCheckResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HealthCheckResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HealthCheckResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HealthCheckResponse& from) {
    HealthCheckResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HealthCheckResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.fanout.HealthCheckResponse";
  }
  protected:
  explicit HealthCheckResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kDetailsFieldNumber = 2,
    kStatusFieldNumber = 1,
    kPendingJobsFieldNumber = 3,
    kActiveWorkersFieldNumber = 4,
  };
  // map<string, string> details = 2;
  int details_size() const;
  private:
  int _internal_details_size() const;
  public:
  void clear_details();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_details() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_details();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      details() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_details();

  // string status = 1;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // int32 pending_jobs = 3;
  void clear_pending_jobs();
  int32_t pending_jobs() const;
  void set_pending_jobs(int32_t value);
  private:
  int32_t _internal_pending_jobs() const;
  void _internal_set_pending_jobs(int32_t value);
  public:

  // int32 active_workers = 4;
  void clear_active_workers();
  int32_t active_workers() const;
  void set_active_workers(int32_t value);
  private:
  int32_t _internal_active_workers() const;
  void _internal_set_active_workers(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.fanout.HealthCheckResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        HealthCheckResponse_DetailsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> details_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    int32_t pending_jobs_;
    int32_t active_workers_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2ffanout_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FanoutJob

// string job_id = 1;
inline void FanoutJob::clear_job_id() {
  _impl_.job_id_.ClearToEmpty();
}
inline const std::string& FanoutJob::job_id() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.FanoutJob.job_id)
  return _internal_job_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FanoutJob::set_job_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.job_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.fanout.FanoutJob.job_id)
}
inline std::string* FanoutJob::mutable_job_id() {
  std::string* _s = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:sonet.fanout.FanoutJob.job_id)
  return _s;
}
inline const std::string& FanoutJob::_internal_job_id() const {
  return _impl_.job_id_.Get();
}
inline void FanoutJob::_internal_set_job_id(const std::string& value) {
  
  _impl_.job_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FanoutJob::_internal_mutable_job_id() {
  
  return _impl_.job_id_.Mutable(GetArenaForAllocation());
}
inline std::string* FanoutJob::release_job_id() {
  // @@protoc_insertion_point(field_release:sonet.fanout.FanoutJob.job_id)
  return _impl_.job_id_.Release();
}
inline void FanoutJob::set_allocated_job_id(std::string* job_id) {
  if (job_id != nullptr) {
    
  } else {
    
  }
  _impl_.job_id_.SetAllocated(job_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.job_id_.IsDefault()) {
    _impl_.job_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.fanout.FanoutJob.job_id)
}

// string note_id = 2;
inline void FanoutJob::clear_note_id() {
  _impl_.note_id_.ClearToEmpty();
}
inline const std::string& FanoutJob::note_id() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.FanoutJob.note_id)
  return _internal_note_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FanoutJob::set_note_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.note_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.fanout.FanoutJob.note_id)
}
inline std::string* FanoutJob::mutable_note_id() {
  std::string* _s = _internal_mutable_note_id();
  // @@protoc_insertion_point(field_mutable:sonet.fanout.FanoutJob.note_id)
  return _s;
}
inline const std::string& FanoutJob::_internal_note_id() const {
  return _impl_.note_id_.Get();
}
inline void FanoutJob::_internal_set_note_id(const std::string& value) {
  
  _impl_.note_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FanoutJob::_internal_mutable_note_id() {
  
  return _impl_.note_id_.Mutable(GetArenaForAllocation());
}
inline std::string* FanoutJob::release_note_id() {
  // @@protoc_insertion_point(field_release:sonet.fanout.FanoutJob.note_id)
  return _impl_.note_id_.Release();
}
inline void FanoutJob::set_allocated_note_id(std::string* note_id) {
  if (note_id != nullptr) {
    
  } else {
    
  }
  _impl_.note_id_.SetAllocated(note_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.note_id_.IsDefault()) {
    _impl_.note_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.fanout.FanoutJob.note_id)
}

// string author_id = 3;
inline void FanoutJob::clear_author_id() {
  _impl_.author_id_.ClearToEmpty();
}
inline const std::string& FanoutJob::author_id() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.FanoutJob.author_id)
  return _internal_author_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FanoutJob::set_author_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.author_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.fanout.FanoutJob.author_id)
}
inline std::string* FanoutJob::mutable_author_id() {
  std::string* _s = _internal_mutable_author_id();
  // @@protoc_insertion_point(field_mutable:sonet.fanout.FanoutJob.author_id)
  return _s;
}
inline const std::string& FanoutJob::_internal_author_id() const {
  return _impl_.author_id_.Get();
}
inline void FanoutJob::_internal_set_author_id(const std::string& value) {
  
  _impl_.author_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FanoutJob::_internal_mutable_author_id() {
  
  return _impl_.author_id_.Mutable(GetArenaForAllocation());
}
inline std::string* FanoutJob::release_author_id() {
  // @@protoc_insertion_point(field_release:sonet.fanout.FanoutJob.author_id)
  return _impl_.author_id_.Release();
}
inline void FanoutJob::set_allocated_author_id(std::string* author_id) {
  if (author_id != nullptr) {
    
  } else {
    
  }
  _impl_.author_id_.SetAllocated(author_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.author_id_.IsDefault()) {
    _impl_.author_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.fanout.FanoutJob.author_id)
}

// .sonet.fanout.UserTier author_tier = 4;
inline void FanoutJob::clear_author_tier() {
  _impl_.author_tier_ = 0;
}
inline ::sonet::fanout::UserTier FanoutJob::_internal_author_tier() const {
  return static_cast< ::sonet::fanout::UserTier >(_impl_.author_tier_);
}
inline ::sonet::fanout::UserTier FanoutJob::author_tier() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.FanoutJob.author_tier)
  return _internal_author_tier();
}
inline void FanoutJob::_internal_set_author_tier(::sonet::fanout::UserTier value) {
  
  _impl_.author_tier_ = value;
}
inline void FanoutJob::set_author_tier(::sonet::fanout::UserTier value) {
  _internal_set_author_tier(value);
  // @@protoc_insertion_point(field_set:sonet.fanout.FanoutJob.author_tier)
}

// .sonet.fanout.FanoutStrategy strategy = 5;
inline void FanoutJob::clear_strategy() {
  _impl_.strategy_ = 0;
}
inline ::sonet::fanout::FanoutStrategy FanoutJob::_internal_strategy() const {
  return static_cast< ::sonet::fanout::FanoutStrategy >(_impl_.strategy_);
}
inline ::sonet::fanout::FanoutStrategy FanoutJob::strategy() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.FanoutJob.strategy)
  return _internal_strategy();
}
inline void FanoutJob::_internal_set_strategy(::sonet::fanout::FanoutStrategy value) {
  
  _impl_.strategy_ = value;
}
inline void FanoutJob::set_strategy(::sonet::fanout::FanoutStrategy value) {
  _internal_set_strategy(value);
  // @@protoc_insertion_point(field_set:sonet.fanout.FanoutJob.strategy)
}

// .sonet.common.Timestamp created_at = 6;
inline bool FanoutJob::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool FanoutJob::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::sonet::common::Timestamp& FanoutJob::_internal_created_at() const {
  const ::sonet::common::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Timestamp&>(
      ::sonet::common::_Timestamp_default_instance_);
}
inline const ::sonet::common::Timestamp& FanoutJob::created_at() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.FanoutJob.created_at)
  return _internal_created_at();
}
inline void FanoutJob::unsafe_arena_set_allocated_created_at(
    ::sonet::common::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.fanout.FanoutJob.created_at)
}
inline ::sonet::common::Timestamp* FanoutJob::release_created_at() {
  
  ::sonet::common::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Timestamp* FanoutJob::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:sonet.fanout.FanoutJob.created_at)
  
  ::sonet::common::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::sonet::common::Timestamp* FanoutJob::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::sonet::common::Timestamp* FanoutJob::mutable_created_at() {
  ::sonet::common::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:sonet.fanout.FanoutJob.created_at)
  return _msg;
}
inline void FanoutJob::set_allocated_created_at(::sonet::common::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:sonet.fanout.FanoutJob.created_at)
}

// .sonet.common.Timestamp started_at = 7;
inline bool FanoutJob::_internal_has_started_at() const {
  return this != internal_default_instance() && _impl_.started_at_ != nullptr;
}
inline bool FanoutJob::has_started_at() const {
  return _internal_has_started_at();
}
inline const ::sonet::common::Timestamp& FanoutJob::_internal_started_at() const {
  const ::sonet::common::Timestamp* p = _impl_.started_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Timestamp&>(
      ::sonet::common::_Timestamp_default_instance_);
}
inline const ::sonet::common::Timestamp& FanoutJob::started_at() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.FanoutJob.started_at)
  return _internal_started_at();
}
inline void FanoutJob::unsafe_arena_set_allocated_started_at(
    ::sonet::common::Timestamp* started_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.started_at_);
  }
  _impl_.started_at_ = started_at;
  if (started_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.fanout.FanoutJob.started_at)
}
inline ::sonet::common::Timestamp* FanoutJob::release_started_at() {
  
  ::sonet::common::Timestamp* temp = _impl_.started_at_;
  _impl_.started_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Timestamp* FanoutJob::unsafe_arena_release_started_at() {
  // @@protoc_insertion_point(field_release:sonet.fanout.FanoutJob.started_at)
  
  ::sonet::common::Timestamp* temp = _impl_.started_at_;
  _impl_.started_at_ = nullptr;
  return temp;
}
inline ::sonet::common::Timestamp* FanoutJob::_internal_mutable_started_at() {
  
  if (_impl_.started_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Timestamp>(GetArenaForAllocation());
    _impl_.started_at_ = p;
  }
  return _impl_.started_at_;
}
inline ::sonet::common::Timestamp* FanoutJob::mutable_started_at() {
  ::sonet::common::Timestamp* _msg = _internal_mutable_started_at();
  // @@protoc_insertion_point(field_mutable:sonet.fanout.FanoutJob.started_at)
  return _msg;
}
inline void FanoutJob::set_allocated_started_at(::sonet::common::Timestamp* started_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.started_at_);
  }
  if (started_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(started_at));
    if (message_arena != submessage_arena) {
      started_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, started_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.started_at_ = started_at;
  // @@protoc_insertion_point(field_set_allocated:sonet.fanout.FanoutJob.started_at)
}

// .sonet.common.Timestamp completed_at = 8;
inline bool FanoutJob::_internal_has_completed_at() const {
  return this != internal_default_instance() && _impl_.completed_at_ != nullptr;
}
inline bool FanoutJob::has_completed_at() const {
  return _internal_has_completed_at();
}
inline const ::sonet::common::Timestamp& FanoutJob::_internal_completed_at() const {
  const ::sonet::common::Timestamp* p = _impl_.completed_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Timestamp&>(
      ::sonet::common::_Timestamp_default_instance_);
}
inline const ::sonet::common::Timestamp& FanoutJob::completed_at() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.FanoutJob.completed_at)
  return _internal_completed_at();
}
inline void FanoutJob::unsafe_arena_set_allocated_completed_at(
    ::sonet::common::Timestamp* completed_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.completed_at_);
  }
  _impl_.completed_at_ = completed_at;
  if (completed_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.fanout.FanoutJob.completed_at)
}
inline ::sonet::common::Timestamp* FanoutJob::release_completed_at() {
  
  ::sonet::common::Timestamp* temp = _impl_.completed_at_;
  _impl_.completed_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Timestamp* FanoutJob::unsafe_arena_release_completed_at() {
  // @@protoc_insertion_point(field_release:sonet.fanout.FanoutJob.completed_at)
  
  ::sonet::common::Timestamp* temp = _impl_.completed_at_;
  _impl_.completed_at_ = nullptr;
  return temp;
}
inline ::sonet::common::Timestamp* FanoutJob::_internal_mutable_completed_at() {
  
  if (_impl_.completed_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Timestamp>(GetArenaForAllocation());
    _impl_.completed_at_ = p;
  }
  return _impl_.completed_at_;
}
inline ::sonet::common::Timestamp* FanoutJob::mutable_completed_at() {
  ::sonet::common::Timestamp* _msg = _internal_mutable_completed_at();
  // @@protoc_insertion_point(field_mutable:sonet.fanout.FanoutJob.completed_at)
  return _msg;
}
inline void FanoutJob::set_allocated_completed_at(::sonet::common::Timestamp* completed_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.completed_at_);
  }
  if (completed_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(completed_at));
    if (message_arena != submessage_arena) {
      completed_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, completed_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.completed_at_ = completed_at;
  // @@protoc_insertion_point(field_set_allocated:sonet.fanout.FanoutJob.completed_at)
}

// .sonet.fanout.FanoutJob.JobStatus status = 9;
inline void FanoutJob::clear_status() {
  _impl_.status_ = 0;
}
inline ::sonet::fanout::FanoutJob_JobStatus FanoutJob::_internal_status() const {
  return static_cast< ::sonet::fanout::FanoutJob_JobStatus >(_impl_.status_);
}
inline ::sonet::fanout::FanoutJob_JobStatus FanoutJob::status() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.FanoutJob.status)
  return _internal_status();
}
inline void FanoutJob::_internal_set_status(::sonet::fanout::FanoutJob_JobStatus value) {
  
  _impl_.status_ = value;
}
inline void FanoutJob::set_status(::sonet::fanout::FanoutJob_JobStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:sonet.fanout.FanoutJob.status)
}

// int32 total_followers = 10;
inline void FanoutJob::clear_total_followers() {
  _impl_.total_followers_ = 0;
}
inline int32_t FanoutJob::_internal_total_followers() const {
  return _impl_.total_followers_;
}
inline int32_t FanoutJob::total_followers() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.FanoutJob.total_followers)
  return _internal_total_followers();
}
inline void FanoutJob::_internal_set_total_followers(int32_t value) {
  
  _impl_.total_followers_ = value;
}
inline void FanoutJob::set_total_followers(int32_t value) {
  _internal_set_total_followers(value);
  // @@protoc_insertion_point(field_set:sonet.fanout.FanoutJob.total_followers)
}

// int32 processed_followers = 11;
inline void FanoutJob::clear_processed_followers() {
  _impl_.processed_followers_ = 0;
}
inline int32_t FanoutJob::_internal_processed_followers() const {
  return _impl_.processed_followers_;
}
inline int32_t FanoutJob::processed_followers() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.FanoutJob.processed_followers)
  return _internal_processed_followers();
}
inline void FanoutJob::_internal_set_processed_followers(int32_t value) {
  
  _impl_.processed_followers_ = value;
}
inline void FanoutJob::set_processed_followers(int32_t value) {
  _internal_set_processed_followers(value);
  // @@protoc_insertion_point(field_set:sonet.fanout.FanoutJob.processed_followers)
}

// int32 failed_deliveries = 12;
inline void FanoutJob::clear_failed_deliveries() {
  _impl_.failed_deliveries_ = 0;
}
inline int32_t FanoutJob::_internal_failed_deliveries() const {
  return _impl_.failed_deliveries_;
}
inline int32_t FanoutJob::failed_deliveries() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.FanoutJob.failed_deliveries)
  return _internal_failed_deliveries();
}
inline void FanoutJob::_internal_set_failed_deliveries(int32_t value) {
  
  _impl_.failed_deliveries_ = value;
}
inline void FanoutJob::set_failed_deliveries(int32_t value) {
  _internal_set_failed_deliveries(value);
  // @@protoc_insertion_point(field_set:sonet.fanout.FanoutJob.failed_deliveries)
}

// double processing_time_ms = 13;
inline void FanoutJob::clear_processing_time_ms() {
  _impl_.processing_time_ms_ = 0;
}
inline double FanoutJob::_internal_processing_time_ms() const {
  return _impl_.processing_time_ms_;
}
inline double FanoutJob::processing_time_ms() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.FanoutJob.processing_time_ms)
  return _internal_processing_time_ms();
}
inline void FanoutJob::_internal_set_processing_time_ms(double value) {
  
  _impl_.processing_time_ms_ = value;
}
inline void FanoutJob::set_processing_time_ms(double value) {
  _internal_set_processing_time_ms(value);
  // @@protoc_insertion_point(field_set:sonet.fanout.FanoutJob.processing_time_ms)
}

// string error_message = 14;
inline void FanoutJob::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& FanoutJob::error_message() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.FanoutJob.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FanoutJob::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.fanout.FanoutJob.error_message)
}
inline std::string* FanoutJob::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:sonet.fanout.FanoutJob.error_message)
  return _s;
}
inline const std::string& FanoutJob::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void FanoutJob::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* FanoutJob::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* FanoutJob::release_error_message() {
  // @@protoc_insertion_point(field_release:sonet.fanout.FanoutJob.error_message)
  return _impl_.error_message_.Release();
}
inline void FanoutJob::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.fanout.FanoutJob.error_message)
}

// -------------------------------------------------------------------

// FollowerBatch

// string batch_id = 1;
inline void FollowerBatch::clear_batch_id() {
  _impl_.batch_id_.ClearToEmpty();
}
inline const std::string& FollowerBatch::batch_id() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.FollowerBatch.batch_id)
  return _internal_batch_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FollowerBatch::set_batch_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.batch_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.fanout.FollowerBatch.batch_id)
}
inline std::string* FollowerBatch::mutable_batch_id() {
  std::string* _s = _internal_mutable_batch_id();
  // @@protoc_insertion_point(field_mutable:sonet.fanout.FollowerBatch.batch_id)
  return _s;
}
inline const std::string& FollowerBatch::_internal_batch_id() const {
  return _impl_.batch_id_.Get();
}
inline void FollowerBatch::_internal_set_batch_id(const std::string& value) {
  
  _impl_.batch_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FollowerBatch::_internal_mutable_batch_id() {
  
  return _impl_.batch_id_.Mutable(GetArenaForAllocation());
}
inline std::string* FollowerBatch::release_batch_id() {
  // @@protoc_insertion_point(field_release:sonet.fanout.FollowerBatch.batch_id)
  return _impl_.batch_id_.Release();
}
inline void FollowerBatch::set_allocated_batch_id(std::string* batch_id) {
  if (batch_id != nullptr) {
    
  } else {
    
  }
  _impl_.batch_id_.SetAllocated(batch_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.batch_id_.IsDefault()) {
    _impl_.batch_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.fanout.FollowerBatch.batch_id)
}

// string job_id = 2;
inline void FollowerBatch::clear_job_id() {
  _impl_.job_id_.ClearToEmpty();
}
inline const std::string& FollowerBatch::job_id() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.FollowerBatch.job_id)
  return _internal_job_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FollowerBatch::set_job_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.job_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.fanout.FollowerBatch.job_id)
}
inline std::string* FollowerBatch::mutable_job_id() {
  std::string* _s = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:sonet.fanout.FollowerBatch.job_id)
  return _s;
}
inline const std::string& FollowerBatch::_internal_job_id() const {
  return _impl_.job_id_.Get();
}
inline void FollowerBatch::_internal_set_job_id(const std::string& value) {
  
  _impl_.job_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FollowerBatch::_internal_mutable_job_id() {
  
  return _impl_.job_id_.Mutable(GetArenaForAllocation());
}
inline std::string* FollowerBatch::release_job_id() {
  // @@protoc_insertion_point(field_release:sonet.fanout.FollowerBatch.job_id)
  return _impl_.job_id_.Release();
}
inline void FollowerBatch::set_allocated_job_id(std::string* job_id) {
  if (job_id != nullptr) {
    
  } else {
    
  }
  _impl_.job_id_.SetAllocated(job_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.job_id_.IsDefault()) {
    _impl_.job_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.fanout.FollowerBatch.job_id)
}

// repeated string follower_ids = 3;
inline int FollowerBatch::_internal_follower_ids_size() const {
  return _impl_.follower_ids_.size();
}
inline int FollowerBatch::follower_ids_size() const {
  return _internal_follower_ids_size();
}
inline void FollowerBatch::clear_follower_ids() {
  _impl_.follower_ids_.Clear();
}
inline std::string* FollowerBatch::add_follower_ids() {
  std::string* _s = _internal_add_follower_ids();
  // @@protoc_insertion_point(field_add_mutable:sonet.fanout.FollowerBatch.follower_ids)
  return _s;
}
inline const std::string& FollowerBatch::_internal_follower_ids(int index) const {
  return _impl_.follower_ids_.Get(index);
}
inline const std::string& FollowerBatch::follower_ids(int index) const {
  // @@protoc_insertion_point(field_get:sonet.fanout.FollowerBatch.follower_ids)
  return _internal_follower_ids(index);
}
inline std::string* FollowerBatch::mutable_follower_ids(int index) {
  // @@protoc_insertion_point(field_mutable:sonet.fanout.FollowerBatch.follower_ids)
  return _impl_.follower_ids_.Mutable(index);
}
inline void FollowerBatch::set_follower_ids(int index, const std::string& value) {
  _impl_.follower_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sonet.fanout.FollowerBatch.follower_ids)
}
inline void FollowerBatch::set_follower_ids(int index, std::string&& value) {
  _impl_.follower_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sonet.fanout.FollowerBatch.follower_ids)
}
inline void FollowerBatch::set_follower_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.follower_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sonet.fanout.FollowerBatch.follower_ids)
}
inline void FollowerBatch::set_follower_ids(int index, const char* value, size_t size) {
  _impl_.follower_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sonet.fanout.FollowerBatch.follower_ids)
}
inline std::string* FollowerBatch::_internal_add_follower_ids() {
  return _impl_.follower_ids_.Add();
}
inline void FollowerBatch::add_follower_ids(const std::string& value) {
  _impl_.follower_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sonet.fanout.FollowerBatch.follower_ids)
}
inline void FollowerBatch::add_follower_ids(std::string&& value) {
  _impl_.follower_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sonet.fanout.FollowerBatch.follower_ids)
}
inline void FollowerBatch::add_follower_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.follower_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sonet.fanout.FollowerBatch.follower_ids)
}
inline void FollowerBatch::add_follower_ids(const char* value, size_t size) {
  _impl_.follower_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sonet.fanout.FollowerBatch.follower_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FollowerBatch::follower_ids() const {
  // @@protoc_insertion_point(field_list:sonet.fanout.FollowerBatch.follower_ids)
  return _impl_.follower_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FollowerBatch::mutable_follower_ids() {
  // @@protoc_insertion_point(field_mutable_list:sonet.fanout.FollowerBatch.follower_ids)
  return &_impl_.follower_ids_;
}

// int32 batch_size = 4;
inline void FollowerBatch::clear_batch_size() {
  _impl_.batch_size_ = 0;
}
inline int32_t FollowerBatch::_internal_batch_size() const {
  return _impl_.batch_size_;
}
inline int32_t FollowerBatch::batch_size() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.FollowerBatch.batch_size)
  return _internal_batch_size();
}
inline void FollowerBatch::_internal_set_batch_size(int32_t value) {
  
  _impl_.batch_size_ = value;
}
inline void FollowerBatch::set_batch_size(int32_t value) {
  _internal_set_batch_size(value);
  // @@protoc_insertion_point(field_set:sonet.fanout.FollowerBatch.batch_size)
}

// int32 batch_number = 5;
inline void FollowerBatch::clear_batch_number() {
  _impl_.batch_number_ = 0;
}
inline int32_t FollowerBatch::_internal_batch_number() const {
  return _impl_.batch_number_;
}
inline int32_t FollowerBatch::batch_number() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.FollowerBatch.batch_number)
  return _internal_batch_number();
}
inline void FollowerBatch::_internal_set_batch_number(int32_t value) {
  
  _impl_.batch_number_ = value;
}
inline void FollowerBatch::set_batch_number(int32_t value) {
  _internal_set_batch_number(value);
  // @@protoc_insertion_point(field_set:sonet.fanout.FollowerBatch.batch_number)
}

// .sonet.fanout.FanoutStrategy strategy = 6;
inline void FollowerBatch::clear_strategy() {
  _impl_.strategy_ = 0;
}
inline ::sonet::fanout::FanoutStrategy FollowerBatch::_internal_strategy() const {
  return static_cast< ::sonet::fanout::FanoutStrategy >(_impl_.strategy_);
}
inline ::sonet::fanout::FanoutStrategy FollowerBatch::strategy() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.FollowerBatch.strategy)
  return _internal_strategy();
}
inline void FollowerBatch::_internal_set_strategy(::sonet::fanout::FanoutStrategy value) {
  
  _impl_.strategy_ = value;
}
inline void FollowerBatch::set_strategy(::sonet::fanout::FanoutStrategy value) {
  _internal_set_strategy(value);
  // @@protoc_insertion_point(field_set:sonet.fanout.FollowerBatch.strategy)
}

// -------------------------------------------------------------------

// DeliveryTarget

// string user_id = 1;
inline void DeliveryTarget::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& DeliveryTarget::user_id() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.DeliveryTarget.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeliveryTarget::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.fanout.DeliveryTarget.user_id)
}
inline std::string* DeliveryTarget::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:sonet.fanout.DeliveryTarget.user_id)
  return _s;
}
inline const std::string& DeliveryTarget::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void DeliveryTarget::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeliveryTarget::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeliveryTarget::release_user_id() {
  // @@protoc_insertion_point(field_release:sonet.fanout.DeliveryTarget.user_id)
  return _impl_.user_id_.Release();
}
inline void DeliveryTarget::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.fanout.DeliveryTarget.user_id)
}

// string timeline_key = 2;
inline void DeliveryTarget::clear_timeline_key() {
  _impl_.timeline_key_.ClearToEmpty();
}
inline const std::string& DeliveryTarget::timeline_key() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.DeliveryTarget.timeline_key)
  return _internal_timeline_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeliveryTarget::set_timeline_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.timeline_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.fanout.DeliveryTarget.timeline_key)
}
inline std::string* DeliveryTarget::mutable_timeline_key() {
  std::string* _s = _internal_mutable_timeline_key();
  // @@protoc_insertion_point(field_mutable:sonet.fanout.DeliveryTarget.timeline_key)
  return _s;
}
inline const std::string& DeliveryTarget::_internal_timeline_key() const {
  return _impl_.timeline_key_.Get();
}
inline void DeliveryTarget::_internal_set_timeline_key(const std::string& value) {
  
  _impl_.timeline_key_.Set(value, GetArenaForAllocation());
}
inline std::string* DeliveryTarget::_internal_mutable_timeline_key() {
  
  return _impl_.timeline_key_.Mutable(GetArenaForAllocation());
}
inline std::string* DeliveryTarget::release_timeline_key() {
  // @@protoc_insertion_point(field_release:sonet.fanout.DeliveryTarget.timeline_key)
  return _impl_.timeline_key_.Release();
}
inline void DeliveryTarget::set_allocated_timeline_key(std::string* timeline_key) {
  if (timeline_key != nullptr) {
    
  } else {
    
  }
  _impl_.timeline_key_.SetAllocated(timeline_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.timeline_key_.IsDefault()) {
    _impl_.timeline_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.fanout.DeliveryTarget.timeline_key)
}

// bool is_active_user = 3;
inline void DeliveryTarget::clear_is_active_user() {
  _impl_.is_active_user_ = false;
}
inline bool DeliveryTarget::_internal_is_active_user() const {
  return _impl_.is_active_user_;
}
inline bool DeliveryTarget::is_active_user() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.DeliveryTarget.is_active_user)
  return _internal_is_active_user();
}
inline void DeliveryTarget::_internal_set_is_active_user(bool value) {
  
  _impl_.is_active_user_ = value;
}
inline void DeliveryTarget::set_is_active_user(bool value) {
  _internal_set_is_active_user(value);
  // @@protoc_insertion_point(field_set:sonet.fanout.DeliveryTarget.is_active_user)
}

// .sonet.common.Timestamp last_seen = 4;
inline bool DeliveryTarget::_internal_has_last_seen() const {
  return this != internal_default_instance() && _impl_.last_seen_ != nullptr;
}
inline bool DeliveryTarget::has_last_seen() const {
  return _internal_has_last_seen();
}
inline const ::sonet::common::Timestamp& DeliveryTarget::_internal_last_seen() const {
  const ::sonet::common::Timestamp* p = _impl_.last_seen_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Timestamp&>(
      ::sonet::common::_Timestamp_default_instance_);
}
inline const ::sonet::common::Timestamp& DeliveryTarget::last_seen() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.DeliveryTarget.last_seen)
  return _internal_last_seen();
}
inline void DeliveryTarget::unsafe_arena_set_allocated_last_seen(
    ::sonet::common::Timestamp* last_seen) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_seen_);
  }
  _impl_.last_seen_ = last_seen;
  if (last_seen) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.fanout.DeliveryTarget.last_seen)
}
inline ::sonet::common::Timestamp* DeliveryTarget::release_last_seen() {
  
  ::sonet::common::Timestamp* temp = _impl_.last_seen_;
  _impl_.last_seen_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Timestamp* DeliveryTarget::unsafe_arena_release_last_seen() {
  // @@protoc_insertion_point(field_release:sonet.fanout.DeliveryTarget.last_seen)
  
  ::sonet::common::Timestamp* temp = _impl_.last_seen_;
  _impl_.last_seen_ = nullptr;
  return temp;
}
inline ::sonet::common::Timestamp* DeliveryTarget::_internal_mutable_last_seen() {
  
  if (_impl_.last_seen_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Timestamp>(GetArenaForAllocation());
    _impl_.last_seen_ = p;
  }
  return _impl_.last_seen_;
}
inline ::sonet::common::Timestamp* DeliveryTarget::mutable_last_seen() {
  ::sonet::common::Timestamp* _msg = _internal_mutable_last_seen();
  // @@protoc_insertion_point(field_mutable:sonet.fanout.DeliveryTarget.last_seen)
  return _msg;
}
inline void DeliveryTarget::set_allocated_last_seen(::sonet::common::Timestamp* last_seen) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_seen_);
  }
  if (last_seen) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_seen));
    if (message_arena != submessage_arena) {
      last_seen = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_seen, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.last_seen_ = last_seen;
  // @@protoc_insertion_point(field_set_allocated:sonet.fanout.DeliveryTarget.last_seen)
}

// int32 follower_tier = 5;
inline void DeliveryTarget::clear_follower_tier() {
  _impl_.follower_tier_ = 0;
}
inline int32_t DeliveryTarget::_internal_follower_tier() const {
  return _impl_.follower_tier_;
}
inline int32_t DeliveryTarget::follower_tier() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.DeliveryTarget.follower_tier)
  return _internal_follower_tier();
}
inline void DeliveryTarget::_internal_set_follower_tier(int32_t value) {
  
  _impl_.follower_tier_ = value;
}
inline void DeliveryTarget::set_follower_tier(int32_t value) {
  _internal_set_follower_tier(value);
  // @@protoc_insertion_point(field_set:sonet.fanout.DeliveryTarget.follower_tier)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// FanoutMetrics

// string author_id = 1;
inline void FanoutMetrics::clear_author_id() {
  _impl_.author_id_.ClearToEmpty();
}
inline const std::string& FanoutMetrics::author_id() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.FanoutMetrics.author_id)
  return _internal_author_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FanoutMetrics::set_author_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.author_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.fanout.FanoutMetrics.author_id)
}
inline std::string* FanoutMetrics::mutable_author_id() {
  std::string* _s = _internal_mutable_author_id();
  // @@protoc_insertion_point(field_mutable:sonet.fanout.FanoutMetrics.author_id)
  return _s;
}
inline const std::string& FanoutMetrics::_internal_author_id() const {
  return _impl_.author_id_.Get();
}
inline void FanoutMetrics::_internal_set_author_id(const std::string& value) {
  
  _impl_.author_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FanoutMetrics::_internal_mutable_author_id() {
  
  return _impl_.author_id_.Mutable(GetArenaForAllocation());
}
inline std::string* FanoutMetrics::release_author_id() {
  // @@protoc_insertion_point(field_release:sonet.fanout.FanoutMetrics.author_id)
  return _impl_.author_id_.Release();
}
inline void FanoutMetrics::set_allocated_author_id(std::string* author_id) {
  if (author_id != nullptr) {
    
  } else {
    
  }
  _impl_.author_id_.SetAllocated(author_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.author_id_.IsDefault()) {
    _impl_.author_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.fanout.FanoutMetrics.author_id)
}

// string note_id = 2;
inline void FanoutMetrics::clear_note_id() {
  _impl_.note_id_.ClearToEmpty();
}
inline const std::string& FanoutMetrics::note_id() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.FanoutMetrics.note_id)
  return _internal_note_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FanoutMetrics::set_note_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.note_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.fanout.FanoutMetrics.note_id)
}
inline std::string* FanoutMetrics::mutable_note_id() {
  std::string* _s = _internal_mutable_note_id();
  // @@protoc_insertion_point(field_mutable:sonet.fanout.FanoutMetrics.note_id)
  return _s;
}
inline const std::string& FanoutMetrics::_internal_note_id() const {
  return _impl_.note_id_.Get();
}
inline void FanoutMetrics::_internal_set_note_id(const std::string& value) {
  
  _impl_.note_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FanoutMetrics::_internal_mutable_note_id() {
  
  return _impl_.note_id_.Mutable(GetArenaForAllocation());
}
inline std::string* FanoutMetrics::release_note_id() {
  // @@protoc_insertion_point(field_release:sonet.fanout.FanoutMetrics.note_id)
  return _impl_.note_id_.Release();
}
inline void FanoutMetrics::set_allocated_note_id(std::string* note_id) {
  if (note_id != nullptr) {
    
  } else {
    
  }
  _impl_.note_id_.SetAllocated(note_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.note_id_.IsDefault()) {
    _impl_.note_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.fanout.FanoutMetrics.note_id)
}

// int64 total_deliveries = 3;
inline void FanoutMetrics::clear_total_deliveries() {
  _impl_.total_deliveries_ = int64_t{0};
}
inline int64_t FanoutMetrics::_internal_total_deliveries() const {
  return _impl_.total_deliveries_;
}
inline int64_t FanoutMetrics::total_deliveries() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.FanoutMetrics.total_deliveries)
  return _internal_total_deliveries();
}
inline void FanoutMetrics::_internal_set_total_deliveries(int64_t value) {
  
  _impl_.total_deliveries_ = value;
}
inline void FanoutMetrics::set_total_deliveries(int64_t value) {
  _internal_set_total_deliveries(value);
  // @@protoc_insertion_point(field_set:sonet.fanout.FanoutMetrics.total_deliveries)
}

// int64 successful_deliveries = 4;
inline void FanoutMetrics::clear_successful_deliveries() {
  _impl_.successful_deliveries_ = int64_t{0};
}
inline int64_t FanoutMetrics::_internal_successful_deliveries() const {
  return _impl_.successful_deliveries_;
}
inline int64_t FanoutMetrics::successful_deliveries() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.FanoutMetrics.successful_deliveries)
  return _internal_successful_deliveries();
}
inline void FanoutMetrics::_internal_set_successful_deliveries(int64_t value) {
  
  _impl_.successful_deliveries_ = value;
}
inline void FanoutMetrics::set_successful_deliveries(int64_t value) {
  _internal_set_successful_deliveries(value);
  // @@protoc_insertion_point(field_set:sonet.fanout.FanoutMetrics.successful_deliveries)
}

// int64 failed_deliveries = 5;
inline void FanoutMetrics::clear_failed_deliveries() {
  _impl_.failed_deliveries_ = int64_t{0};
}
inline int64_t FanoutMetrics::_internal_failed_deliveries() const {
  return _impl_.failed_deliveries_;
}
inline int64_t FanoutMetrics::failed_deliveries() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.FanoutMetrics.failed_deliveries)
  return _internal_failed_deliveries();
}
inline void FanoutMetrics::_internal_set_failed_deliveries(int64_t value) {
  
  _impl_.failed_deliveries_ = value;
}
inline void FanoutMetrics::set_failed_deliveries(int64_t value) {
  _internal_set_failed_deliveries(value);
  // @@protoc_insertion_point(field_set:sonet.fanout.FanoutMetrics.failed_deliveries)
}

// double avg_delivery_time_ms = 6;
inline void FanoutMetrics::clear_avg_delivery_time_ms() {
  _impl_.avg_delivery_time_ms_ = 0;
}
inline double FanoutMetrics::_internal_avg_delivery_time_ms() const {
  return _impl_.avg_delivery_time_ms_;
}
inline double FanoutMetrics::avg_delivery_time_ms() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.FanoutMetrics.avg_delivery_time_ms)
  return _internal_avg_delivery_time_ms();
}
inline void FanoutMetrics::_internal_set_avg_delivery_time_ms(double value) {
  
  _impl_.avg_delivery_time_ms_ = value;
}
inline void FanoutMetrics::set_avg_delivery_time_ms(double value) {
  _internal_set_avg_delivery_time_ms(value);
  // @@protoc_insertion_point(field_set:sonet.fanout.FanoutMetrics.avg_delivery_time_ms)
}

// map<string, int64> delivery_by_tier = 7;
inline int FanoutMetrics::_internal_delivery_by_tier_size() const {
  return _impl_.delivery_by_tier_.size();
}
inline int FanoutMetrics::delivery_by_tier_size() const {
  return _internal_delivery_by_tier_size();
}
inline void FanoutMetrics::clear_delivery_by_tier() {
  _impl_.delivery_by_tier_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
FanoutMetrics::_internal_delivery_by_tier() const {
  return _impl_.delivery_by_tier_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
FanoutMetrics::delivery_by_tier() const {
  // @@protoc_insertion_point(field_map:sonet.fanout.FanoutMetrics.delivery_by_tier)
  return _internal_delivery_by_tier();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
FanoutMetrics::_internal_mutable_delivery_by_tier() {
  return _impl_.delivery_by_tier_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
FanoutMetrics::mutable_delivery_by_tier() {
  // @@protoc_insertion_point(field_mutable_map:sonet.fanout.FanoutMetrics.delivery_by_tier)
  return _internal_mutable_delivery_by_tier();
}

// .sonet.common.Timestamp completed_at = 8;
inline bool FanoutMetrics::_internal_has_completed_at() const {
  return this != internal_default_instance() && _impl_.completed_at_ != nullptr;
}
inline bool FanoutMetrics::has_completed_at() const {
  return _internal_has_completed_at();
}
inline const ::sonet::common::Timestamp& FanoutMetrics::_internal_completed_at() const {
  const ::sonet::common::Timestamp* p = _impl_.completed_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Timestamp&>(
      ::sonet::common::_Timestamp_default_instance_);
}
inline const ::sonet::common::Timestamp& FanoutMetrics::completed_at() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.FanoutMetrics.completed_at)
  return _internal_completed_at();
}
inline void FanoutMetrics::unsafe_arena_set_allocated_completed_at(
    ::sonet::common::Timestamp* completed_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.completed_at_);
  }
  _impl_.completed_at_ = completed_at;
  if (completed_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.fanout.FanoutMetrics.completed_at)
}
inline ::sonet::common::Timestamp* FanoutMetrics::release_completed_at() {
  
  ::sonet::common::Timestamp* temp = _impl_.completed_at_;
  _impl_.completed_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Timestamp* FanoutMetrics::unsafe_arena_release_completed_at() {
  // @@protoc_insertion_point(field_release:sonet.fanout.FanoutMetrics.completed_at)
  
  ::sonet::common::Timestamp* temp = _impl_.completed_at_;
  _impl_.completed_at_ = nullptr;
  return temp;
}
inline ::sonet::common::Timestamp* FanoutMetrics::_internal_mutable_completed_at() {
  
  if (_impl_.completed_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Timestamp>(GetArenaForAllocation());
    _impl_.completed_at_ = p;
  }
  return _impl_.completed_at_;
}
inline ::sonet::common::Timestamp* FanoutMetrics::mutable_completed_at() {
  ::sonet::common::Timestamp* _msg = _internal_mutable_completed_at();
  // @@protoc_insertion_point(field_mutable:sonet.fanout.FanoutMetrics.completed_at)
  return _msg;
}
inline void FanoutMetrics::set_allocated_completed_at(::sonet::common::Timestamp* completed_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.completed_at_);
  }
  if (completed_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(completed_at));
    if (message_arena != submessage_arena) {
      completed_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, completed_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.completed_at_ = completed_at;
  // @@protoc_insertion_point(field_set_allocated:sonet.fanout.FanoutMetrics.completed_at)
}

// -------------------------------------------------------------------

// InitiateFanoutRequest

// .sonet.note.Note note = 1;
inline bool InitiateFanoutRequest::_internal_has_note() const {
  return this != internal_default_instance() && _impl_.note_ != nullptr;
}
inline bool InitiateFanoutRequest::has_note() const {
  return _internal_has_note();
}
inline const ::sonet::note::Note& InitiateFanoutRequest::_internal_note() const {
  const ::sonet::note::Note* p = _impl_.note_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::note::Note&>(
      ::sonet::note::_Note_default_instance_);
}
inline const ::sonet::note::Note& InitiateFanoutRequest::note() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.InitiateFanoutRequest.note)
  return _internal_note();
}
inline void InitiateFanoutRequest::unsafe_arena_set_allocated_note(
    ::sonet::note::Note* note) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.note_);
  }
  _impl_.note_ = note;
  if (note) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.fanout.InitiateFanoutRequest.note)
}
inline ::sonet::note::Note* InitiateFanoutRequest::release_note() {
  
  ::sonet::note::Note* temp = _impl_.note_;
  _impl_.note_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::note::Note* InitiateFanoutRequest::unsafe_arena_release_note() {
  // @@protoc_insertion_point(field_release:sonet.fanout.InitiateFanoutRequest.note)
  
  ::sonet::note::Note* temp = _impl_.note_;
  _impl_.note_ = nullptr;
  return temp;
}
inline ::sonet::note::Note* InitiateFanoutRequest::_internal_mutable_note() {
  
  if (_impl_.note_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::note::Note>(GetArenaForAllocation());
    _impl_.note_ = p;
  }
  return _impl_.note_;
}
inline ::sonet::note::Note* InitiateFanoutRequest::mutable_note() {
  ::sonet::note::Note* _msg = _internal_mutable_note();
  // @@protoc_insertion_point(field_mutable:sonet.fanout.InitiateFanoutRequest.note)
  return _msg;
}
inline void InitiateFanoutRequest::set_allocated_note(::sonet::note::Note* note) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.note_);
  }
  if (note) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(note));
    if (message_arena != submessage_arena) {
      note = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, note, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.note_ = note;
  // @@protoc_insertion_point(field_set_allocated:sonet.fanout.InitiateFanoutRequest.note)
}

// .sonet.fanout.FanoutStrategy strategy = 2;
inline void InitiateFanoutRequest::clear_strategy() {
  _impl_.strategy_ = 0;
}
inline ::sonet::fanout::FanoutStrategy InitiateFanoutRequest::_internal_strategy() const {
  return static_cast< ::sonet::fanout::FanoutStrategy >(_impl_.strategy_);
}
inline ::sonet::fanout::FanoutStrategy InitiateFanoutRequest::strategy() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.InitiateFanoutRequest.strategy)
  return _internal_strategy();
}
inline void InitiateFanoutRequest::_internal_set_strategy(::sonet::fanout::FanoutStrategy value) {
  
  _impl_.strategy_ = value;
}
inline void InitiateFanoutRequest::set_strategy(::sonet::fanout::FanoutStrategy value) {
  _internal_set_strategy(value);
  // @@protoc_insertion_point(field_set:sonet.fanout.InitiateFanoutRequest.strategy)
}

// bool urgent = 3;
inline void InitiateFanoutRequest::clear_urgent() {
  _impl_.urgent_ = false;
}
inline bool InitiateFanoutRequest::_internal_urgent() const {
  return _impl_.urgent_;
}
inline bool InitiateFanoutRequest::urgent() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.InitiateFanoutRequest.urgent)
  return _internal_urgent();
}
inline void InitiateFanoutRequest::_internal_set_urgent(bool value) {
  
  _impl_.urgent_ = value;
}
inline void InitiateFanoutRequest::set_urgent(bool value) {
  _internal_set_urgent(value);
  // @@protoc_insertion_point(field_set:sonet.fanout.InitiateFanoutRequest.urgent)
}

// repeated string specific_followers = 4;
inline int InitiateFanoutRequest::_internal_specific_followers_size() const {
  return _impl_.specific_followers_.size();
}
inline int InitiateFanoutRequest::specific_followers_size() const {
  return _internal_specific_followers_size();
}
inline void InitiateFanoutRequest::clear_specific_followers() {
  _impl_.specific_followers_.Clear();
}
inline std::string* InitiateFanoutRequest::add_specific_followers() {
  std::string* _s = _internal_add_specific_followers();
  // @@protoc_insertion_point(field_add_mutable:sonet.fanout.InitiateFanoutRequest.specific_followers)
  return _s;
}
inline const std::string& InitiateFanoutRequest::_internal_specific_followers(int index) const {
  return _impl_.specific_followers_.Get(index);
}
inline const std::string& InitiateFanoutRequest::specific_followers(int index) const {
  // @@protoc_insertion_point(field_get:sonet.fanout.InitiateFanoutRequest.specific_followers)
  return _internal_specific_followers(index);
}
inline std::string* InitiateFanoutRequest::mutable_specific_followers(int index) {
  // @@protoc_insertion_point(field_mutable:sonet.fanout.InitiateFanoutRequest.specific_followers)
  return _impl_.specific_followers_.Mutable(index);
}
inline void InitiateFanoutRequest::set_specific_followers(int index, const std::string& value) {
  _impl_.specific_followers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sonet.fanout.InitiateFanoutRequest.specific_followers)
}
inline void InitiateFanoutRequest::set_specific_followers(int index, std::string&& value) {
  _impl_.specific_followers_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sonet.fanout.InitiateFanoutRequest.specific_followers)
}
inline void InitiateFanoutRequest::set_specific_followers(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.specific_followers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sonet.fanout.InitiateFanoutRequest.specific_followers)
}
inline void InitiateFanoutRequest::set_specific_followers(int index, const char* value, size_t size) {
  _impl_.specific_followers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sonet.fanout.InitiateFanoutRequest.specific_followers)
}
inline std::string* InitiateFanoutRequest::_internal_add_specific_followers() {
  return _impl_.specific_followers_.Add();
}
inline void InitiateFanoutRequest::add_specific_followers(const std::string& value) {
  _impl_.specific_followers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sonet.fanout.InitiateFanoutRequest.specific_followers)
}
inline void InitiateFanoutRequest::add_specific_followers(std::string&& value) {
  _impl_.specific_followers_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sonet.fanout.InitiateFanoutRequest.specific_followers)
}
inline void InitiateFanoutRequest::add_specific_followers(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.specific_followers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sonet.fanout.InitiateFanoutRequest.specific_followers)
}
inline void InitiateFanoutRequest::add_specific_followers(const char* value, size_t size) {
  _impl_.specific_followers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sonet.fanout.InitiateFanoutRequest.specific_followers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
InitiateFanoutRequest::specific_followers() const {
  // @@protoc_insertion_point(field_list:sonet.fanout.InitiateFanoutRequest.specific_followers)
  return _impl_.specific_followers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
InitiateFanoutRequest::mutable_specific_followers() {
  // @@protoc_insertion_point(field_mutable_list:sonet.fanout.InitiateFanoutRequest.specific_followers)
  return &_impl_.specific_followers_;
}

// -------------------------------------------------------------------

// InitiateFanoutResponse

// string job_id = 1;
inline void InitiateFanoutResponse::clear_job_id() {
  _impl_.job_id_.ClearToEmpty();
}
inline const std::string& InitiateFanoutResponse::job_id() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.InitiateFanoutResponse.job_id)
  return _internal_job_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InitiateFanoutResponse::set_job_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.job_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.fanout.InitiateFanoutResponse.job_id)
}
inline std::string* InitiateFanoutResponse::mutable_job_id() {
  std::string* _s = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:sonet.fanout.InitiateFanoutResponse.job_id)
  return _s;
}
inline const std::string& InitiateFanoutResponse::_internal_job_id() const {
  return _impl_.job_id_.Get();
}
inline void InitiateFanoutResponse::_internal_set_job_id(const std::string& value) {
  
  _impl_.job_id_.Set(value, GetArenaForAllocation());
}
inline std::string* InitiateFanoutResponse::_internal_mutable_job_id() {
  
  return _impl_.job_id_.Mutable(GetArenaForAllocation());
}
inline std::string* InitiateFanoutResponse::release_job_id() {
  // @@protoc_insertion_point(field_release:sonet.fanout.InitiateFanoutResponse.job_id)
  return _impl_.job_id_.Release();
}
inline void InitiateFanoutResponse::set_allocated_job_id(std::string* job_id) {
  if (job_id != nullptr) {
    
  } else {
    
  }
  _impl_.job_id_.SetAllocated(job_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.job_id_.IsDefault()) {
    _impl_.job_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.fanout.InitiateFanoutResponse.job_id)
}

// .sonet.fanout.FanoutStrategy strategy_used = 2;
inline void InitiateFanoutResponse::clear_strategy_used() {
  _impl_.strategy_used_ = 0;
}
inline ::sonet::fanout::FanoutStrategy InitiateFanoutResponse::_internal_strategy_used() const {
  return static_cast< ::sonet::fanout::FanoutStrategy >(_impl_.strategy_used_);
}
inline ::sonet::fanout::FanoutStrategy InitiateFanoutResponse::strategy_used() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.InitiateFanoutResponse.strategy_used)
  return _internal_strategy_used();
}
inline void InitiateFanoutResponse::_internal_set_strategy_used(::sonet::fanout::FanoutStrategy value) {
  
  _impl_.strategy_used_ = value;
}
inline void InitiateFanoutResponse::set_strategy_used(::sonet::fanout::FanoutStrategy value) {
  _internal_set_strategy_used(value);
  // @@protoc_insertion_point(field_set:sonet.fanout.InitiateFanoutResponse.strategy_used)
}

// int32 estimated_deliveries = 3;
inline void InitiateFanoutResponse::clear_estimated_deliveries() {
  _impl_.estimated_deliveries_ = 0;
}
inline int32_t InitiateFanoutResponse::_internal_estimated_deliveries() const {
  return _impl_.estimated_deliveries_;
}
inline int32_t InitiateFanoutResponse::estimated_deliveries() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.InitiateFanoutResponse.estimated_deliveries)
  return _internal_estimated_deliveries();
}
inline void InitiateFanoutResponse::_internal_set_estimated_deliveries(int32_t value) {
  
  _impl_.estimated_deliveries_ = value;
}
inline void InitiateFanoutResponse::set_estimated_deliveries(int32_t value) {
  _internal_set_estimated_deliveries(value);
  // @@protoc_insertion_point(field_set:sonet.fanout.InitiateFanoutResponse.estimated_deliveries)
}

// double estimated_completion_time_ms = 4;
inline void InitiateFanoutResponse::clear_estimated_completion_time_ms() {
  _impl_.estimated_completion_time_ms_ = 0;
}
inline double InitiateFanoutResponse::_internal_estimated_completion_time_ms() const {
  return _impl_.estimated_completion_time_ms_;
}
inline double InitiateFanoutResponse::estimated_completion_time_ms() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.InitiateFanoutResponse.estimated_completion_time_ms)
  return _internal_estimated_completion_time_ms();
}
inline void InitiateFanoutResponse::_internal_set_estimated_completion_time_ms(double value) {
  
  _impl_.estimated_completion_time_ms_ = value;
}
inline void InitiateFanoutResponse::set_estimated_completion_time_ms(double value) {
  _internal_set_estimated_completion_time_ms(value);
  // @@protoc_insertion_point(field_set:sonet.fanout.InitiateFanoutResponse.estimated_completion_time_ms)
}

// bool success = 5;
inline void InitiateFanoutResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool InitiateFanoutResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool InitiateFanoutResponse::success() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.InitiateFanoutResponse.success)
  return _internal_success();
}
inline void InitiateFanoutResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void InitiateFanoutResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:sonet.fanout.InitiateFanoutResponse.success)
}

// string error_message = 6;
inline void InitiateFanoutResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& InitiateFanoutResponse::error_message() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.InitiateFanoutResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InitiateFanoutResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.fanout.InitiateFanoutResponse.error_message)
}
inline std::string* InitiateFanoutResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:sonet.fanout.InitiateFanoutResponse.error_message)
  return _s;
}
inline const std::string& InitiateFanoutResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void InitiateFanoutResponse::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* InitiateFanoutResponse::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* InitiateFanoutResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:sonet.fanout.InitiateFanoutResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void InitiateFanoutResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.fanout.InitiateFanoutResponse.error_message)
}

// -------------------------------------------------------------------

// GetFanoutJobStatusRequest

// string job_id = 1;
inline void GetFanoutJobStatusRequest::clear_job_id() {
  _impl_.job_id_.ClearToEmpty();
}
inline const std::string& GetFanoutJobStatusRequest::job_id() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.GetFanoutJobStatusRequest.job_id)
  return _internal_job_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFanoutJobStatusRequest::set_job_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.job_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.fanout.GetFanoutJobStatusRequest.job_id)
}
inline std::string* GetFanoutJobStatusRequest::mutable_job_id() {
  std::string* _s = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:sonet.fanout.GetFanoutJobStatusRequest.job_id)
  return _s;
}
inline const std::string& GetFanoutJobStatusRequest::_internal_job_id() const {
  return _impl_.job_id_.Get();
}
inline void GetFanoutJobStatusRequest::_internal_set_job_id(const std::string& value) {
  
  _impl_.job_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetFanoutJobStatusRequest::_internal_mutable_job_id() {
  
  return _impl_.job_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetFanoutJobStatusRequest::release_job_id() {
  // @@protoc_insertion_point(field_release:sonet.fanout.GetFanoutJobStatusRequest.job_id)
  return _impl_.job_id_.Release();
}
inline void GetFanoutJobStatusRequest::set_allocated_job_id(std::string* job_id) {
  if (job_id != nullptr) {
    
  } else {
    
  }
  _impl_.job_id_.SetAllocated(job_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.job_id_.IsDefault()) {
    _impl_.job_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.fanout.GetFanoutJobStatusRequest.job_id)
}

// -------------------------------------------------------------------

// GetFanoutJobStatusResponse

// .sonet.fanout.FanoutJob job = 1;
inline bool GetFanoutJobStatusResponse::_internal_has_job() const {
  return this != internal_default_instance() && _impl_.job_ != nullptr;
}
inline bool GetFanoutJobStatusResponse::has_job() const {
  return _internal_has_job();
}
inline void GetFanoutJobStatusResponse::clear_job() {
  if (GetArenaForAllocation() == nullptr && _impl_.job_ != nullptr) {
    delete _impl_.job_;
  }
  _impl_.job_ = nullptr;
}
inline const ::sonet::fanout::FanoutJob& GetFanoutJobStatusResponse::_internal_job() const {
  const ::sonet::fanout::FanoutJob* p = _impl_.job_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::fanout::FanoutJob&>(
      ::sonet::fanout::_FanoutJob_default_instance_);
}
inline const ::sonet::fanout::FanoutJob& GetFanoutJobStatusResponse::job() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.GetFanoutJobStatusResponse.job)
  return _internal_job();
}
inline void GetFanoutJobStatusResponse::unsafe_arena_set_allocated_job(
    ::sonet::fanout::FanoutJob* job) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.job_);
  }
  _impl_.job_ = job;
  if (job) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.fanout.GetFanoutJobStatusResponse.job)
}
inline ::sonet::fanout::FanoutJob* GetFanoutJobStatusResponse::release_job() {
  
  ::sonet::fanout::FanoutJob* temp = _impl_.job_;
  _impl_.job_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::fanout::FanoutJob* GetFanoutJobStatusResponse::unsafe_arena_release_job() {
  // @@protoc_insertion_point(field_release:sonet.fanout.GetFanoutJobStatusResponse.job)
  
  ::sonet::fanout::FanoutJob* temp = _impl_.job_;
  _impl_.job_ = nullptr;
  return temp;
}
inline ::sonet::fanout::FanoutJob* GetFanoutJobStatusResponse::_internal_mutable_job() {
  
  if (_impl_.job_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::fanout::FanoutJob>(GetArenaForAllocation());
    _impl_.job_ = p;
  }
  return _impl_.job_;
}
inline ::sonet::fanout::FanoutJob* GetFanoutJobStatusResponse::mutable_job() {
  ::sonet::fanout::FanoutJob* _msg = _internal_mutable_job();
  // @@protoc_insertion_point(field_mutable:sonet.fanout.GetFanoutJobStatusResponse.job)
  return _msg;
}
inline void GetFanoutJobStatusResponse::set_allocated_job(::sonet::fanout::FanoutJob* job) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.job_;
  }
  if (job) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(job);
    if (message_arena != submessage_arena) {
      job = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, job, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.job_ = job;
  // @@protoc_insertion_point(field_set_allocated:sonet.fanout.GetFanoutJobStatusResponse.job)
}

// bool success = 2;
inline void GetFanoutJobStatusResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool GetFanoutJobStatusResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool GetFanoutJobStatusResponse::success() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.GetFanoutJobStatusResponse.success)
  return _internal_success();
}
inline void GetFanoutJobStatusResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void GetFanoutJobStatusResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:sonet.fanout.GetFanoutJobStatusResponse.success)
}

// string error_message = 3;
inline void GetFanoutJobStatusResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& GetFanoutJobStatusResponse::error_message() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.GetFanoutJobStatusResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFanoutJobStatusResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.fanout.GetFanoutJobStatusResponse.error_message)
}
inline std::string* GetFanoutJobStatusResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:sonet.fanout.GetFanoutJobStatusResponse.error_message)
  return _s;
}
inline const std::string& GetFanoutJobStatusResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void GetFanoutJobStatusResponse::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* GetFanoutJobStatusResponse::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* GetFanoutJobStatusResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:sonet.fanout.GetFanoutJobStatusResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void GetFanoutJobStatusResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.fanout.GetFanoutJobStatusResponse.error_message)
}

// -------------------------------------------------------------------

// CancelFanoutJobRequest

// string job_id = 1;
inline void CancelFanoutJobRequest::clear_job_id() {
  _impl_.job_id_.ClearToEmpty();
}
inline const std::string& CancelFanoutJobRequest::job_id() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.CancelFanoutJobRequest.job_id)
  return _internal_job_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CancelFanoutJobRequest::set_job_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.job_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.fanout.CancelFanoutJobRequest.job_id)
}
inline std::string* CancelFanoutJobRequest::mutable_job_id() {
  std::string* _s = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:sonet.fanout.CancelFanoutJobRequest.job_id)
  return _s;
}
inline const std::string& CancelFanoutJobRequest::_internal_job_id() const {
  return _impl_.job_id_.Get();
}
inline void CancelFanoutJobRequest::_internal_set_job_id(const std::string& value) {
  
  _impl_.job_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CancelFanoutJobRequest::_internal_mutable_job_id() {
  
  return _impl_.job_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CancelFanoutJobRequest::release_job_id() {
  // @@protoc_insertion_point(field_release:sonet.fanout.CancelFanoutJobRequest.job_id)
  return _impl_.job_id_.Release();
}
inline void CancelFanoutJobRequest::set_allocated_job_id(std::string* job_id) {
  if (job_id != nullptr) {
    
  } else {
    
  }
  _impl_.job_id_.SetAllocated(job_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.job_id_.IsDefault()) {
    _impl_.job_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.fanout.CancelFanoutJobRequest.job_id)
}

// string reason = 2;
inline void CancelFanoutJobRequest::clear_reason() {
  _impl_.reason_.ClearToEmpty();
}
inline const std::string& CancelFanoutJobRequest::reason() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.CancelFanoutJobRequest.reason)
  return _internal_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CancelFanoutJobRequest::set_reason(ArgT0&& arg0, ArgT... args) {
 
 _impl_.reason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.fanout.CancelFanoutJobRequest.reason)
}
inline std::string* CancelFanoutJobRequest::mutable_reason() {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:sonet.fanout.CancelFanoutJobRequest.reason)
  return _s;
}
inline const std::string& CancelFanoutJobRequest::_internal_reason() const {
  return _impl_.reason_.Get();
}
inline void CancelFanoutJobRequest::_internal_set_reason(const std::string& value) {
  
  _impl_.reason_.Set(value, GetArenaForAllocation());
}
inline std::string* CancelFanoutJobRequest::_internal_mutable_reason() {
  
  return _impl_.reason_.Mutable(GetArenaForAllocation());
}
inline std::string* CancelFanoutJobRequest::release_reason() {
  // @@protoc_insertion_point(field_release:sonet.fanout.CancelFanoutJobRequest.reason)
  return _impl_.reason_.Release();
}
inline void CancelFanoutJobRequest::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    
  } else {
    
  }
  _impl_.reason_.SetAllocated(reason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reason_.IsDefault()) {
    _impl_.reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.fanout.CancelFanoutJobRequest.reason)
}

// -------------------------------------------------------------------

// CancelFanoutJobResponse

// bool success = 1;
inline void CancelFanoutJobResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool CancelFanoutJobResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool CancelFanoutJobResponse::success() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.CancelFanoutJobResponse.success)
  return _internal_success();
}
inline void CancelFanoutJobResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void CancelFanoutJobResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:sonet.fanout.CancelFanoutJobResponse.success)
}

// string error_message = 2;
inline void CancelFanoutJobResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& CancelFanoutJobResponse::error_message() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.CancelFanoutJobResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CancelFanoutJobResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.fanout.CancelFanoutJobResponse.error_message)
}
inline std::string* CancelFanoutJobResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:sonet.fanout.CancelFanoutJobResponse.error_message)
  return _s;
}
inline const std::string& CancelFanoutJobResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void CancelFanoutJobResponse::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* CancelFanoutJobResponse::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* CancelFanoutJobResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:sonet.fanout.CancelFanoutJobResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void CancelFanoutJobResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.fanout.CancelFanoutJobResponse.error_message)
}

// -------------------------------------------------------------------

// GetUserTierRequest

// string user_id = 1;
inline void GetUserTierRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& GetUserTierRequest::user_id() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.GetUserTierRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetUserTierRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.fanout.GetUserTierRequest.user_id)
}
inline std::string* GetUserTierRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:sonet.fanout.GetUserTierRequest.user_id)
  return _s;
}
inline const std::string& GetUserTierRequest::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void GetUserTierRequest::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetUserTierRequest::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetUserTierRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:sonet.fanout.GetUserTierRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void GetUserTierRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.fanout.GetUserTierRequest.user_id)
}

// -------------------------------------------------------------------

// GetUserTierResponse

// .sonet.fanout.UserTier tier = 1;
inline void GetUserTierResponse::clear_tier() {
  _impl_.tier_ = 0;
}
inline ::sonet::fanout::UserTier GetUserTierResponse::_internal_tier() const {
  return static_cast< ::sonet::fanout::UserTier >(_impl_.tier_);
}
inline ::sonet::fanout::UserTier GetUserTierResponse::tier() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.GetUserTierResponse.tier)
  return _internal_tier();
}
inline void GetUserTierResponse::_internal_set_tier(::sonet::fanout::UserTier value) {
  
  _impl_.tier_ = value;
}
inline void GetUserTierResponse::set_tier(::sonet::fanout::UserTier value) {
  _internal_set_tier(value);
  // @@protoc_insertion_point(field_set:sonet.fanout.GetUserTierResponse.tier)
}

// int32 follower_count = 2;
inline void GetUserTierResponse::clear_follower_count() {
  _impl_.follower_count_ = 0;
}
inline int32_t GetUserTierResponse::_internal_follower_count() const {
  return _impl_.follower_count_;
}
inline int32_t GetUserTierResponse::follower_count() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.GetUserTierResponse.follower_count)
  return _internal_follower_count();
}
inline void GetUserTierResponse::_internal_set_follower_count(int32_t value) {
  
  _impl_.follower_count_ = value;
}
inline void GetUserTierResponse::set_follower_count(int32_t value) {
  _internal_set_follower_count(value);
  // @@protoc_insertion_point(field_set:sonet.fanout.GetUserTierResponse.follower_count)
}

// .sonet.fanout.FanoutStrategy recommended_strategy = 3;
inline void GetUserTierResponse::clear_recommended_strategy() {
  _impl_.recommended_strategy_ = 0;
}
inline ::sonet::fanout::FanoutStrategy GetUserTierResponse::_internal_recommended_strategy() const {
  return static_cast< ::sonet::fanout::FanoutStrategy >(_impl_.recommended_strategy_);
}
inline ::sonet::fanout::FanoutStrategy GetUserTierResponse::recommended_strategy() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.GetUserTierResponse.recommended_strategy)
  return _internal_recommended_strategy();
}
inline void GetUserTierResponse::_internal_set_recommended_strategy(::sonet::fanout::FanoutStrategy value) {
  
  _impl_.recommended_strategy_ = value;
}
inline void GetUserTierResponse::set_recommended_strategy(::sonet::fanout::FanoutStrategy value) {
  _internal_set_recommended_strategy(value);
  // @@protoc_insertion_point(field_set:sonet.fanout.GetUserTierResponse.recommended_strategy)
}

// bool success = 4;
inline void GetUserTierResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool GetUserTierResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool GetUserTierResponse::success() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.GetUserTierResponse.success)
  return _internal_success();
}
inline void GetUserTierResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void GetUserTierResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:sonet.fanout.GetUserTierResponse.success)
}

// string error_message = 5;
inline void GetUserTierResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& GetUserTierResponse::error_message() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.GetUserTierResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetUserTierResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.fanout.GetUserTierResponse.error_message)
}
inline std::string* GetUserTierResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:sonet.fanout.GetUserTierResponse.error_message)
  return _s;
}
inline const std::string& GetUserTierResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void GetUserTierResponse::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* GetUserTierResponse::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* GetUserTierResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:sonet.fanout.GetUserTierResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void GetUserTierResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.fanout.GetUserTierResponse.error_message)
}

// -------------------------------------------------------------------

// ProcessFollowerBatchRequest

// .sonet.fanout.FollowerBatch batch = 1;
inline bool ProcessFollowerBatchRequest::_internal_has_batch() const {
  return this != internal_default_instance() && _impl_.batch_ != nullptr;
}
inline bool ProcessFollowerBatchRequest::has_batch() const {
  return _internal_has_batch();
}
inline void ProcessFollowerBatchRequest::clear_batch() {
  if (GetArenaForAllocation() == nullptr && _impl_.batch_ != nullptr) {
    delete _impl_.batch_;
  }
  _impl_.batch_ = nullptr;
}
inline const ::sonet::fanout::FollowerBatch& ProcessFollowerBatchRequest::_internal_batch() const {
  const ::sonet::fanout::FollowerBatch* p = _impl_.batch_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::fanout::FollowerBatch&>(
      ::sonet::fanout::_FollowerBatch_default_instance_);
}
inline const ::sonet::fanout::FollowerBatch& ProcessFollowerBatchRequest::batch() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.ProcessFollowerBatchRequest.batch)
  return _internal_batch();
}
inline void ProcessFollowerBatchRequest::unsafe_arena_set_allocated_batch(
    ::sonet::fanout::FollowerBatch* batch) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.batch_);
  }
  _impl_.batch_ = batch;
  if (batch) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.fanout.ProcessFollowerBatchRequest.batch)
}
inline ::sonet::fanout::FollowerBatch* ProcessFollowerBatchRequest::release_batch() {
  
  ::sonet::fanout::FollowerBatch* temp = _impl_.batch_;
  _impl_.batch_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::fanout::FollowerBatch* ProcessFollowerBatchRequest::unsafe_arena_release_batch() {
  // @@protoc_insertion_point(field_release:sonet.fanout.ProcessFollowerBatchRequest.batch)
  
  ::sonet::fanout::FollowerBatch* temp = _impl_.batch_;
  _impl_.batch_ = nullptr;
  return temp;
}
inline ::sonet::fanout::FollowerBatch* ProcessFollowerBatchRequest::_internal_mutable_batch() {
  
  if (_impl_.batch_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::fanout::FollowerBatch>(GetArenaForAllocation());
    _impl_.batch_ = p;
  }
  return _impl_.batch_;
}
inline ::sonet::fanout::FollowerBatch* ProcessFollowerBatchRequest::mutable_batch() {
  ::sonet::fanout::FollowerBatch* _msg = _internal_mutable_batch();
  // @@protoc_insertion_point(field_mutable:sonet.fanout.ProcessFollowerBatchRequest.batch)
  return _msg;
}
inline void ProcessFollowerBatchRequest::set_allocated_batch(::sonet::fanout::FollowerBatch* batch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.batch_;
  }
  if (batch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(batch);
    if (message_arena != submessage_arena) {
      batch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, batch, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.batch_ = batch;
  // @@protoc_insertion_point(field_set_allocated:sonet.fanout.ProcessFollowerBatchRequest.batch)
}

// .sonet.note.Note note = 2;
inline bool ProcessFollowerBatchRequest::_internal_has_note() const {
  return this != internal_default_instance() && _impl_.note_ != nullptr;
}
inline bool ProcessFollowerBatchRequest::has_note() const {
  return _internal_has_note();
}
inline const ::sonet::note::Note& ProcessFollowerBatchRequest::_internal_note() const {
  const ::sonet::note::Note* p = _impl_.note_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::note::Note&>(
      ::sonet::note::_Note_default_instance_);
}
inline const ::sonet::note::Note& ProcessFollowerBatchRequest::note() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.ProcessFollowerBatchRequest.note)
  return _internal_note();
}
inline void ProcessFollowerBatchRequest::unsafe_arena_set_allocated_note(
    ::sonet::note::Note* note) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.note_);
  }
  _impl_.note_ = note;
  if (note) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.fanout.ProcessFollowerBatchRequest.note)
}
inline ::sonet::note::Note* ProcessFollowerBatchRequest::release_note() {
  
  ::sonet::note::Note* temp = _impl_.note_;
  _impl_.note_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::note::Note* ProcessFollowerBatchRequest::unsafe_arena_release_note() {
  // @@protoc_insertion_point(field_release:sonet.fanout.ProcessFollowerBatchRequest.note)
  
  ::sonet::note::Note* temp = _impl_.note_;
  _impl_.note_ = nullptr;
  return temp;
}
inline ::sonet::note::Note* ProcessFollowerBatchRequest::_internal_mutable_note() {
  
  if (_impl_.note_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::note::Note>(GetArenaForAllocation());
    _impl_.note_ = p;
  }
  return _impl_.note_;
}
inline ::sonet::note::Note* ProcessFollowerBatchRequest::mutable_note() {
  ::sonet::note::Note* _msg = _internal_mutable_note();
  // @@protoc_insertion_point(field_mutable:sonet.fanout.ProcessFollowerBatchRequest.note)
  return _msg;
}
inline void ProcessFollowerBatchRequest::set_allocated_note(::sonet::note::Note* note) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.note_);
  }
  if (note) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(note));
    if (message_arena != submessage_arena) {
      note = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, note, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.note_ = note;
  // @@protoc_insertion_point(field_set_allocated:sonet.fanout.ProcessFollowerBatchRequest.note)
}

// -------------------------------------------------------------------

// ProcessFollowerBatchResponse

// string batch_id = 1;
inline void ProcessFollowerBatchResponse::clear_batch_id() {
  _impl_.batch_id_.ClearToEmpty();
}
inline const std::string& ProcessFollowerBatchResponse::batch_id() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.ProcessFollowerBatchResponse.batch_id)
  return _internal_batch_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessFollowerBatchResponse::set_batch_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.batch_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.fanout.ProcessFollowerBatchResponse.batch_id)
}
inline std::string* ProcessFollowerBatchResponse::mutable_batch_id() {
  std::string* _s = _internal_mutable_batch_id();
  // @@protoc_insertion_point(field_mutable:sonet.fanout.ProcessFollowerBatchResponse.batch_id)
  return _s;
}
inline const std::string& ProcessFollowerBatchResponse::_internal_batch_id() const {
  return _impl_.batch_id_.Get();
}
inline void ProcessFollowerBatchResponse::_internal_set_batch_id(const std::string& value) {
  
  _impl_.batch_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessFollowerBatchResponse::_internal_mutable_batch_id() {
  
  return _impl_.batch_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessFollowerBatchResponse::release_batch_id() {
  // @@protoc_insertion_point(field_release:sonet.fanout.ProcessFollowerBatchResponse.batch_id)
  return _impl_.batch_id_.Release();
}
inline void ProcessFollowerBatchResponse::set_allocated_batch_id(std::string* batch_id) {
  if (batch_id != nullptr) {
    
  } else {
    
  }
  _impl_.batch_id_.SetAllocated(batch_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.batch_id_.IsDefault()) {
    _impl_.batch_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.fanout.ProcessFollowerBatchResponse.batch_id)
}

// int32 successful_deliveries = 2;
inline void ProcessFollowerBatchResponse::clear_successful_deliveries() {
  _impl_.successful_deliveries_ = 0;
}
inline int32_t ProcessFollowerBatchResponse::_internal_successful_deliveries() const {
  return _impl_.successful_deliveries_;
}
inline int32_t ProcessFollowerBatchResponse::successful_deliveries() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.ProcessFollowerBatchResponse.successful_deliveries)
  return _internal_successful_deliveries();
}
inline void ProcessFollowerBatchResponse::_internal_set_successful_deliveries(int32_t value) {
  
  _impl_.successful_deliveries_ = value;
}
inline void ProcessFollowerBatchResponse::set_successful_deliveries(int32_t value) {
  _internal_set_successful_deliveries(value);
  // @@protoc_insertion_point(field_set:sonet.fanout.ProcessFollowerBatchResponse.successful_deliveries)
}

// int32 failed_deliveries = 3;
inline void ProcessFollowerBatchResponse::clear_failed_deliveries() {
  _impl_.failed_deliveries_ = 0;
}
inline int32_t ProcessFollowerBatchResponse::_internal_failed_deliveries() const {
  return _impl_.failed_deliveries_;
}
inline int32_t ProcessFollowerBatchResponse::failed_deliveries() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.ProcessFollowerBatchResponse.failed_deliveries)
  return _internal_failed_deliveries();
}
inline void ProcessFollowerBatchResponse::_internal_set_failed_deliveries(int32_t value) {
  
  _impl_.failed_deliveries_ = value;
}
inline void ProcessFollowerBatchResponse::set_failed_deliveries(int32_t value) {
  _internal_set_failed_deliveries(value);
  // @@protoc_insertion_point(field_set:sonet.fanout.ProcessFollowerBatchResponse.failed_deliveries)
}

// repeated string failed_user_ids = 4;
inline int ProcessFollowerBatchResponse::_internal_failed_user_ids_size() const {
  return _impl_.failed_user_ids_.size();
}
inline int ProcessFollowerBatchResponse::failed_user_ids_size() const {
  return _internal_failed_user_ids_size();
}
inline void ProcessFollowerBatchResponse::clear_failed_user_ids() {
  _impl_.failed_user_ids_.Clear();
}
inline std::string* ProcessFollowerBatchResponse::add_failed_user_ids() {
  std::string* _s = _internal_add_failed_user_ids();
  // @@protoc_insertion_point(field_add_mutable:sonet.fanout.ProcessFollowerBatchResponse.failed_user_ids)
  return _s;
}
inline const std::string& ProcessFollowerBatchResponse::_internal_failed_user_ids(int index) const {
  return _impl_.failed_user_ids_.Get(index);
}
inline const std::string& ProcessFollowerBatchResponse::failed_user_ids(int index) const {
  // @@protoc_insertion_point(field_get:sonet.fanout.ProcessFollowerBatchResponse.failed_user_ids)
  return _internal_failed_user_ids(index);
}
inline std::string* ProcessFollowerBatchResponse::mutable_failed_user_ids(int index) {
  // @@protoc_insertion_point(field_mutable:sonet.fanout.ProcessFollowerBatchResponse.failed_user_ids)
  return _impl_.failed_user_ids_.Mutable(index);
}
inline void ProcessFollowerBatchResponse::set_failed_user_ids(int index, const std::string& value) {
  _impl_.failed_user_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sonet.fanout.ProcessFollowerBatchResponse.failed_user_ids)
}
inline void ProcessFollowerBatchResponse::set_failed_user_ids(int index, std::string&& value) {
  _impl_.failed_user_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sonet.fanout.ProcessFollowerBatchResponse.failed_user_ids)
}
inline void ProcessFollowerBatchResponse::set_failed_user_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.failed_user_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sonet.fanout.ProcessFollowerBatchResponse.failed_user_ids)
}
inline void ProcessFollowerBatchResponse::set_failed_user_ids(int index, const char* value, size_t size) {
  _impl_.failed_user_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sonet.fanout.ProcessFollowerBatchResponse.failed_user_ids)
}
inline std::string* ProcessFollowerBatchResponse::_internal_add_failed_user_ids() {
  return _impl_.failed_user_ids_.Add();
}
inline void ProcessFollowerBatchResponse::add_failed_user_ids(const std::string& value) {
  _impl_.failed_user_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sonet.fanout.ProcessFollowerBatchResponse.failed_user_ids)
}
inline void ProcessFollowerBatchResponse::add_failed_user_ids(std::string&& value) {
  _impl_.failed_user_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sonet.fanout.ProcessFollowerBatchResponse.failed_user_ids)
}
inline void ProcessFollowerBatchResponse::add_failed_user_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.failed_user_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sonet.fanout.ProcessFollowerBatchResponse.failed_user_ids)
}
inline void ProcessFollowerBatchResponse::add_failed_user_ids(const char* value, size_t size) {
  _impl_.failed_user_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sonet.fanout.ProcessFollowerBatchResponse.failed_user_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProcessFollowerBatchResponse::failed_user_ids() const {
  // @@protoc_insertion_point(field_list:sonet.fanout.ProcessFollowerBatchResponse.failed_user_ids)
  return _impl_.failed_user_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProcessFollowerBatchResponse::mutable_failed_user_ids() {
  // @@protoc_insertion_point(field_mutable_list:sonet.fanout.ProcessFollowerBatchResponse.failed_user_ids)
  return &_impl_.failed_user_ids_;
}

// bool success = 5;
inline void ProcessFollowerBatchResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool ProcessFollowerBatchResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool ProcessFollowerBatchResponse::success() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.ProcessFollowerBatchResponse.success)
  return _internal_success();
}
inline void ProcessFollowerBatchResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void ProcessFollowerBatchResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:sonet.fanout.ProcessFollowerBatchResponse.success)
}

// string error_message = 6;
inline void ProcessFollowerBatchResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& ProcessFollowerBatchResponse::error_message() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.ProcessFollowerBatchResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessFollowerBatchResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.fanout.ProcessFollowerBatchResponse.error_message)
}
inline std::string* ProcessFollowerBatchResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:sonet.fanout.ProcessFollowerBatchResponse.error_message)
  return _s;
}
inline const std::string& ProcessFollowerBatchResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void ProcessFollowerBatchResponse::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessFollowerBatchResponse::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessFollowerBatchResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:sonet.fanout.ProcessFollowerBatchResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void ProcessFollowerBatchResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.fanout.ProcessFollowerBatchResponse.error_message)
}

// -------------------------------------------------------------------

// GetFanoutMetricsRequest

// string author_id = 1;
inline void GetFanoutMetricsRequest::clear_author_id() {
  _impl_.author_id_.ClearToEmpty();
}
inline const std::string& GetFanoutMetricsRequest::author_id() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.GetFanoutMetricsRequest.author_id)
  return _internal_author_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFanoutMetricsRequest::set_author_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.author_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.fanout.GetFanoutMetricsRequest.author_id)
}
inline std::string* GetFanoutMetricsRequest::mutable_author_id() {
  std::string* _s = _internal_mutable_author_id();
  // @@protoc_insertion_point(field_mutable:sonet.fanout.GetFanoutMetricsRequest.author_id)
  return _s;
}
inline const std::string& GetFanoutMetricsRequest::_internal_author_id() const {
  return _impl_.author_id_.Get();
}
inline void GetFanoutMetricsRequest::_internal_set_author_id(const std::string& value) {
  
  _impl_.author_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetFanoutMetricsRequest::_internal_mutable_author_id() {
  
  return _impl_.author_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetFanoutMetricsRequest::release_author_id() {
  // @@protoc_insertion_point(field_release:sonet.fanout.GetFanoutMetricsRequest.author_id)
  return _impl_.author_id_.Release();
}
inline void GetFanoutMetricsRequest::set_allocated_author_id(std::string* author_id) {
  if (author_id != nullptr) {
    
  } else {
    
  }
  _impl_.author_id_.SetAllocated(author_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.author_id_.IsDefault()) {
    _impl_.author_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.fanout.GetFanoutMetricsRequest.author_id)
}

// string note_id = 2;
inline void GetFanoutMetricsRequest::clear_note_id() {
  _impl_.note_id_.ClearToEmpty();
}
inline const std::string& GetFanoutMetricsRequest::note_id() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.GetFanoutMetricsRequest.note_id)
  return _internal_note_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFanoutMetricsRequest::set_note_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.note_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.fanout.GetFanoutMetricsRequest.note_id)
}
inline std::string* GetFanoutMetricsRequest::mutable_note_id() {
  std::string* _s = _internal_mutable_note_id();
  // @@protoc_insertion_point(field_mutable:sonet.fanout.GetFanoutMetricsRequest.note_id)
  return _s;
}
inline const std::string& GetFanoutMetricsRequest::_internal_note_id() const {
  return _impl_.note_id_.Get();
}
inline void GetFanoutMetricsRequest::_internal_set_note_id(const std::string& value) {
  
  _impl_.note_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetFanoutMetricsRequest::_internal_mutable_note_id() {
  
  return _impl_.note_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetFanoutMetricsRequest::release_note_id() {
  // @@protoc_insertion_point(field_release:sonet.fanout.GetFanoutMetricsRequest.note_id)
  return _impl_.note_id_.Release();
}
inline void GetFanoutMetricsRequest::set_allocated_note_id(std::string* note_id) {
  if (note_id != nullptr) {
    
  } else {
    
  }
  _impl_.note_id_.SetAllocated(note_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.note_id_.IsDefault()) {
    _impl_.note_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.fanout.GetFanoutMetricsRequest.note_id)
}

// .sonet.common.Timestamp since = 3;
inline bool GetFanoutMetricsRequest::_internal_has_since() const {
  return this != internal_default_instance() && _impl_.since_ != nullptr;
}
inline bool GetFanoutMetricsRequest::has_since() const {
  return _internal_has_since();
}
inline const ::sonet::common::Timestamp& GetFanoutMetricsRequest::_internal_since() const {
  const ::sonet::common::Timestamp* p = _impl_.since_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Timestamp&>(
      ::sonet::common::_Timestamp_default_instance_);
}
inline const ::sonet::common::Timestamp& GetFanoutMetricsRequest::since() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.GetFanoutMetricsRequest.since)
  return _internal_since();
}
inline void GetFanoutMetricsRequest::unsafe_arena_set_allocated_since(
    ::sonet::common::Timestamp* since) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.since_);
  }
  _impl_.since_ = since;
  if (since) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.fanout.GetFanoutMetricsRequest.since)
}
inline ::sonet::common::Timestamp* GetFanoutMetricsRequest::release_since() {
  
  ::sonet::common::Timestamp* temp = _impl_.since_;
  _impl_.since_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Timestamp* GetFanoutMetricsRequest::unsafe_arena_release_since() {
  // @@protoc_insertion_point(field_release:sonet.fanout.GetFanoutMetricsRequest.since)
  
  ::sonet::common::Timestamp* temp = _impl_.since_;
  _impl_.since_ = nullptr;
  return temp;
}
inline ::sonet::common::Timestamp* GetFanoutMetricsRequest::_internal_mutable_since() {
  
  if (_impl_.since_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Timestamp>(GetArenaForAllocation());
    _impl_.since_ = p;
  }
  return _impl_.since_;
}
inline ::sonet::common::Timestamp* GetFanoutMetricsRequest::mutable_since() {
  ::sonet::common::Timestamp* _msg = _internal_mutable_since();
  // @@protoc_insertion_point(field_mutable:sonet.fanout.GetFanoutMetricsRequest.since)
  return _msg;
}
inline void GetFanoutMetricsRequest::set_allocated_since(::sonet::common::Timestamp* since) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.since_);
  }
  if (since) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(since));
    if (message_arena != submessage_arena) {
      since = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, since, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.since_ = since;
  // @@protoc_insertion_point(field_set_allocated:sonet.fanout.GetFanoutMetricsRequest.since)
}

// .sonet.common.Timestamp until = 4;
inline bool GetFanoutMetricsRequest::_internal_has_until() const {
  return this != internal_default_instance() && _impl_.until_ != nullptr;
}
inline bool GetFanoutMetricsRequest::has_until() const {
  return _internal_has_until();
}
inline const ::sonet::common::Timestamp& GetFanoutMetricsRequest::_internal_until() const {
  const ::sonet::common::Timestamp* p = _impl_.until_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Timestamp&>(
      ::sonet::common::_Timestamp_default_instance_);
}
inline const ::sonet::common::Timestamp& GetFanoutMetricsRequest::until() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.GetFanoutMetricsRequest.until)
  return _internal_until();
}
inline void GetFanoutMetricsRequest::unsafe_arena_set_allocated_until(
    ::sonet::common::Timestamp* until) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.until_);
  }
  _impl_.until_ = until;
  if (until) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.fanout.GetFanoutMetricsRequest.until)
}
inline ::sonet::common::Timestamp* GetFanoutMetricsRequest::release_until() {
  
  ::sonet::common::Timestamp* temp = _impl_.until_;
  _impl_.until_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Timestamp* GetFanoutMetricsRequest::unsafe_arena_release_until() {
  // @@protoc_insertion_point(field_release:sonet.fanout.GetFanoutMetricsRequest.until)
  
  ::sonet::common::Timestamp* temp = _impl_.until_;
  _impl_.until_ = nullptr;
  return temp;
}
inline ::sonet::common::Timestamp* GetFanoutMetricsRequest::_internal_mutable_until() {
  
  if (_impl_.until_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Timestamp>(GetArenaForAllocation());
    _impl_.until_ = p;
  }
  return _impl_.until_;
}
inline ::sonet::common::Timestamp* GetFanoutMetricsRequest::mutable_until() {
  ::sonet::common::Timestamp* _msg = _internal_mutable_until();
  // @@protoc_insertion_point(field_mutable:sonet.fanout.GetFanoutMetricsRequest.until)
  return _msg;
}
inline void GetFanoutMetricsRequest::set_allocated_until(::sonet::common::Timestamp* until) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.until_);
  }
  if (until) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(until));
    if (message_arena != submessage_arena) {
      until = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, until, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.until_ = until;
  // @@protoc_insertion_point(field_set_allocated:sonet.fanout.GetFanoutMetricsRequest.until)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GetFanoutMetricsResponse

// repeated .sonet.fanout.FanoutMetrics metrics = 1;
inline int GetFanoutMetricsResponse::_internal_metrics_size() const {
  return _impl_.metrics_.size();
}
inline int GetFanoutMetricsResponse::metrics_size() const {
  return _internal_metrics_size();
}
inline void GetFanoutMetricsResponse::clear_metrics() {
  _impl_.metrics_.Clear();
}
inline ::sonet::fanout::FanoutMetrics* GetFanoutMetricsResponse::mutable_metrics(int index) {
  // @@protoc_insertion_point(field_mutable:sonet.fanout.GetFanoutMetricsResponse.metrics)
  return _impl_.metrics_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::fanout::FanoutMetrics >*
GetFanoutMetricsResponse::mutable_metrics() {
  // @@protoc_insertion_point(field_mutable_list:sonet.fanout.GetFanoutMetricsResponse.metrics)
  return &_impl_.metrics_;
}
inline const ::sonet::fanout::FanoutMetrics& GetFanoutMetricsResponse::_internal_metrics(int index) const {
  return _impl_.metrics_.Get(index);
}
inline const ::sonet::fanout::FanoutMetrics& GetFanoutMetricsResponse::metrics(int index) const {
  // @@protoc_insertion_point(field_get:sonet.fanout.GetFanoutMetricsResponse.metrics)
  return _internal_metrics(index);
}
inline ::sonet::fanout::FanoutMetrics* GetFanoutMetricsResponse::_internal_add_metrics() {
  return _impl_.metrics_.Add();
}
inline ::sonet::fanout::FanoutMetrics* GetFanoutMetricsResponse::add_metrics() {
  ::sonet::fanout::FanoutMetrics* _add = _internal_add_metrics();
  // @@protoc_insertion_point(field_add:sonet.fanout.GetFanoutMetricsResponse.metrics)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::fanout::FanoutMetrics >&
GetFanoutMetricsResponse::metrics() const {
  // @@protoc_insertion_point(field_list:sonet.fanout.GetFanoutMetricsResponse.metrics)
  return _impl_.metrics_;
}

// map<string, double> summary_stats = 2;
inline int GetFanoutMetricsResponse::_internal_summary_stats_size() const {
  return _impl_.summary_stats_.size();
}
inline int GetFanoutMetricsResponse::summary_stats_size() const {
  return _internal_summary_stats_size();
}
inline void GetFanoutMetricsResponse::clear_summary_stats() {
  _impl_.summary_stats_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
GetFanoutMetricsResponse::_internal_summary_stats() const {
  return _impl_.summary_stats_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
GetFanoutMetricsResponse::summary_stats() const {
  // @@protoc_insertion_point(field_map:sonet.fanout.GetFanoutMetricsResponse.summary_stats)
  return _internal_summary_stats();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
GetFanoutMetricsResponse::_internal_mutable_summary_stats() {
  return _impl_.summary_stats_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
GetFanoutMetricsResponse::mutable_summary_stats() {
  // @@protoc_insertion_point(field_mutable_map:sonet.fanout.GetFanoutMetricsResponse.summary_stats)
  return _internal_mutable_summary_stats();
}

// bool success = 3;
inline void GetFanoutMetricsResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool GetFanoutMetricsResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool GetFanoutMetricsResponse::success() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.GetFanoutMetricsResponse.success)
  return _internal_success();
}
inline void GetFanoutMetricsResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void GetFanoutMetricsResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:sonet.fanout.GetFanoutMetricsResponse.success)
}

// string error_message = 4;
inline void GetFanoutMetricsResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& GetFanoutMetricsResponse::error_message() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.GetFanoutMetricsResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFanoutMetricsResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.fanout.GetFanoutMetricsResponse.error_message)
}
inline std::string* GetFanoutMetricsResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:sonet.fanout.GetFanoutMetricsResponse.error_message)
  return _s;
}
inline const std::string& GetFanoutMetricsResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void GetFanoutMetricsResponse::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* GetFanoutMetricsResponse::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* GetFanoutMetricsResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:sonet.fanout.GetFanoutMetricsResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void GetFanoutMetricsResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.fanout.GetFanoutMetricsResponse.error_message)
}

// -------------------------------------------------------------------

// HealthCheckRequest

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// HealthCheckResponse

// string status = 1;
inline void HealthCheckResponse::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& HealthCheckResponse::status() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.HealthCheckResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HealthCheckResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.fanout.HealthCheckResponse.status)
}
inline std::string* HealthCheckResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:sonet.fanout.HealthCheckResponse.status)
  return _s;
}
inline const std::string& HealthCheckResponse::_internal_status() const {
  return _impl_.status_.Get();
}
inline void HealthCheckResponse::_internal_set_status(const std::string& value) {
  
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* HealthCheckResponse::_internal_mutable_status() {
  
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* HealthCheckResponse::release_status() {
  // @@protoc_insertion_point(field_release:sonet.fanout.HealthCheckResponse.status)
  return _impl_.status_.Release();
}
inline void HealthCheckResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.fanout.HealthCheckResponse.status)
}

// map<string, string> details = 2;
inline int HealthCheckResponse::_internal_details_size() const {
  return _impl_.details_.size();
}
inline int HealthCheckResponse::details_size() const {
  return _internal_details_size();
}
inline void HealthCheckResponse::clear_details() {
  _impl_.details_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
HealthCheckResponse::_internal_details() const {
  return _impl_.details_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
HealthCheckResponse::details() const {
  // @@protoc_insertion_point(field_map:sonet.fanout.HealthCheckResponse.details)
  return _internal_details();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
HealthCheckResponse::_internal_mutable_details() {
  return _impl_.details_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
HealthCheckResponse::mutable_details() {
  // @@protoc_insertion_point(field_mutable_map:sonet.fanout.HealthCheckResponse.details)
  return _internal_mutable_details();
}

// int32 pending_jobs = 3;
inline void HealthCheckResponse::clear_pending_jobs() {
  _impl_.pending_jobs_ = 0;
}
inline int32_t HealthCheckResponse::_internal_pending_jobs() const {
  return _impl_.pending_jobs_;
}
inline int32_t HealthCheckResponse::pending_jobs() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.HealthCheckResponse.pending_jobs)
  return _internal_pending_jobs();
}
inline void HealthCheckResponse::_internal_set_pending_jobs(int32_t value) {
  
  _impl_.pending_jobs_ = value;
}
inline void HealthCheckResponse::set_pending_jobs(int32_t value) {
  _internal_set_pending_jobs(value);
  // @@protoc_insertion_point(field_set:sonet.fanout.HealthCheckResponse.pending_jobs)
}

// int32 active_workers = 4;
inline void HealthCheckResponse::clear_active_workers() {
  _impl_.active_workers_ = 0;
}
inline int32_t HealthCheckResponse::_internal_active_workers() const {
  return _impl_.active_workers_;
}
inline int32_t HealthCheckResponse::active_workers() const {
  // @@protoc_insertion_point(field_get:sonet.fanout.HealthCheckResponse.active_workers)
  return _internal_active_workers();
}
inline void HealthCheckResponse::_internal_set_active_workers(int32_t value) {
  
  _impl_.active_workers_ = value;
}
inline void HealthCheckResponse::set_active_workers(int32_t value) {
  _internal_set_active_workers(value);
  // @@protoc_insertion_point(field_set:sonet.fanout.HealthCheckResponse.active_workers)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace fanout
}  // namespace sonet

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::sonet::fanout::FanoutJob_JobStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sonet::fanout::FanoutJob_JobStatus>() {
  return ::sonet::fanout::FanoutJob_JobStatus_descriptor();
}
template <> struct is_proto_enum< ::sonet::fanout::FanoutStrategy> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sonet::fanout::FanoutStrategy>() {
  return ::sonet::fanout::FanoutStrategy_descriptor();
}
template <> struct is_proto_enum< ::sonet::fanout::UserTier> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sonet::fanout::UserTier>() {
  return ::sonet::fanout::UserTier_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_services_2ffanout_2eproto
