// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: services/user.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_services_2fuser_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_services_2fuser_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common/common.pb.h"
#include "common/timestamp.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_services_2fuser_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_services_2fuser_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_services_2fuser_2eproto;
namespace sonet {
namespace user {
class AuthCredentials;
struct AuthCredentialsDefaultTypeInternal;
extern AuthCredentialsDefaultTypeInternal _AuthCredentials_default_instance_;
class ChangePasswordRequest;
struct ChangePasswordRequestDefaultTypeInternal;
extern ChangePasswordRequestDefaultTypeInternal _ChangePasswordRequest_default_instance_;
class ChangePasswordResponse;
struct ChangePasswordResponseDefaultTypeInternal;
extern ChangePasswordResponseDefaultTypeInternal _ChangePasswordResponse_default_instance_;
class ConfirmPasswordResetRequest;
struct ConfirmPasswordResetRequestDefaultTypeInternal;
extern ConfirmPasswordResetRequestDefaultTypeInternal _ConfirmPasswordResetRequest_default_instance_;
class ConfirmPasswordResetResponse;
struct ConfirmPasswordResetResponseDefaultTypeInternal;
extern ConfirmPasswordResetResponseDefaultTypeInternal _ConfirmPasswordResetResponse_default_instance_;
class DisableTwoFactorRequest;
struct DisableTwoFactorRequestDefaultTypeInternal;
extern DisableTwoFactorRequestDefaultTypeInternal _DisableTwoFactorRequest_default_instance_;
class DisableTwoFactorResponse;
struct DisableTwoFactorResponseDefaultTypeInternal;
extern DisableTwoFactorResponseDefaultTypeInternal _DisableTwoFactorResponse_default_instance_;
class GetActiveSessionsRequest;
struct GetActiveSessionsRequestDefaultTypeInternal;
extern GetActiveSessionsRequestDefaultTypeInternal _GetActiveSessionsRequest_default_instance_;
class GetActiveSessionsResponse;
struct GetActiveSessionsResponseDefaultTypeInternal;
extern GetActiveSessionsResponseDefaultTypeInternal _GetActiveSessionsResponse_default_instance_;
class GetUserProfileRequest;
struct GetUserProfileRequestDefaultTypeInternal;
extern GetUserProfileRequestDefaultTypeInternal _GetUserProfileRequest_default_instance_;
class GetUserProfileResponse;
struct GetUserProfileResponseDefaultTypeInternal;
extern GetUserProfileResponseDefaultTypeInternal _GetUserProfileResponse_default_instance_;
class LoginUserRequest;
struct LoginUserRequestDefaultTypeInternal;
extern LoginUserRequestDefaultTypeInternal _LoginUserRequest_default_instance_;
class LoginUserResponse;
struct LoginUserResponseDefaultTypeInternal;
extern LoginUserResponseDefaultTypeInternal _LoginUserResponse_default_instance_;
class LogoutRequest;
struct LogoutRequestDefaultTypeInternal;
extern LogoutRequestDefaultTypeInternal _LogoutRequest_default_instance_;
class LogoutResponse;
struct LogoutResponseDefaultTypeInternal;
extern LogoutResponseDefaultTypeInternal _LogoutResponse_default_instance_;
class RefreshTokenRequest;
struct RefreshTokenRequestDefaultTypeInternal;
extern RefreshTokenRequestDefaultTypeInternal _RefreshTokenRequest_default_instance_;
class RefreshTokenResponse;
struct RefreshTokenResponseDefaultTypeInternal;
extern RefreshTokenResponseDefaultTypeInternal _RefreshTokenResponse_default_instance_;
class RegisterUserRequest;
struct RegisterUserRequestDefaultTypeInternal;
extern RegisterUserRequestDefaultTypeInternal _RegisterUserRequest_default_instance_;
class RegisterUserResponse;
struct RegisterUserResponseDefaultTypeInternal;
extern RegisterUserResponseDefaultTypeInternal _RegisterUserResponse_default_instance_;
class ResendVerificationRequest;
struct ResendVerificationRequestDefaultTypeInternal;
extern ResendVerificationRequestDefaultTypeInternal _ResendVerificationRequest_default_instance_;
class ResendVerificationResponse;
struct ResendVerificationResponseDefaultTypeInternal;
extern ResendVerificationResponseDefaultTypeInternal _ResendVerificationResponse_default_instance_;
class ResetPasswordRequest;
struct ResetPasswordRequestDefaultTypeInternal;
extern ResetPasswordRequestDefaultTypeInternal _ResetPasswordRequest_default_instance_;
class ResetPasswordResponse;
struct ResetPasswordResponseDefaultTypeInternal;
extern ResetPasswordResponseDefaultTypeInternal _ResetPasswordResponse_default_instance_;
class Session;
struct SessionDefaultTypeInternal;
extern SessionDefaultTypeInternal _Session_default_instance_;
class SetupTwoFactorRequest;
struct SetupTwoFactorRequestDefaultTypeInternal;
extern SetupTwoFactorRequestDefaultTypeInternal _SetupTwoFactorRequest_default_instance_;
class SetupTwoFactorResponse;
struct SetupTwoFactorResponseDefaultTypeInternal;
extern SetupTwoFactorResponseDefaultTypeInternal _SetupTwoFactorResponse_default_instance_;
class TerminateSessionRequest;
struct TerminateSessionRequestDefaultTypeInternal;
extern TerminateSessionRequestDefaultTypeInternal _TerminateSessionRequest_default_instance_;
class TerminateSessionResponse;
struct TerminateSessionResponseDefaultTypeInternal;
extern TerminateSessionResponseDefaultTypeInternal _TerminateSessionResponse_default_instance_;
class TwoFactorAuth;
struct TwoFactorAuthDefaultTypeInternal;
extern TwoFactorAuthDefaultTypeInternal _TwoFactorAuth_default_instance_;
class UpdateUserProfileRequest;
struct UpdateUserProfileRequestDefaultTypeInternal;
extern UpdateUserProfileRequestDefaultTypeInternal _UpdateUserProfileRequest_default_instance_;
class UpdateUserProfileRequest_SettingsEntry_DoNotUse;
struct UpdateUserProfileRequest_SettingsEntry_DoNotUseDefaultTypeInternal;
extern UpdateUserProfileRequest_SettingsEntry_DoNotUseDefaultTypeInternal _UpdateUserProfileRequest_SettingsEntry_DoNotUse_default_instance_;
class UpdateUserProfileResponse;
struct UpdateUserProfileResponseDefaultTypeInternal;
extern UpdateUserProfileResponseDefaultTypeInternal _UpdateUserProfileResponse_default_instance_;
class UserProfile;
struct UserProfileDefaultTypeInternal;
extern UserProfileDefaultTypeInternal _UserProfile_default_instance_;
class UserProfile_PrivacySettingsEntry_DoNotUse;
struct UserProfile_PrivacySettingsEntry_DoNotUseDefaultTypeInternal;
extern UserProfile_PrivacySettingsEntry_DoNotUseDefaultTypeInternal _UserProfile_PrivacySettingsEntry_DoNotUse_default_instance_;
class UserProfile_SettingsEntry_DoNotUse;
struct UserProfile_SettingsEntry_DoNotUseDefaultTypeInternal;
extern UserProfile_SettingsEntry_DoNotUseDefaultTypeInternal _UserProfile_SettingsEntry_DoNotUse_default_instance_;
class VerifyEmailRequest;
struct VerifyEmailRequestDefaultTypeInternal;
extern VerifyEmailRequestDefaultTypeInternal _VerifyEmailRequest_default_instance_;
class VerifyEmailResponse;
struct VerifyEmailResponseDefaultTypeInternal;
extern VerifyEmailResponseDefaultTypeInternal _VerifyEmailResponse_default_instance_;
class VerifyTokenRequest;
struct VerifyTokenRequestDefaultTypeInternal;
extern VerifyTokenRequestDefaultTypeInternal _VerifyTokenRequest_default_instance_;
class VerifyTokenResponse;
struct VerifyTokenResponseDefaultTypeInternal;
extern VerifyTokenResponseDefaultTypeInternal _VerifyTokenResponse_default_instance_;
class VerifyTwoFactorRequest;
struct VerifyTwoFactorRequestDefaultTypeInternal;
extern VerifyTwoFactorRequestDefaultTypeInternal _VerifyTwoFactorRequest_default_instance_;
class VerifyTwoFactorResponse;
struct VerifyTwoFactorResponseDefaultTypeInternal;
extern VerifyTwoFactorResponseDefaultTypeInternal _VerifyTwoFactorResponse_default_instance_;
}  // namespace user
}  // namespace sonet
PROTOBUF_NAMESPACE_OPEN
template<> ::sonet::user::AuthCredentials* Arena::CreateMaybeMessage<::sonet::user::AuthCredentials>(Arena*);
template<> ::sonet::user::ChangePasswordRequest* Arena::CreateMaybeMessage<::sonet::user::ChangePasswordRequest>(Arena*);
template<> ::sonet::user::ChangePasswordResponse* Arena::CreateMaybeMessage<::sonet::user::ChangePasswordResponse>(Arena*);
template<> ::sonet::user::ConfirmPasswordResetRequest* Arena::CreateMaybeMessage<::sonet::user::ConfirmPasswordResetRequest>(Arena*);
template<> ::sonet::user::ConfirmPasswordResetResponse* Arena::CreateMaybeMessage<::sonet::user::ConfirmPasswordResetResponse>(Arena*);
template<> ::sonet::user::DisableTwoFactorRequest* Arena::CreateMaybeMessage<::sonet::user::DisableTwoFactorRequest>(Arena*);
template<> ::sonet::user::DisableTwoFactorResponse* Arena::CreateMaybeMessage<::sonet::user::DisableTwoFactorResponse>(Arena*);
template<> ::sonet::user::GetActiveSessionsRequest* Arena::CreateMaybeMessage<::sonet::user::GetActiveSessionsRequest>(Arena*);
template<> ::sonet::user::GetActiveSessionsResponse* Arena::CreateMaybeMessage<::sonet::user::GetActiveSessionsResponse>(Arena*);
template<> ::sonet::user::GetUserProfileRequest* Arena::CreateMaybeMessage<::sonet::user::GetUserProfileRequest>(Arena*);
template<> ::sonet::user::GetUserProfileResponse* Arena::CreateMaybeMessage<::sonet::user::GetUserProfileResponse>(Arena*);
template<> ::sonet::user::LoginUserRequest* Arena::CreateMaybeMessage<::sonet::user::LoginUserRequest>(Arena*);
template<> ::sonet::user::LoginUserResponse* Arena::CreateMaybeMessage<::sonet::user::LoginUserResponse>(Arena*);
template<> ::sonet::user::LogoutRequest* Arena::CreateMaybeMessage<::sonet::user::LogoutRequest>(Arena*);
template<> ::sonet::user::LogoutResponse* Arena::CreateMaybeMessage<::sonet::user::LogoutResponse>(Arena*);
template<> ::sonet::user::RefreshTokenRequest* Arena::CreateMaybeMessage<::sonet::user::RefreshTokenRequest>(Arena*);
template<> ::sonet::user::RefreshTokenResponse* Arena::CreateMaybeMessage<::sonet::user::RefreshTokenResponse>(Arena*);
template<> ::sonet::user::RegisterUserRequest* Arena::CreateMaybeMessage<::sonet::user::RegisterUserRequest>(Arena*);
template<> ::sonet::user::RegisterUserResponse* Arena::CreateMaybeMessage<::sonet::user::RegisterUserResponse>(Arena*);
template<> ::sonet::user::ResendVerificationRequest* Arena::CreateMaybeMessage<::sonet::user::ResendVerificationRequest>(Arena*);
template<> ::sonet::user::ResendVerificationResponse* Arena::CreateMaybeMessage<::sonet::user::ResendVerificationResponse>(Arena*);
template<> ::sonet::user::ResetPasswordRequest* Arena::CreateMaybeMessage<::sonet::user::ResetPasswordRequest>(Arena*);
template<> ::sonet::user::ResetPasswordResponse* Arena::CreateMaybeMessage<::sonet::user::ResetPasswordResponse>(Arena*);
template<> ::sonet::user::Session* Arena::CreateMaybeMessage<::sonet::user::Session>(Arena*);
template<> ::sonet::user::SetupTwoFactorRequest* Arena::CreateMaybeMessage<::sonet::user::SetupTwoFactorRequest>(Arena*);
template<> ::sonet::user::SetupTwoFactorResponse* Arena::CreateMaybeMessage<::sonet::user::SetupTwoFactorResponse>(Arena*);
template<> ::sonet::user::TerminateSessionRequest* Arena::CreateMaybeMessage<::sonet::user::TerminateSessionRequest>(Arena*);
template<> ::sonet::user::TerminateSessionResponse* Arena::CreateMaybeMessage<::sonet::user::TerminateSessionResponse>(Arena*);
template<> ::sonet::user::TwoFactorAuth* Arena::CreateMaybeMessage<::sonet::user::TwoFactorAuth>(Arena*);
template<> ::sonet::user::UpdateUserProfileRequest* Arena::CreateMaybeMessage<::sonet::user::UpdateUserProfileRequest>(Arena*);
template<> ::sonet::user::UpdateUserProfileRequest_SettingsEntry_DoNotUse* Arena::CreateMaybeMessage<::sonet::user::UpdateUserProfileRequest_SettingsEntry_DoNotUse>(Arena*);
template<> ::sonet::user::UpdateUserProfileResponse* Arena::CreateMaybeMessage<::sonet::user::UpdateUserProfileResponse>(Arena*);
template<> ::sonet::user::UserProfile* Arena::CreateMaybeMessage<::sonet::user::UserProfile>(Arena*);
template<> ::sonet::user::UserProfile_PrivacySettingsEntry_DoNotUse* Arena::CreateMaybeMessage<::sonet::user::UserProfile_PrivacySettingsEntry_DoNotUse>(Arena*);
template<> ::sonet::user::UserProfile_SettingsEntry_DoNotUse* Arena::CreateMaybeMessage<::sonet::user::UserProfile_SettingsEntry_DoNotUse>(Arena*);
template<> ::sonet::user::VerifyEmailRequest* Arena::CreateMaybeMessage<::sonet::user::VerifyEmailRequest>(Arena*);
template<> ::sonet::user::VerifyEmailResponse* Arena::CreateMaybeMessage<::sonet::user::VerifyEmailResponse>(Arena*);
template<> ::sonet::user::VerifyTokenRequest* Arena::CreateMaybeMessage<::sonet::user::VerifyTokenRequest>(Arena*);
template<> ::sonet::user::VerifyTokenResponse* Arena::CreateMaybeMessage<::sonet::user::VerifyTokenResponse>(Arena*);
template<> ::sonet::user::VerifyTwoFactorRequest* Arena::CreateMaybeMessage<::sonet::user::VerifyTwoFactorRequest>(Arena*);
template<> ::sonet::user::VerifyTwoFactorResponse* Arena::CreateMaybeMessage<::sonet::user::VerifyTwoFactorResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sonet {
namespace user {

enum UserStatus : int {
  USER_STATUS_UNSPECIFIED = 0,
  USER_STATUS_ACTIVE = 1,
  USER_STATUS_SUSPENDED = 2,
  USER_STATUS_PENDING_VERIFICATION = 3,
  USER_STATUS_DEACTIVATED = 4,
  USER_STATUS_BANNED = 5,
  UserStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UserStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UserStatus_IsValid(int value);
constexpr UserStatus UserStatus_MIN = USER_STATUS_UNSPECIFIED;
constexpr UserStatus UserStatus_MAX = USER_STATUS_BANNED;
constexpr int UserStatus_ARRAYSIZE = UserStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UserStatus_descriptor();
template<typename T>
inline const std::string& UserStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UserStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UserStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UserStatus_descriptor(), enum_t_value);
}
inline bool UserStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UserStatus>(
    UserStatus_descriptor(), name, value);
}
enum SessionType : int {
  SESSION_TYPE_UNSPECIFIED = 0,
  SESSION_TYPE_WEB = 1,
  SESSION_TYPE_MOBILE = 2,
  SESSION_TYPE_API = 3,
  SESSION_TYPE_ADMIN = 4,
  SessionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SessionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SessionType_IsValid(int value);
constexpr SessionType SessionType_MIN = SESSION_TYPE_UNSPECIFIED;
constexpr SessionType SessionType_MAX = SESSION_TYPE_ADMIN;
constexpr int SessionType_ARRAYSIZE = SessionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SessionType_descriptor();
template<typename T>
inline const std::string& SessionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SessionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SessionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SessionType_descriptor(), enum_t_value);
}
inline bool SessionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SessionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SessionType>(
    SessionType_descriptor(), name, value);
}
// ===================================================================

class UserProfile_SettingsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<UserProfile_SettingsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<UserProfile_SettingsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  UserProfile_SettingsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR UserProfile_SettingsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit UserProfile_SettingsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const UserProfile_SettingsEntry_DoNotUse& other);
  static const UserProfile_SettingsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const UserProfile_SettingsEntry_DoNotUse*>(&_UserProfile_SettingsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "sonet.user.UserProfile.SettingsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "sonet.user.UserProfile.SettingsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_services_2fuser_2eproto;
};

// -------------------------------------------------------------------

class UserProfile_PrivacySettingsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<UserProfile_PrivacySettingsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<UserProfile_PrivacySettingsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  UserProfile_PrivacySettingsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR UserProfile_PrivacySettingsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit UserProfile_PrivacySettingsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const UserProfile_PrivacySettingsEntry_DoNotUse& other);
  static const UserProfile_PrivacySettingsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const UserProfile_PrivacySettingsEntry_DoNotUse*>(&_UserProfile_PrivacySettingsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "sonet.user.UserProfile.PrivacySettingsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "sonet.user.UserProfile.PrivacySettingsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_services_2fuser_2eproto;
};

// -------------------------------------------------------------------

class UserProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.user.UserProfile) */ {
 public:
  inline UserProfile() : UserProfile(nullptr) {}
  ~UserProfile() override;
  explicit PROTOBUF_CONSTEXPR UserProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserProfile(const UserProfile& from);
  UserProfile(UserProfile&& from) noexcept
    : UserProfile() {
    *this = ::std::move(from);
  }

  inline UserProfile& operator=(const UserProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserProfile& operator=(UserProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserProfile* internal_default_instance() {
    return reinterpret_cast<const UserProfile*>(
               &_UserProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UserProfile& a, UserProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(UserProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserProfile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserProfile& from) {
    UserProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.user.UserProfile";
  }
  protected:
  explicit UserProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSettingsFieldNumber = 18,
    kPrivacySettingsFieldNumber = 19,
    kUserIdFieldNumber = 1,
    kUsernameFieldNumber = 2,
    kEmailFieldNumber = 3,
    kDisplayNameFieldNumber = 4,
    kBioFieldNumber = 5,
    kAvatarUrlFieldNumber = 6,
    kLocationFieldNumber = 7,
    kWebsiteFieldNumber = 8,
    kCreatedAtFieldNumber = 12,
    kUpdatedAtFieldNumber = 13,
    kLastLoginFieldNumber = 14,
    kStatusFieldNumber = 9,
    kIsVerifiedFieldNumber = 10,
    kIsPrivateFieldNumber = 11,
    kFollowerCountFieldNumber = 15,
    kFollowingCountFieldNumber = 16,
    kNoteCountFieldNumber = 17,
  };
  // map<string, string> settings = 18;
  int settings_size() const;
  private:
  int _internal_settings_size() const;
  public:
  void clear_settings();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_settings() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_settings();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      settings() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_settings();

  // map<string, string> privacy_settings = 19;
  int privacy_settings_size() const;
  private:
  int _internal_privacy_settings_size() const;
  public:
  void clear_privacy_settings();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_privacy_settings() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_privacy_settings();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      privacy_settings() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_privacy_settings();

  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string username = 2;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string email = 3;
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // string display_name = 4;
  void clear_display_name();
  const std::string& display_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_display_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_display_name();
  PROTOBUF_NODISCARD std::string* release_display_name();
  void set_allocated_display_name(std::string* display_name);
  private:
  const std::string& _internal_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(const std::string& value);
  std::string* _internal_mutable_display_name();
  public:

  // string bio = 5;
  void clear_bio();
  const std::string& bio() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bio(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bio();
  PROTOBUF_NODISCARD std::string* release_bio();
  void set_allocated_bio(std::string* bio);
  private:
  const std::string& _internal_bio() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bio(const std::string& value);
  std::string* _internal_mutable_bio();
  public:

  // string avatar_url = 6;
  void clear_avatar_url();
  const std::string& avatar_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_avatar_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_avatar_url();
  PROTOBUF_NODISCARD std::string* release_avatar_url();
  void set_allocated_avatar_url(std::string* avatar_url);
  private:
  const std::string& _internal_avatar_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_avatar_url(const std::string& value);
  std::string* _internal_mutable_avatar_url();
  public:

  // string location = 7;
  void clear_location();
  const std::string& location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // string website = 8;
  void clear_website();
  const std::string& website() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_website(ArgT0&& arg0, ArgT... args);
  std::string* mutable_website();
  PROTOBUF_NODISCARD std::string* release_website();
  void set_allocated_website(std::string* website);
  private:
  const std::string& _internal_website() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_website(const std::string& value);
  std::string* _internal_mutable_website();
  public:

  // .sonet.common.Timestamp created_at = 12;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::sonet::common::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::sonet::common::Timestamp* release_created_at();
  ::sonet::common::Timestamp* mutable_created_at();
  void set_allocated_created_at(::sonet::common::Timestamp* created_at);
  private:
  const ::sonet::common::Timestamp& _internal_created_at() const;
  ::sonet::common::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::sonet::common::Timestamp* created_at);
  ::sonet::common::Timestamp* unsafe_arena_release_created_at();

  // .sonet.common.Timestamp updated_at = 13;
  bool has_updated_at() const;
  private:
  bool _internal_has_updated_at() const;
  public:
  void clear_updated_at();
  const ::sonet::common::Timestamp& updated_at() const;
  PROTOBUF_NODISCARD ::sonet::common::Timestamp* release_updated_at();
  ::sonet::common::Timestamp* mutable_updated_at();
  void set_allocated_updated_at(::sonet::common::Timestamp* updated_at);
  private:
  const ::sonet::common::Timestamp& _internal_updated_at() const;
  ::sonet::common::Timestamp* _internal_mutable_updated_at();
  public:
  void unsafe_arena_set_allocated_updated_at(
      ::sonet::common::Timestamp* updated_at);
  ::sonet::common::Timestamp* unsafe_arena_release_updated_at();

  // .sonet.common.Timestamp last_login = 14;
  bool has_last_login() const;
  private:
  bool _internal_has_last_login() const;
  public:
  void clear_last_login();
  const ::sonet::common::Timestamp& last_login() const;
  PROTOBUF_NODISCARD ::sonet::common::Timestamp* release_last_login();
  ::sonet::common::Timestamp* mutable_last_login();
  void set_allocated_last_login(::sonet::common::Timestamp* last_login);
  private:
  const ::sonet::common::Timestamp& _internal_last_login() const;
  ::sonet::common::Timestamp* _internal_mutable_last_login();
  public:
  void unsafe_arena_set_allocated_last_login(
      ::sonet::common::Timestamp* last_login);
  ::sonet::common::Timestamp* unsafe_arena_release_last_login();

  // .sonet.user.UserStatus status = 9;
  void clear_status();
  ::sonet::user::UserStatus status() const;
  void set_status(::sonet::user::UserStatus value);
  private:
  ::sonet::user::UserStatus _internal_status() const;
  void _internal_set_status(::sonet::user::UserStatus value);
  public:

  // bool is_verified = 10;
  void clear_is_verified();
  bool is_verified() const;
  void set_is_verified(bool value);
  private:
  bool _internal_is_verified() const;
  void _internal_set_is_verified(bool value);
  public:

  // bool is_private = 11;
  void clear_is_private();
  bool is_private() const;
  void set_is_private(bool value);
  private:
  bool _internal_is_private() const;
  void _internal_set_is_private(bool value);
  public:

  // uint64 follower_count = 15;
  void clear_follower_count();
  uint64_t follower_count() const;
  void set_follower_count(uint64_t value);
  private:
  uint64_t _internal_follower_count() const;
  void _internal_set_follower_count(uint64_t value);
  public:

  // uint64 following_count = 16;
  void clear_following_count();
  uint64_t following_count() const;
  void set_following_count(uint64_t value);
  private:
  uint64_t _internal_following_count() const;
  void _internal_set_following_count(uint64_t value);
  public:

  // uint64 note_count = 17;
  void clear_note_count();
  uint64_t note_count() const;
  void set_note_count(uint64_t value);
  private:
  uint64_t _internal_note_count() const;
  void _internal_set_note_count(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.user.UserProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        UserProfile_SettingsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> settings_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        UserProfile_PrivacySettingsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> privacy_settings_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr display_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bio_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr avatar_url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr website_;
    ::sonet::common::Timestamp* created_at_;
    ::sonet::common::Timestamp* updated_at_;
    ::sonet::common::Timestamp* last_login_;
    int status_;
    bool is_verified_;
    bool is_private_;
    uint64_t follower_count_;
    uint64_t following_count_;
    uint64_t note_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fuser_2eproto;
};
// -------------------------------------------------------------------

class AuthCredentials final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.user.AuthCredentials) */ {
 public:
  inline AuthCredentials() : AuthCredentials(nullptr) {}
  ~AuthCredentials() override;
  explicit PROTOBUF_CONSTEXPR AuthCredentials(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthCredentials(const AuthCredentials& from);
  AuthCredentials(AuthCredentials&& from) noexcept
    : AuthCredentials() {
    *this = ::std::move(from);
  }

  inline AuthCredentials& operator=(const AuthCredentials& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthCredentials& operator=(AuthCredentials&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthCredentials& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthCredentials* internal_default_instance() {
    return reinterpret_cast<const AuthCredentials*>(
               &_AuthCredentials_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AuthCredentials& a, AuthCredentials& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthCredentials* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthCredentials* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthCredentials* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthCredentials>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthCredentials& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthCredentials& from) {
    AuthCredentials::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthCredentials* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.user.AuthCredentials";
  }
  protected:
  explicit AuthCredentials(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmailFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kTwoFactorCodeFieldNumber = 3,
  };
  // string email = 1;
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // string two_factor_code = 3;
  void clear_two_factor_code();
  const std::string& two_factor_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_two_factor_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_two_factor_code();
  PROTOBUF_NODISCARD std::string* release_two_factor_code();
  void set_allocated_two_factor_code(std::string* two_factor_code);
  private:
  const std::string& _internal_two_factor_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_two_factor_code(const std::string& value);
  std::string* _internal_mutable_two_factor_code();
  public:

  // @@protoc_insertion_point(class_scope:sonet.user.AuthCredentials)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr two_factor_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fuser_2eproto;
};
// -------------------------------------------------------------------

class Session final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.user.Session) */ {
 public:
  inline Session() : Session(nullptr) {}
  ~Session() override;
  explicit PROTOBUF_CONSTEXPR Session(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Session(const Session& from);
  Session(Session&& from) noexcept
    : Session() {
    *this = ::std::move(from);
  }

  inline Session& operator=(const Session& from) {
    CopyFrom(from);
    return *this;
  }
  inline Session& operator=(Session&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Session& default_instance() {
    return *internal_default_instance();
  }
  static inline const Session* internal_default_instance() {
    return reinterpret_cast<const Session*>(
               &_Session_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Session& a, Session& b) {
    a.Swap(&b);
  }
  inline void Swap(Session* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Session* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Session* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Session>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Session& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Session& from) {
    Session::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Session* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.user.Session";
  }
  protected:
  explicit Session(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kUserIdFieldNumber = 2,
    kDeviceIdFieldNumber = 3,
    kDeviceNameFieldNumber = 4,
    kIpAddressFieldNumber = 5,
    kUserAgentFieldNumber = 6,
    kLocationInfoFieldNumber = 13,
    kCreatedAtFieldNumber = 8,
    kLastActivityFieldNumber = 9,
    kExpiresAtFieldNumber = 10,
    kTypeFieldNumber = 7,
    kIsActiveFieldNumber = 11,
    kIsSuspiciousFieldNumber = 12,
  };
  // string session_id = 1;
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // string user_id = 2;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string device_id = 3;
  void clear_device_id();
  const std::string& device_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_id();
  PROTOBUF_NODISCARD std::string* release_device_id();
  void set_allocated_device_id(std::string* device_id);
  private:
  const std::string& _internal_device_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_id(const std::string& value);
  std::string* _internal_mutable_device_id();
  public:

  // string device_name = 4;
  void clear_device_name();
  const std::string& device_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_name();
  PROTOBUF_NODISCARD std::string* release_device_name();
  void set_allocated_device_name(std::string* device_name);
  private:
  const std::string& _internal_device_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_name(const std::string& value);
  std::string* _internal_mutable_device_name();
  public:

  // string ip_address = 5;
  void clear_ip_address();
  const std::string& ip_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip_address();
  PROTOBUF_NODISCARD std::string* release_ip_address();
  void set_allocated_ip_address(std::string* ip_address);
  private:
  const std::string& _internal_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_address(const std::string& value);
  std::string* _internal_mutable_ip_address();
  public:

  // string user_agent = 6;
  void clear_user_agent();
  const std::string& user_agent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_agent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_agent();
  PROTOBUF_NODISCARD std::string* release_user_agent();
  void set_allocated_user_agent(std::string* user_agent);
  private:
  const std::string& _internal_user_agent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_agent(const std::string& value);
  std::string* _internal_mutable_user_agent();
  public:

  // string location_info = 13;
  void clear_location_info();
  const std::string& location_info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_info();
  PROTOBUF_NODISCARD std::string* release_location_info();
  void set_allocated_location_info(std::string* location_info);
  private:
  const std::string& _internal_location_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_info(const std::string& value);
  std::string* _internal_mutable_location_info();
  public:

  // .sonet.common.Timestamp created_at = 8;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::sonet::common::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::sonet::common::Timestamp* release_created_at();
  ::sonet::common::Timestamp* mutable_created_at();
  void set_allocated_created_at(::sonet::common::Timestamp* created_at);
  private:
  const ::sonet::common::Timestamp& _internal_created_at() const;
  ::sonet::common::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::sonet::common::Timestamp* created_at);
  ::sonet::common::Timestamp* unsafe_arena_release_created_at();

  // .sonet.common.Timestamp last_activity = 9;
  bool has_last_activity() const;
  private:
  bool _internal_has_last_activity() const;
  public:
  void clear_last_activity();
  const ::sonet::common::Timestamp& last_activity() const;
  PROTOBUF_NODISCARD ::sonet::common::Timestamp* release_last_activity();
  ::sonet::common::Timestamp* mutable_last_activity();
  void set_allocated_last_activity(::sonet::common::Timestamp* last_activity);
  private:
  const ::sonet::common::Timestamp& _internal_last_activity() const;
  ::sonet::common::Timestamp* _internal_mutable_last_activity();
  public:
  void unsafe_arena_set_allocated_last_activity(
      ::sonet::common::Timestamp* last_activity);
  ::sonet::common::Timestamp* unsafe_arena_release_last_activity();

  // .sonet.common.Timestamp expires_at = 10;
  bool has_expires_at() const;
  private:
  bool _internal_has_expires_at() const;
  public:
  void clear_expires_at();
  const ::sonet::common::Timestamp& expires_at() const;
  PROTOBUF_NODISCARD ::sonet::common::Timestamp* release_expires_at();
  ::sonet::common::Timestamp* mutable_expires_at();
  void set_allocated_expires_at(::sonet::common::Timestamp* expires_at);
  private:
  const ::sonet::common::Timestamp& _internal_expires_at() const;
  ::sonet::common::Timestamp* _internal_mutable_expires_at();
  public:
  void unsafe_arena_set_allocated_expires_at(
      ::sonet::common::Timestamp* expires_at);
  ::sonet::common::Timestamp* unsafe_arena_release_expires_at();

  // .sonet.user.SessionType type = 7;
  void clear_type();
  ::sonet::user::SessionType type() const;
  void set_type(::sonet::user::SessionType value);
  private:
  ::sonet::user::SessionType _internal_type() const;
  void _internal_set_type(::sonet::user::SessionType value);
  public:

  // bool is_active = 11;
  void clear_is_active();
  bool is_active() const;
  void set_is_active(bool value);
  private:
  bool _internal_is_active() const;
  void _internal_set_is_active(bool value);
  public:

  // bool is_suspicious = 12;
  void clear_is_suspicious();
  bool is_suspicious() const;
  void set_is_suspicious(bool value);
  private:
  bool _internal_is_suspicious() const;
  void _internal_set_is_suspicious(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.user.Session)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_agent_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_info_;
    ::sonet::common::Timestamp* created_at_;
    ::sonet::common::Timestamp* last_activity_;
    ::sonet::common::Timestamp* expires_at_;
    int type_;
    bool is_active_;
    bool is_suspicious_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fuser_2eproto;
};
// -------------------------------------------------------------------

class TwoFactorAuth final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.user.TwoFactorAuth) */ {
 public:
  inline TwoFactorAuth() : TwoFactorAuth(nullptr) {}
  ~TwoFactorAuth() override;
  explicit PROTOBUF_CONSTEXPR TwoFactorAuth(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TwoFactorAuth(const TwoFactorAuth& from);
  TwoFactorAuth(TwoFactorAuth&& from) noexcept
    : TwoFactorAuth() {
    *this = ::std::move(from);
  }

  inline TwoFactorAuth& operator=(const TwoFactorAuth& from) {
    CopyFrom(from);
    return *this;
  }
  inline TwoFactorAuth& operator=(TwoFactorAuth&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TwoFactorAuth& default_instance() {
    return *internal_default_instance();
  }
  static inline const TwoFactorAuth* internal_default_instance() {
    return reinterpret_cast<const TwoFactorAuth*>(
               &_TwoFactorAuth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TwoFactorAuth& a, TwoFactorAuth& b) {
    a.Swap(&b);
  }
  inline void Swap(TwoFactorAuth* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TwoFactorAuth* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TwoFactorAuth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TwoFactorAuth>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TwoFactorAuth& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TwoFactorAuth& from) {
    TwoFactorAuth::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TwoFactorAuth* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.user.TwoFactorAuth";
  }
  protected:
  explicit TwoFactorAuth(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBackupCodesFieldNumber = 4,
    kUserIdFieldNumber = 1,
    kQrCodeUrlFieldNumber = 3,
    kSetupAtFieldNumber = 5,
    kIsEnabledFieldNumber = 2,
  };
  // repeated string backup_codes = 4;
  int backup_codes_size() const;
  private:
  int _internal_backup_codes_size() const;
  public:
  void clear_backup_codes();
  const std::string& backup_codes(int index) const;
  std::string* mutable_backup_codes(int index);
  void set_backup_codes(int index, const std::string& value);
  void set_backup_codes(int index, std::string&& value);
  void set_backup_codes(int index, const char* value);
  void set_backup_codes(int index, const char* value, size_t size);
  std::string* add_backup_codes();
  void add_backup_codes(const std::string& value);
  void add_backup_codes(std::string&& value);
  void add_backup_codes(const char* value);
  void add_backup_codes(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& backup_codes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_backup_codes();
  private:
  const std::string& _internal_backup_codes(int index) const;
  std::string* _internal_add_backup_codes();
  public:

  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string qr_code_url = 3;
  void clear_qr_code_url();
  const std::string& qr_code_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_qr_code_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_qr_code_url();
  PROTOBUF_NODISCARD std::string* release_qr_code_url();
  void set_allocated_qr_code_url(std::string* qr_code_url);
  private:
  const std::string& _internal_qr_code_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_qr_code_url(const std::string& value);
  std::string* _internal_mutable_qr_code_url();
  public:

  // .sonet.common.Timestamp setup_at = 5;
  bool has_setup_at() const;
  private:
  bool _internal_has_setup_at() const;
  public:
  void clear_setup_at();
  const ::sonet::common::Timestamp& setup_at() const;
  PROTOBUF_NODISCARD ::sonet::common::Timestamp* release_setup_at();
  ::sonet::common::Timestamp* mutable_setup_at();
  void set_allocated_setup_at(::sonet::common::Timestamp* setup_at);
  private:
  const ::sonet::common::Timestamp& _internal_setup_at() const;
  ::sonet::common::Timestamp* _internal_mutable_setup_at();
  public:
  void unsafe_arena_set_allocated_setup_at(
      ::sonet::common::Timestamp* setup_at);
  ::sonet::common::Timestamp* unsafe_arena_release_setup_at();

  // bool is_enabled = 2;
  void clear_is_enabled();
  bool is_enabled() const;
  void set_is_enabled(bool value);
  private:
  bool _internal_is_enabled() const;
  void _internal_set_is_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.user.TwoFactorAuth)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> backup_codes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr qr_code_url_;
    ::sonet::common::Timestamp* setup_at_;
    bool is_enabled_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fuser_2eproto;
};
// -------------------------------------------------------------------

class RegisterUserRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.user.RegisterUserRequest) */ {
 public:
  inline RegisterUserRequest() : RegisterUserRequest(nullptr) {}
  ~RegisterUserRequest() override;
  explicit PROTOBUF_CONSTEXPR RegisterUserRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterUserRequest(const RegisterUserRequest& from);
  RegisterUserRequest(RegisterUserRequest&& from) noexcept
    : RegisterUserRequest() {
    *this = ::std::move(from);
  }

  inline RegisterUserRequest& operator=(const RegisterUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterUserRequest& operator=(RegisterUserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterUserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterUserRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterUserRequest*>(
               &_RegisterUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RegisterUserRequest& a, RegisterUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterUserRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterUserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterUserRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterUserRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterUserRequest& from) {
    RegisterUserRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterUserRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.user.RegisterUserRequest";
  }
  protected:
  explicit RegisterUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kEmailFieldNumber = 2,
    kPasswordFieldNumber = 3,
    kDisplayNameFieldNumber = 4,
    kInvitationCodeFieldNumber = 5,
    kAcceptTermsFieldNumber = 6,
    kAcceptPrivacyFieldNumber = 7,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string email = 2;
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // string password = 3;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // string display_name = 4;
  void clear_display_name();
  const std::string& display_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_display_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_display_name();
  PROTOBUF_NODISCARD std::string* release_display_name();
  void set_allocated_display_name(std::string* display_name);
  private:
  const std::string& _internal_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(const std::string& value);
  std::string* _internal_mutable_display_name();
  public:

  // string invitation_code = 5;
  void clear_invitation_code();
  const std::string& invitation_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_invitation_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_invitation_code();
  PROTOBUF_NODISCARD std::string* release_invitation_code();
  void set_allocated_invitation_code(std::string* invitation_code);
  private:
  const std::string& _internal_invitation_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_invitation_code(const std::string& value);
  std::string* _internal_mutable_invitation_code();
  public:

  // bool accept_terms = 6;
  void clear_accept_terms();
  bool accept_terms() const;
  void set_accept_terms(bool value);
  private:
  bool _internal_accept_terms() const;
  void _internal_set_accept_terms(bool value);
  public:

  // bool accept_privacy = 7;
  void clear_accept_privacy();
  bool accept_privacy() const;
  void set_accept_privacy(bool value);
  private:
  bool _internal_accept_privacy() const;
  void _internal_set_accept_privacy(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.user.RegisterUserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr display_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr invitation_code_;
    bool accept_terms_;
    bool accept_privacy_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fuser_2eproto;
};
// -------------------------------------------------------------------

class RegisterUserResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.user.RegisterUserResponse) */ {
 public:
  inline RegisterUserResponse() : RegisterUserResponse(nullptr) {}
  ~RegisterUserResponse() override;
  explicit PROTOBUF_CONSTEXPR RegisterUserResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterUserResponse(const RegisterUserResponse& from);
  RegisterUserResponse(RegisterUserResponse&& from) noexcept
    : RegisterUserResponse() {
    *this = ::std::move(from);
  }

  inline RegisterUserResponse& operator=(const RegisterUserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterUserResponse& operator=(RegisterUserResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterUserResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterUserResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterUserResponse*>(
               &_RegisterUserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RegisterUserResponse& a, RegisterUserResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterUserResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterUserResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterUserResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterUserResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterUserResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterUserResponse& from) {
    RegisterUserResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterUserResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.user.RegisterUserResponse";
  }
  protected:
  explicit RegisterUserResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVerificationTokenFieldNumber = 3,
    kStatusFieldNumber = 1,
    kUserFieldNumber = 2,
  };
  // string verification_token = 3;
  void clear_verification_token();
  const std::string& verification_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_verification_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_verification_token();
  PROTOBUF_NODISCARD std::string* release_verification_token();
  void set_allocated_verification_token(std::string* verification_token);
  private:
  const std::string& _internal_verification_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verification_token(const std::string& value);
  std::string* _internal_mutable_verification_token();
  public:

  // .sonet.common.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::sonet::common::Status& status() const;
  PROTOBUF_NODISCARD ::sonet::common::Status* release_status();
  ::sonet::common::Status* mutable_status();
  void set_allocated_status(::sonet::common::Status* status);
  private:
  const ::sonet::common::Status& _internal_status() const;
  ::sonet::common::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::sonet::common::Status* status);
  ::sonet::common::Status* unsafe_arena_release_status();

  // .sonet.user.UserProfile user = 2;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::sonet::user::UserProfile& user() const;
  PROTOBUF_NODISCARD ::sonet::user::UserProfile* release_user();
  ::sonet::user::UserProfile* mutable_user();
  void set_allocated_user(::sonet::user::UserProfile* user);
  private:
  const ::sonet::user::UserProfile& _internal_user() const;
  ::sonet::user::UserProfile* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::sonet::user::UserProfile* user);
  ::sonet::user::UserProfile* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:sonet.user.RegisterUserResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr verification_token_;
    ::sonet::common::Status* status_;
    ::sonet::user::UserProfile* user_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fuser_2eproto;
};
// -------------------------------------------------------------------

class LoginUserRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.user.LoginUserRequest) */ {
 public:
  inline LoginUserRequest() : LoginUserRequest(nullptr) {}
  ~LoginUserRequest() override;
  explicit PROTOBUF_CONSTEXPR LoginUserRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginUserRequest(const LoginUserRequest& from);
  LoginUserRequest(LoginUserRequest&& from) noexcept
    : LoginUserRequest() {
    *this = ::std::move(from);
  }

  inline LoginUserRequest& operator=(const LoginUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginUserRequest& operator=(LoginUserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginUserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginUserRequest* internal_default_instance() {
    return reinterpret_cast<const LoginUserRequest*>(
               &_LoginUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LoginUserRequest& a, LoginUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginUserRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginUserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginUserRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginUserRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginUserRequest& from) {
    LoginUserRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginUserRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.user.LoginUserRequest";
  }
  protected:
  explicit LoginUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceNameFieldNumber = 2,
    kCredentialsFieldNumber = 1,
  };
  // string device_name = 2;
  void clear_device_name();
  const std::string& device_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_name();
  PROTOBUF_NODISCARD std::string* release_device_name();
  void set_allocated_device_name(std::string* device_name);
  private:
  const std::string& _internal_device_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_name(const std::string& value);
  std::string* _internal_mutable_device_name();
  public:

  // .sonet.user.AuthCredentials credentials = 1;
  bool has_credentials() const;
  private:
  bool _internal_has_credentials() const;
  public:
  void clear_credentials();
  const ::sonet::user::AuthCredentials& credentials() const;
  PROTOBUF_NODISCARD ::sonet::user::AuthCredentials* release_credentials();
  ::sonet::user::AuthCredentials* mutable_credentials();
  void set_allocated_credentials(::sonet::user::AuthCredentials* credentials);
  private:
  const ::sonet::user::AuthCredentials& _internal_credentials() const;
  ::sonet::user::AuthCredentials* _internal_mutable_credentials();
  public:
  void unsafe_arena_set_allocated_credentials(
      ::sonet::user::AuthCredentials* credentials);
  ::sonet::user::AuthCredentials* unsafe_arena_release_credentials();

  // @@protoc_insertion_point(class_scope:sonet.user.LoginUserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_name_;
    ::sonet::user::AuthCredentials* credentials_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fuser_2eproto;
};
// -------------------------------------------------------------------

class LoginUserResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.user.LoginUserResponse) */ {
 public:
  inline LoginUserResponse() : LoginUserResponse(nullptr) {}
  ~LoginUserResponse() override;
  explicit PROTOBUF_CONSTEXPR LoginUserResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginUserResponse(const LoginUserResponse& from);
  LoginUserResponse(LoginUserResponse&& from) noexcept
    : LoginUserResponse() {
    *this = ::std::move(from);
  }

  inline LoginUserResponse& operator=(const LoginUserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginUserResponse& operator=(LoginUserResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginUserResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginUserResponse* internal_default_instance() {
    return reinterpret_cast<const LoginUserResponse*>(
               &_LoginUserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(LoginUserResponse& a, LoginUserResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginUserResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginUserResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginUserResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginUserResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginUserResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginUserResponse& from) {
    LoginUserResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginUserResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.user.LoginUserResponse";
  }
  protected:
  explicit LoginUserResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccessTokenFieldNumber = 2,
    kRefreshTokenFieldNumber = 3,
    kStatusFieldNumber = 1,
    kSessionFieldNumber = 5,
    kExpiresInFieldNumber = 4,
    kRequires2FaFieldNumber = 6,
  };
  // string access_token = 2;
  void clear_access_token();
  const std::string& access_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_access_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_access_token();
  PROTOBUF_NODISCARD std::string* release_access_token();
  void set_allocated_access_token(std::string* access_token);
  private:
  const std::string& _internal_access_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_access_token(const std::string& value);
  std::string* _internal_mutable_access_token();
  public:

  // string refresh_token = 3;
  void clear_refresh_token();
  const std::string& refresh_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_refresh_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_refresh_token();
  PROTOBUF_NODISCARD std::string* release_refresh_token();
  void set_allocated_refresh_token(std::string* refresh_token);
  private:
  const std::string& _internal_refresh_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_refresh_token(const std::string& value);
  std::string* _internal_mutable_refresh_token();
  public:

  // .sonet.common.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::sonet::common::Status& status() const;
  PROTOBUF_NODISCARD ::sonet::common::Status* release_status();
  ::sonet::common::Status* mutable_status();
  void set_allocated_status(::sonet::common::Status* status);
  private:
  const ::sonet::common::Status& _internal_status() const;
  ::sonet::common::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::sonet::common::Status* status);
  ::sonet::common::Status* unsafe_arena_release_status();

  // .sonet.user.Session session = 5;
  bool has_session() const;
  private:
  bool _internal_has_session() const;
  public:
  void clear_session();
  const ::sonet::user::Session& session() const;
  PROTOBUF_NODISCARD ::sonet::user::Session* release_session();
  ::sonet::user::Session* mutable_session();
  void set_allocated_session(::sonet::user::Session* session);
  private:
  const ::sonet::user::Session& _internal_session() const;
  ::sonet::user::Session* _internal_mutable_session();
  public:
  void unsafe_arena_set_allocated_session(
      ::sonet::user::Session* session);
  ::sonet::user::Session* unsafe_arena_release_session();

  // int32 expires_in = 4;
  void clear_expires_in();
  int32_t expires_in() const;
  void set_expires_in(int32_t value);
  private:
  int32_t _internal_expires_in() const;
  void _internal_set_expires_in(int32_t value);
  public:

  // bool requires_2fa = 6;
  void clear_requires_2fa();
  bool requires_2fa() const;
  void set_requires_2fa(bool value);
  private:
  bool _internal_requires_2fa() const;
  void _internal_set_requires_2fa(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.user.LoginUserResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr access_token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr refresh_token_;
    ::sonet::common::Status* status_;
    ::sonet::user::Session* session_;
    int32_t expires_in_;
    bool requires_2fa_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fuser_2eproto;
};
// -------------------------------------------------------------------

class VerifyTokenRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.user.VerifyTokenRequest) */ {
 public:
  inline VerifyTokenRequest() : VerifyTokenRequest(nullptr) {}
  ~VerifyTokenRequest() override;
  explicit PROTOBUF_CONSTEXPR VerifyTokenRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VerifyTokenRequest(const VerifyTokenRequest& from);
  VerifyTokenRequest(VerifyTokenRequest&& from) noexcept
    : VerifyTokenRequest() {
    *this = ::std::move(from);
  }

  inline VerifyTokenRequest& operator=(const VerifyTokenRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerifyTokenRequest& operator=(VerifyTokenRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerifyTokenRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerifyTokenRequest* internal_default_instance() {
    return reinterpret_cast<const VerifyTokenRequest*>(
               &_VerifyTokenRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(VerifyTokenRequest& a, VerifyTokenRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VerifyTokenRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerifyTokenRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerifyTokenRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VerifyTokenRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VerifyTokenRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VerifyTokenRequest& from) {
    VerifyTokenRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerifyTokenRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.user.VerifyTokenRequest";
  }
  protected:
  explicit VerifyTokenRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
  };
  // string token = 1;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // @@protoc_insertion_point(class_scope:sonet.user.VerifyTokenRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fuser_2eproto;
};
// -------------------------------------------------------------------

class VerifyTokenResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.user.VerifyTokenResponse) */ {
 public:
  inline VerifyTokenResponse() : VerifyTokenResponse(nullptr) {}
  ~VerifyTokenResponse() override;
  explicit PROTOBUF_CONSTEXPR VerifyTokenResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VerifyTokenResponse(const VerifyTokenResponse& from);
  VerifyTokenResponse(VerifyTokenResponse&& from) noexcept
    : VerifyTokenResponse() {
    *this = ::std::move(from);
  }

  inline VerifyTokenResponse& operator=(const VerifyTokenResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerifyTokenResponse& operator=(VerifyTokenResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerifyTokenResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerifyTokenResponse* internal_default_instance() {
    return reinterpret_cast<const VerifyTokenResponse*>(
               &_VerifyTokenResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(VerifyTokenResponse& a, VerifyTokenResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(VerifyTokenResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerifyTokenResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerifyTokenResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VerifyTokenResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VerifyTokenResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VerifyTokenResponse& from) {
    VerifyTokenResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerifyTokenResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.user.VerifyTokenResponse";
  }
  protected:
  explicit VerifyTokenResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kUserFieldNumber = 2,
    kSessionFieldNumber = 3,
  };
  // .sonet.common.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::sonet::common::Status& status() const;
  PROTOBUF_NODISCARD ::sonet::common::Status* release_status();
  ::sonet::common::Status* mutable_status();
  void set_allocated_status(::sonet::common::Status* status);
  private:
  const ::sonet::common::Status& _internal_status() const;
  ::sonet::common::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::sonet::common::Status* status);
  ::sonet::common::Status* unsafe_arena_release_status();

  // .sonet.user.UserProfile user = 2;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::sonet::user::UserProfile& user() const;
  PROTOBUF_NODISCARD ::sonet::user::UserProfile* release_user();
  ::sonet::user::UserProfile* mutable_user();
  void set_allocated_user(::sonet::user::UserProfile* user);
  private:
  const ::sonet::user::UserProfile& _internal_user() const;
  ::sonet::user::UserProfile* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::sonet::user::UserProfile* user);
  ::sonet::user::UserProfile* unsafe_arena_release_user();

  // .sonet.user.Session session = 3;
  bool has_session() const;
  private:
  bool _internal_has_session() const;
  public:
  void clear_session();
  const ::sonet::user::Session& session() const;
  PROTOBUF_NODISCARD ::sonet::user::Session* release_session();
  ::sonet::user::Session* mutable_session();
  void set_allocated_session(::sonet::user::Session* session);
  private:
  const ::sonet::user::Session& _internal_session() const;
  ::sonet::user::Session* _internal_mutable_session();
  public:
  void unsafe_arena_set_allocated_session(
      ::sonet::user::Session* session);
  ::sonet::user::Session* unsafe_arena_release_session();

  // @@protoc_insertion_point(class_scope:sonet.user.VerifyTokenResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sonet::common::Status* status_;
    ::sonet::user::UserProfile* user_;
    ::sonet::user::Session* session_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fuser_2eproto;
};
// -------------------------------------------------------------------

class RefreshTokenRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.user.RefreshTokenRequest) */ {
 public:
  inline RefreshTokenRequest() : RefreshTokenRequest(nullptr) {}
  ~RefreshTokenRequest() override;
  explicit PROTOBUF_CONSTEXPR RefreshTokenRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefreshTokenRequest(const RefreshTokenRequest& from);
  RefreshTokenRequest(RefreshTokenRequest&& from) noexcept
    : RefreshTokenRequest() {
    *this = ::std::move(from);
  }

  inline RefreshTokenRequest& operator=(const RefreshTokenRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshTokenRequest& operator=(RefreshTokenRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefreshTokenRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshTokenRequest* internal_default_instance() {
    return reinterpret_cast<const RefreshTokenRequest*>(
               &_RefreshTokenRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(RefreshTokenRequest& a, RefreshTokenRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshTokenRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshTokenRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshTokenRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshTokenRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RefreshTokenRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RefreshTokenRequest& from) {
    RefreshTokenRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RefreshTokenRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.user.RefreshTokenRequest";
  }
  protected:
  explicit RefreshTokenRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRefreshTokenFieldNumber = 1,
  };
  // string refresh_token = 1;
  void clear_refresh_token();
  const std::string& refresh_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_refresh_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_refresh_token();
  PROTOBUF_NODISCARD std::string* release_refresh_token();
  void set_allocated_refresh_token(std::string* refresh_token);
  private:
  const std::string& _internal_refresh_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_refresh_token(const std::string& value);
  std::string* _internal_mutable_refresh_token();
  public:

  // @@protoc_insertion_point(class_scope:sonet.user.RefreshTokenRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr refresh_token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fuser_2eproto;
};
// -------------------------------------------------------------------

class RefreshTokenResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.user.RefreshTokenResponse) */ {
 public:
  inline RefreshTokenResponse() : RefreshTokenResponse(nullptr) {}
  ~RefreshTokenResponse() override;
  explicit PROTOBUF_CONSTEXPR RefreshTokenResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefreshTokenResponse(const RefreshTokenResponse& from);
  RefreshTokenResponse(RefreshTokenResponse&& from) noexcept
    : RefreshTokenResponse() {
    *this = ::std::move(from);
  }

  inline RefreshTokenResponse& operator=(const RefreshTokenResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshTokenResponse& operator=(RefreshTokenResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefreshTokenResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshTokenResponse* internal_default_instance() {
    return reinterpret_cast<const RefreshTokenResponse*>(
               &_RefreshTokenResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(RefreshTokenResponse& a, RefreshTokenResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshTokenResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshTokenResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshTokenResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshTokenResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RefreshTokenResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RefreshTokenResponse& from) {
    RefreshTokenResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RefreshTokenResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.user.RefreshTokenResponse";
  }
  protected:
  explicit RefreshTokenResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccessTokenFieldNumber = 2,
    kStatusFieldNumber = 1,
    kExpiresInFieldNumber = 3,
  };
  // string access_token = 2;
  void clear_access_token();
  const std::string& access_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_access_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_access_token();
  PROTOBUF_NODISCARD std::string* release_access_token();
  void set_allocated_access_token(std::string* access_token);
  private:
  const std::string& _internal_access_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_access_token(const std::string& value);
  std::string* _internal_mutable_access_token();
  public:

  // .sonet.common.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::sonet::common::Status& status() const;
  PROTOBUF_NODISCARD ::sonet::common::Status* release_status();
  ::sonet::common::Status* mutable_status();
  void set_allocated_status(::sonet::common::Status* status);
  private:
  const ::sonet::common::Status& _internal_status() const;
  ::sonet::common::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::sonet::common::Status* status);
  ::sonet::common::Status* unsafe_arena_release_status();

  // int32 expires_in = 3;
  void clear_expires_in();
  int32_t expires_in() const;
  void set_expires_in(int32_t value);
  private:
  int32_t _internal_expires_in() const;
  void _internal_set_expires_in(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.user.RefreshTokenResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr access_token_;
    ::sonet::common::Status* status_;
    int32_t expires_in_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fuser_2eproto;
};
// -------------------------------------------------------------------

class LogoutRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.user.LogoutRequest) */ {
 public:
  inline LogoutRequest() : LogoutRequest(nullptr) {}
  ~LogoutRequest() override;
  explicit PROTOBUF_CONSTEXPR LogoutRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogoutRequest(const LogoutRequest& from);
  LogoutRequest(LogoutRequest&& from) noexcept
    : LogoutRequest() {
    *this = ::std::move(from);
  }

  inline LogoutRequest& operator=(const LogoutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogoutRequest& operator=(LogoutRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogoutRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogoutRequest* internal_default_instance() {
    return reinterpret_cast<const LogoutRequest*>(
               &_LogoutRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(LogoutRequest& a, LogoutRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LogoutRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogoutRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogoutRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogoutRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogoutRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogoutRequest& from) {
    LogoutRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogoutRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.user.LogoutRequest";
  }
  protected:
  explicit LogoutRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kLogoutAllDevicesFieldNumber = 2,
  };
  // string session_id = 1;
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // bool logout_all_devices = 2;
  void clear_logout_all_devices();
  bool logout_all_devices() const;
  void set_logout_all_devices(bool value);
  private:
  bool _internal_logout_all_devices() const;
  void _internal_set_logout_all_devices(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.user.LogoutRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    bool logout_all_devices_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fuser_2eproto;
};
// -------------------------------------------------------------------

class LogoutResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.user.LogoutResponse) */ {
 public:
  inline LogoutResponse() : LogoutResponse(nullptr) {}
  ~LogoutResponse() override;
  explicit PROTOBUF_CONSTEXPR LogoutResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogoutResponse(const LogoutResponse& from);
  LogoutResponse(LogoutResponse&& from) noexcept
    : LogoutResponse() {
    *this = ::std::move(from);
  }

  inline LogoutResponse& operator=(const LogoutResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogoutResponse& operator=(LogoutResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogoutResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogoutResponse* internal_default_instance() {
    return reinterpret_cast<const LogoutResponse*>(
               &_LogoutResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(LogoutResponse& a, LogoutResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LogoutResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogoutResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogoutResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogoutResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogoutResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogoutResponse& from) {
    LogoutResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogoutResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.user.LogoutResponse";
  }
  protected:
  explicit LogoutResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .sonet.common.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::sonet::common::Status& status() const;
  PROTOBUF_NODISCARD ::sonet::common::Status* release_status();
  ::sonet::common::Status* mutable_status();
  void set_allocated_status(::sonet::common::Status* status);
  private:
  const ::sonet::common::Status& _internal_status() const;
  ::sonet::common::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::sonet::common::Status* status);
  ::sonet::common::Status* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:sonet.user.LogoutResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sonet::common::Status* status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fuser_2eproto;
};
// -------------------------------------------------------------------

class ChangePasswordRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.user.ChangePasswordRequest) */ {
 public:
  inline ChangePasswordRequest() : ChangePasswordRequest(nullptr) {}
  ~ChangePasswordRequest() override;
  explicit PROTOBUF_CONSTEXPR ChangePasswordRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangePasswordRequest(const ChangePasswordRequest& from);
  ChangePasswordRequest(ChangePasswordRequest&& from) noexcept
    : ChangePasswordRequest() {
    *this = ::std::move(from);
  }

  inline ChangePasswordRequest& operator=(const ChangePasswordRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangePasswordRequest& operator=(ChangePasswordRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangePasswordRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangePasswordRequest* internal_default_instance() {
    return reinterpret_cast<const ChangePasswordRequest*>(
               &_ChangePasswordRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ChangePasswordRequest& a, ChangePasswordRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangePasswordRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangePasswordRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangePasswordRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangePasswordRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangePasswordRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChangePasswordRequest& from) {
    ChangePasswordRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangePasswordRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.user.ChangePasswordRequest";
  }
  protected:
  explicit ChangePasswordRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOldPasswordFieldNumber = 1,
    kNewPasswordFieldNumber = 2,
  };
  // string old_password = 1;
  void clear_old_password();
  const std::string& old_password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_old_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_old_password();
  PROTOBUF_NODISCARD std::string* release_old_password();
  void set_allocated_old_password(std::string* old_password);
  private:
  const std::string& _internal_old_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_old_password(const std::string& value);
  std::string* _internal_mutable_old_password();
  public:

  // string new_password = 2;
  void clear_new_password();
  const std::string& new_password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_password();
  PROTOBUF_NODISCARD std::string* release_new_password();
  void set_allocated_new_password(std::string* new_password);
  private:
  const std::string& _internal_new_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_password(const std::string& value);
  std::string* _internal_mutable_new_password();
  public:

  // @@protoc_insertion_point(class_scope:sonet.user.ChangePasswordRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr old_password_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fuser_2eproto;
};
// -------------------------------------------------------------------

class ChangePasswordResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.user.ChangePasswordResponse) */ {
 public:
  inline ChangePasswordResponse() : ChangePasswordResponse(nullptr) {}
  ~ChangePasswordResponse() override;
  explicit PROTOBUF_CONSTEXPR ChangePasswordResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangePasswordResponse(const ChangePasswordResponse& from);
  ChangePasswordResponse(ChangePasswordResponse&& from) noexcept
    : ChangePasswordResponse() {
    *this = ::std::move(from);
  }

  inline ChangePasswordResponse& operator=(const ChangePasswordResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangePasswordResponse& operator=(ChangePasswordResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangePasswordResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangePasswordResponse* internal_default_instance() {
    return reinterpret_cast<const ChangePasswordResponse*>(
               &_ChangePasswordResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ChangePasswordResponse& a, ChangePasswordResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangePasswordResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangePasswordResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangePasswordResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangePasswordResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangePasswordResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChangePasswordResponse& from) {
    ChangePasswordResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangePasswordResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.user.ChangePasswordResponse";
  }
  protected:
  explicit ChangePasswordResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .sonet.common.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::sonet::common::Status& status() const;
  PROTOBUF_NODISCARD ::sonet::common::Status* release_status();
  ::sonet::common::Status* mutable_status();
  void set_allocated_status(::sonet::common::Status* status);
  private:
  const ::sonet::common::Status& _internal_status() const;
  ::sonet::common::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::sonet::common::Status* status);
  ::sonet::common::Status* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:sonet.user.ChangePasswordResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sonet::common::Status* status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fuser_2eproto;
};
// -------------------------------------------------------------------

class ResetPasswordRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.user.ResetPasswordRequest) */ {
 public:
  inline ResetPasswordRequest() : ResetPasswordRequest(nullptr) {}
  ~ResetPasswordRequest() override;
  explicit PROTOBUF_CONSTEXPR ResetPasswordRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResetPasswordRequest(const ResetPasswordRequest& from);
  ResetPasswordRequest(ResetPasswordRequest&& from) noexcept
    : ResetPasswordRequest() {
    *this = ::std::move(from);
  }

  inline ResetPasswordRequest& operator=(const ResetPasswordRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetPasswordRequest& operator=(ResetPasswordRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResetPasswordRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResetPasswordRequest* internal_default_instance() {
    return reinterpret_cast<const ResetPasswordRequest*>(
               &_ResetPasswordRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ResetPasswordRequest& a, ResetPasswordRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ResetPasswordRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetPasswordRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResetPasswordRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResetPasswordRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResetPasswordRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResetPasswordRequest& from) {
    ResetPasswordRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResetPasswordRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.user.ResetPasswordRequest";
  }
  protected:
  explicit ResetPasswordRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmailFieldNumber = 1,
  };
  // string email = 1;
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // @@protoc_insertion_point(class_scope:sonet.user.ResetPasswordRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fuser_2eproto;
};
// -------------------------------------------------------------------

class ResetPasswordResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.user.ResetPasswordResponse) */ {
 public:
  inline ResetPasswordResponse() : ResetPasswordResponse(nullptr) {}
  ~ResetPasswordResponse() override;
  explicit PROTOBUF_CONSTEXPR ResetPasswordResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResetPasswordResponse(const ResetPasswordResponse& from);
  ResetPasswordResponse(ResetPasswordResponse&& from) noexcept
    : ResetPasswordResponse() {
    *this = ::std::move(from);
  }

  inline ResetPasswordResponse& operator=(const ResetPasswordResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetPasswordResponse& operator=(ResetPasswordResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResetPasswordResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResetPasswordResponse* internal_default_instance() {
    return reinterpret_cast<const ResetPasswordResponse*>(
               &_ResetPasswordResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ResetPasswordResponse& a, ResetPasswordResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ResetPasswordResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetPasswordResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResetPasswordResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResetPasswordResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResetPasswordResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResetPasswordResponse& from) {
    ResetPasswordResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResetPasswordResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.user.ResetPasswordResponse";
  }
  protected:
  explicit ResetPasswordResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResetTokenFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // string reset_token = 2;
  void clear_reset_token();
  const std::string& reset_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reset_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reset_token();
  PROTOBUF_NODISCARD std::string* release_reset_token();
  void set_allocated_reset_token(std::string* reset_token);
  private:
  const std::string& _internal_reset_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reset_token(const std::string& value);
  std::string* _internal_mutable_reset_token();
  public:

  // .sonet.common.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::sonet::common::Status& status() const;
  PROTOBUF_NODISCARD ::sonet::common::Status* release_status();
  ::sonet::common::Status* mutable_status();
  void set_allocated_status(::sonet::common::Status* status);
  private:
  const ::sonet::common::Status& _internal_status() const;
  ::sonet::common::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::sonet::common::Status* status);
  ::sonet::common::Status* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:sonet.user.ResetPasswordResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reset_token_;
    ::sonet::common::Status* status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fuser_2eproto;
};
// -------------------------------------------------------------------

class ConfirmPasswordResetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.user.ConfirmPasswordResetRequest) */ {
 public:
  inline ConfirmPasswordResetRequest() : ConfirmPasswordResetRequest(nullptr) {}
  ~ConfirmPasswordResetRequest() override;
  explicit PROTOBUF_CONSTEXPR ConfirmPasswordResetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfirmPasswordResetRequest(const ConfirmPasswordResetRequest& from);
  ConfirmPasswordResetRequest(ConfirmPasswordResetRequest&& from) noexcept
    : ConfirmPasswordResetRequest() {
    *this = ::std::move(from);
  }

  inline ConfirmPasswordResetRequest& operator=(const ConfirmPasswordResetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfirmPasswordResetRequest& operator=(ConfirmPasswordResetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfirmPasswordResetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfirmPasswordResetRequest* internal_default_instance() {
    return reinterpret_cast<const ConfirmPasswordResetRequest*>(
               &_ConfirmPasswordResetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ConfirmPasswordResetRequest& a, ConfirmPasswordResetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfirmPasswordResetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfirmPasswordResetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfirmPasswordResetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfirmPasswordResetRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfirmPasswordResetRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConfirmPasswordResetRequest& from) {
    ConfirmPasswordResetRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfirmPasswordResetRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.user.ConfirmPasswordResetRequest";
  }
  protected:
  explicit ConfirmPasswordResetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResetTokenFieldNumber = 1,
    kNewPasswordFieldNumber = 2,
  };
  // string reset_token = 1;
  void clear_reset_token();
  const std::string& reset_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reset_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reset_token();
  PROTOBUF_NODISCARD std::string* release_reset_token();
  void set_allocated_reset_token(std::string* reset_token);
  private:
  const std::string& _internal_reset_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reset_token(const std::string& value);
  std::string* _internal_mutable_reset_token();
  public:

  // string new_password = 2;
  void clear_new_password();
  const std::string& new_password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_password();
  PROTOBUF_NODISCARD std::string* release_new_password();
  void set_allocated_new_password(std::string* new_password);
  private:
  const std::string& _internal_new_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_password(const std::string& value);
  std::string* _internal_mutable_new_password();
  public:

  // @@protoc_insertion_point(class_scope:sonet.user.ConfirmPasswordResetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reset_token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fuser_2eproto;
};
// -------------------------------------------------------------------

class ConfirmPasswordResetResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.user.ConfirmPasswordResetResponse) */ {
 public:
  inline ConfirmPasswordResetResponse() : ConfirmPasswordResetResponse(nullptr) {}
  ~ConfirmPasswordResetResponse() override;
  explicit PROTOBUF_CONSTEXPR ConfirmPasswordResetResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfirmPasswordResetResponse(const ConfirmPasswordResetResponse& from);
  ConfirmPasswordResetResponse(ConfirmPasswordResetResponse&& from) noexcept
    : ConfirmPasswordResetResponse() {
    *this = ::std::move(from);
  }

  inline ConfirmPasswordResetResponse& operator=(const ConfirmPasswordResetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfirmPasswordResetResponse& operator=(ConfirmPasswordResetResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfirmPasswordResetResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfirmPasswordResetResponse* internal_default_instance() {
    return reinterpret_cast<const ConfirmPasswordResetResponse*>(
               &_ConfirmPasswordResetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ConfirmPasswordResetResponse& a, ConfirmPasswordResetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfirmPasswordResetResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfirmPasswordResetResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfirmPasswordResetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfirmPasswordResetResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfirmPasswordResetResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConfirmPasswordResetResponse& from) {
    ConfirmPasswordResetResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfirmPasswordResetResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.user.ConfirmPasswordResetResponse";
  }
  protected:
  explicit ConfirmPasswordResetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .sonet.common.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::sonet::common::Status& status() const;
  PROTOBUF_NODISCARD ::sonet::common::Status* release_status();
  ::sonet::common::Status* mutable_status();
  void set_allocated_status(::sonet::common::Status* status);
  private:
  const ::sonet::common::Status& _internal_status() const;
  ::sonet::common::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::sonet::common::Status* status);
  ::sonet::common::Status* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:sonet.user.ConfirmPasswordResetResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sonet::common::Status* status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fuser_2eproto;
};
// -------------------------------------------------------------------

class VerifyEmailRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.user.VerifyEmailRequest) */ {
 public:
  inline VerifyEmailRequest() : VerifyEmailRequest(nullptr) {}
  ~VerifyEmailRequest() override;
  explicit PROTOBUF_CONSTEXPR VerifyEmailRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VerifyEmailRequest(const VerifyEmailRequest& from);
  VerifyEmailRequest(VerifyEmailRequest&& from) noexcept
    : VerifyEmailRequest() {
    *this = ::std::move(from);
  }

  inline VerifyEmailRequest& operator=(const VerifyEmailRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerifyEmailRequest& operator=(VerifyEmailRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerifyEmailRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerifyEmailRequest* internal_default_instance() {
    return reinterpret_cast<const VerifyEmailRequest*>(
               &_VerifyEmailRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(VerifyEmailRequest& a, VerifyEmailRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VerifyEmailRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerifyEmailRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerifyEmailRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VerifyEmailRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VerifyEmailRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VerifyEmailRequest& from) {
    VerifyEmailRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerifyEmailRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.user.VerifyEmailRequest";
  }
  protected:
  explicit VerifyEmailRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVerificationTokenFieldNumber = 1,
  };
  // string verification_token = 1;
  void clear_verification_token();
  const std::string& verification_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_verification_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_verification_token();
  PROTOBUF_NODISCARD std::string* release_verification_token();
  void set_allocated_verification_token(std::string* verification_token);
  private:
  const std::string& _internal_verification_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verification_token(const std::string& value);
  std::string* _internal_mutable_verification_token();
  public:

  // @@protoc_insertion_point(class_scope:sonet.user.VerifyEmailRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr verification_token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fuser_2eproto;
};
// -------------------------------------------------------------------

class VerifyEmailResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.user.VerifyEmailResponse) */ {
 public:
  inline VerifyEmailResponse() : VerifyEmailResponse(nullptr) {}
  ~VerifyEmailResponse() override;
  explicit PROTOBUF_CONSTEXPR VerifyEmailResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VerifyEmailResponse(const VerifyEmailResponse& from);
  VerifyEmailResponse(VerifyEmailResponse&& from) noexcept
    : VerifyEmailResponse() {
    *this = ::std::move(from);
  }

  inline VerifyEmailResponse& operator=(const VerifyEmailResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerifyEmailResponse& operator=(VerifyEmailResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerifyEmailResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerifyEmailResponse* internal_default_instance() {
    return reinterpret_cast<const VerifyEmailResponse*>(
               &_VerifyEmailResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(VerifyEmailResponse& a, VerifyEmailResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(VerifyEmailResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerifyEmailResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerifyEmailResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VerifyEmailResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VerifyEmailResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VerifyEmailResponse& from) {
    VerifyEmailResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerifyEmailResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.user.VerifyEmailResponse";
  }
  protected:
  explicit VerifyEmailResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .sonet.common.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::sonet::common::Status& status() const;
  PROTOBUF_NODISCARD ::sonet::common::Status* release_status();
  ::sonet::common::Status* mutable_status();
  void set_allocated_status(::sonet::common::Status* status);
  private:
  const ::sonet::common::Status& _internal_status() const;
  ::sonet::common::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::sonet::common::Status* status);
  ::sonet::common::Status* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:sonet.user.VerifyEmailResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sonet::common::Status* status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fuser_2eproto;
};
// -------------------------------------------------------------------

class ResendVerificationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.user.ResendVerificationRequest) */ {
 public:
  inline ResendVerificationRequest() : ResendVerificationRequest(nullptr) {}
  ~ResendVerificationRequest() override;
  explicit PROTOBUF_CONSTEXPR ResendVerificationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResendVerificationRequest(const ResendVerificationRequest& from);
  ResendVerificationRequest(ResendVerificationRequest&& from) noexcept
    : ResendVerificationRequest() {
    *this = ::std::move(from);
  }

  inline ResendVerificationRequest& operator=(const ResendVerificationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResendVerificationRequest& operator=(ResendVerificationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResendVerificationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResendVerificationRequest* internal_default_instance() {
    return reinterpret_cast<const ResendVerificationRequest*>(
               &_ResendVerificationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ResendVerificationRequest& a, ResendVerificationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ResendVerificationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResendVerificationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResendVerificationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResendVerificationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResendVerificationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResendVerificationRequest& from) {
    ResendVerificationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResendVerificationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.user.ResendVerificationRequest";
  }
  protected:
  explicit ResendVerificationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmailFieldNumber = 1,
  };
  // string email = 1;
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // @@protoc_insertion_point(class_scope:sonet.user.ResendVerificationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fuser_2eproto;
};
// -------------------------------------------------------------------

class ResendVerificationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.user.ResendVerificationResponse) */ {
 public:
  inline ResendVerificationResponse() : ResendVerificationResponse(nullptr) {}
  ~ResendVerificationResponse() override;
  explicit PROTOBUF_CONSTEXPR ResendVerificationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResendVerificationResponse(const ResendVerificationResponse& from);
  ResendVerificationResponse(ResendVerificationResponse&& from) noexcept
    : ResendVerificationResponse() {
    *this = ::std::move(from);
  }

  inline ResendVerificationResponse& operator=(const ResendVerificationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResendVerificationResponse& operator=(ResendVerificationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResendVerificationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResendVerificationResponse* internal_default_instance() {
    return reinterpret_cast<const ResendVerificationResponse*>(
               &_ResendVerificationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ResendVerificationResponse& a, ResendVerificationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ResendVerificationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResendVerificationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResendVerificationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResendVerificationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResendVerificationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResendVerificationResponse& from) {
    ResendVerificationResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResendVerificationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.user.ResendVerificationResponse";
  }
  protected:
  explicit ResendVerificationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .sonet.common.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::sonet::common::Status& status() const;
  PROTOBUF_NODISCARD ::sonet::common::Status* release_status();
  ::sonet::common::Status* mutable_status();
  void set_allocated_status(::sonet::common::Status* status);
  private:
  const ::sonet::common::Status& _internal_status() const;
  ::sonet::common::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::sonet::common::Status* status);
  ::sonet::common::Status* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:sonet.user.ResendVerificationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sonet::common::Status* status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fuser_2eproto;
};
// -------------------------------------------------------------------

class SetupTwoFactorRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.user.SetupTwoFactorRequest) */ {
 public:
  inline SetupTwoFactorRequest() : SetupTwoFactorRequest(nullptr) {}
  ~SetupTwoFactorRequest() override;
  explicit PROTOBUF_CONSTEXPR SetupTwoFactorRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetupTwoFactorRequest(const SetupTwoFactorRequest& from);
  SetupTwoFactorRequest(SetupTwoFactorRequest&& from) noexcept
    : SetupTwoFactorRequest() {
    *this = ::std::move(from);
  }

  inline SetupTwoFactorRequest& operator=(const SetupTwoFactorRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetupTwoFactorRequest& operator=(SetupTwoFactorRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetupTwoFactorRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetupTwoFactorRequest* internal_default_instance() {
    return reinterpret_cast<const SetupTwoFactorRequest*>(
               &_SetupTwoFactorRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(SetupTwoFactorRequest& a, SetupTwoFactorRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetupTwoFactorRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetupTwoFactorRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetupTwoFactorRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetupTwoFactorRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetupTwoFactorRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetupTwoFactorRequest& from) {
    SetupTwoFactorRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetupTwoFactorRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.user.SetupTwoFactorRequest";
  }
  protected:
  explicit SetupTwoFactorRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // @@protoc_insertion_point(class_scope:sonet.user.SetupTwoFactorRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fuser_2eproto;
};
// -------------------------------------------------------------------

class SetupTwoFactorResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.user.SetupTwoFactorResponse) */ {
 public:
  inline SetupTwoFactorResponse() : SetupTwoFactorResponse(nullptr) {}
  ~SetupTwoFactorResponse() override;
  explicit PROTOBUF_CONSTEXPR SetupTwoFactorResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetupTwoFactorResponse(const SetupTwoFactorResponse& from);
  SetupTwoFactorResponse(SetupTwoFactorResponse&& from) noexcept
    : SetupTwoFactorResponse() {
    *this = ::std::move(from);
  }

  inline SetupTwoFactorResponse& operator=(const SetupTwoFactorResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetupTwoFactorResponse& operator=(SetupTwoFactorResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetupTwoFactorResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetupTwoFactorResponse* internal_default_instance() {
    return reinterpret_cast<const SetupTwoFactorResponse*>(
               &_SetupTwoFactorResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(SetupTwoFactorResponse& a, SetupTwoFactorResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetupTwoFactorResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetupTwoFactorResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetupTwoFactorResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetupTwoFactorResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetupTwoFactorResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetupTwoFactorResponse& from) {
    SetupTwoFactorResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetupTwoFactorResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.user.SetupTwoFactorResponse";
  }
  protected:
  explicit SetupTwoFactorResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kTfaConfigFieldNumber = 2,
  };
  // .sonet.common.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::sonet::common::Status& status() const;
  PROTOBUF_NODISCARD ::sonet::common::Status* release_status();
  ::sonet::common::Status* mutable_status();
  void set_allocated_status(::sonet::common::Status* status);
  private:
  const ::sonet::common::Status& _internal_status() const;
  ::sonet::common::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::sonet::common::Status* status);
  ::sonet::common::Status* unsafe_arena_release_status();

  // .sonet.user.TwoFactorAuth tfa_config = 2;
  bool has_tfa_config() const;
  private:
  bool _internal_has_tfa_config() const;
  public:
  void clear_tfa_config();
  const ::sonet::user::TwoFactorAuth& tfa_config() const;
  PROTOBUF_NODISCARD ::sonet::user::TwoFactorAuth* release_tfa_config();
  ::sonet::user::TwoFactorAuth* mutable_tfa_config();
  void set_allocated_tfa_config(::sonet::user::TwoFactorAuth* tfa_config);
  private:
  const ::sonet::user::TwoFactorAuth& _internal_tfa_config() const;
  ::sonet::user::TwoFactorAuth* _internal_mutable_tfa_config();
  public:
  void unsafe_arena_set_allocated_tfa_config(
      ::sonet::user::TwoFactorAuth* tfa_config);
  ::sonet::user::TwoFactorAuth* unsafe_arena_release_tfa_config();

  // @@protoc_insertion_point(class_scope:sonet.user.SetupTwoFactorResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sonet::common::Status* status_;
    ::sonet::user::TwoFactorAuth* tfa_config_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fuser_2eproto;
};
// -------------------------------------------------------------------

class VerifyTwoFactorRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.user.VerifyTwoFactorRequest) */ {
 public:
  inline VerifyTwoFactorRequest() : VerifyTwoFactorRequest(nullptr) {}
  ~VerifyTwoFactorRequest() override;
  explicit PROTOBUF_CONSTEXPR VerifyTwoFactorRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VerifyTwoFactorRequest(const VerifyTwoFactorRequest& from);
  VerifyTwoFactorRequest(VerifyTwoFactorRequest&& from) noexcept
    : VerifyTwoFactorRequest() {
    *this = ::std::move(from);
  }

  inline VerifyTwoFactorRequest& operator=(const VerifyTwoFactorRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerifyTwoFactorRequest& operator=(VerifyTwoFactorRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerifyTwoFactorRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerifyTwoFactorRequest* internal_default_instance() {
    return reinterpret_cast<const VerifyTwoFactorRequest*>(
               &_VerifyTwoFactorRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(VerifyTwoFactorRequest& a, VerifyTwoFactorRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VerifyTwoFactorRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerifyTwoFactorRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerifyTwoFactorRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VerifyTwoFactorRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VerifyTwoFactorRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VerifyTwoFactorRequest& from) {
    VerifyTwoFactorRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerifyTwoFactorRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.user.VerifyTwoFactorRequest";
  }
  protected:
  explicit VerifyTwoFactorRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kCodeFieldNumber = 2,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string code = 2;
  void clear_code();
  const std::string& code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // @@protoc_insertion_point(class_scope:sonet.user.VerifyTwoFactorRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fuser_2eproto;
};
// -------------------------------------------------------------------

class VerifyTwoFactorResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.user.VerifyTwoFactorResponse) */ {
 public:
  inline VerifyTwoFactorResponse() : VerifyTwoFactorResponse(nullptr) {}
  ~VerifyTwoFactorResponse() override;
  explicit PROTOBUF_CONSTEXPR VerifyTwoFactorResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VerifyTwoFactorResponse(const VerifyTwoFactorResponse& from);
  VerifyTwoFactorResponse(VerifyTwoFactorResponse&& from) noexcept
    : VerifyTwoFactorResponse() {
    *this = ::std::move(from);
  }

  inline VerifyTwoFactorResponse& operator=(const VerifyTwoFactorResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerifyTwoFactorResponse& operator=(VerifyTwoFactorResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerifyTwoFactorResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerifyTwoFactorResponse* internal_default_instance() {
    return reinterpret_cast<const VerifyTwoFactorResponse*>(
               &_VerifyTwoFactorResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(VerifyTwoFactorResponse& a, VerifyTwoFactorResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(VerifyTwoFactorResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerifyTwoFactorResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerifyTwoFactorResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VerifyTwoFactorResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VerifyTwoFactorResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VerifyTwoFactorResponse& from) {
    VerifyTwoFactorResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerifyTwoFactorResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.user.VerifyTwoFactorResponse";
  }
  protected:
  explicit VerifyTwoFactorResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kIsVerifiedFieldNumber = 2,
  };
  // .sonet.common.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::sonet::common::Status& status() const;
  PROTOBUF_NODISCARD ::sonet::common::Status* release_status();
  ::sonet::common::Status* mutable_status();
  void set_allocated_status(::sonet::common::Status* status);
  private:
  const ::sonet::common::Status& _internal_status() const;
  ::sonet::common::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::sonet::common::Status* status);
  ::sonet::common::Status* unsafe_arena_release_status();

  // bool is_verified = 2;
  void clear_is_verified();
  bool is_verified() const;
  void set_is_verified(bool value);
  private:
  bool _internal_is_verified() const;
  void _internal_set_is_verified(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.user.VerifyTwoFactorResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sonet::common::Status* status_;
    bool is_verified_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fuser_2eproto;
};
// -------------------------------------------------------------------

class DisableTwoFactorRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.user.DisableTwoFactorRequest) */ {
 public:
  inline DisableTwoFactorRequest() : DisableTwoFactorRequest(nullptr) {}
  ~DisableTwoFactorRequest() override;
  explicit PROTOBUF_CONSTEXPR DisableTwoFactorRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DisableTwoFactorRequest(const DisableTwoFactorRequest& from);
  DisableTwoFactorRequest(DisableTwoFactorRequest&& from) noexcept
    : DisableTwoFactorRequest() {
    *this = ::std::move(from);
  }

  inline DisableTwoFactorRequest& operator=(const DisableTwoFactorRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DisableTwoFactorRequest& operator=(DisableTwoFactorRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DisableTwoFactorRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DisableTwoFactorRequest* internal_default_instance() {
    return reinterpret_cast<const DisableTwoFactorRequest*>(
               &_DisableTwoFactorRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(DisableTwoFactorRequest& a, DisableTwoFactorRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DisableTwoFactorRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DisableTwoFactorRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DisableTwoFactorRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DisableTwoFactorRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DisableTwoFactorRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DisableTwoFactorRequest& from) {
    DisableTwoFactorRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DisableTwoFactorRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.user.DisableTwoFactorRequest";
  }
  protected:
  explicit DisableTwoFactorRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPasswordFieldNumber = 1,
  };
  // string password = 1;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:sonet.user.DisableTwoFactorRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fuser_2eproto;
};
// -------------------------------------------------------------------

class DisableTwoFactorResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.user.DisableTwoFactorResponse) */ {
 public:
  inline DisableTwoFactorResponse() : DisableTwoFactorResponse(nullptr) {}
  ~DisableTwoFactorResponse() override;
  explicit PROTOBUF_CONSTEXPR DisableTwoFactorResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DisableTwoFactorResponse(const DisableTwoFactorResponse& from);
  DisableTwoFactorResponse(DisableTwoFactorResponse&& from) noexcept
    : DisableTwoFactorResponse() {
    *this = ::std::move(from);
  }

  inline DisableTwoFactorResponse& operator=(const DisableTwoFactorResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DisableTwoFactorResponse& operator=(DisableTwoFactorResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DisableTwoFactorResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DisableTwoFactorResponse* internal_default_instance() {
    return reinterpret_cast<const DisableTwoFactorResponse*>(
               &_DisableTwoFactorResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(DisableTwoFactorResponse& a, DisableTwoFactorResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DisableTwoFactorResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DisableTwoFactorResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DisableTwoFactorResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DisableTwoFactorResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DisableTwoFactorResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DisableTwoFactorResponse& from) {
    DisableTwoFactorResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DisableTwoFactorResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.user.DisableTwoFactorResponse";
  }
  protected:
  explicit DisableTwoFactorResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .sonet.common.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::sonet::common::Status& status() const;
  PROTOBUF_NODISCARD ::sonet::common::Status* release_status();
  ::sonet::common::Status* mutable_status();
  void set_allocated_status(::sonet::common::Status* status);
  private:
  const ::sonet::common::Status& _internal_status() const;
  ::sonet::common::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::sonet::common::Status* status);
  ::sonet::common::Status* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:sonet.user.DisableTwoFactorResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sonet::common::Status* status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fuser_2eproto;
};
// -------------------------------------------------------------------

class GetActiveSessionsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.user.GetActiveSessionsRequest) */ {
 public:
  inline GetActiveSessionsRequest() : GetActiveSessionsRequest(nullptr) {}
  ~GetActiveSessionsRequest() override;
  explicit PROTOBUF_CONSTEXPR GetActiveSessionsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetActiveSessionsRequest(const GetActiveSessionsRequest& from);
  GetActiveSessionsRequest(GetActiveSessionsRequest&& from) noexcept
    : GetActiveSessionsRequest() {
    *this = ::std::move(from);
  }

  inline GetActiveSessionsRequest& operator=(const GetActiveSessionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetActiveSessionsRequest& operator=(GetActiveSessionsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetActiveSessionsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetActiveSessionsRequest* internal_default_instance() {
    return reinterpret_cast<const GetActiveSessionsRequest*>(
               &_GetActiveSessionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(GetActiveSessionsRequest& a, GetActiveSessionsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetActiveSessionsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetActiveSessionsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetActiveSessionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetActiveSessionsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetActiveSessionsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetActiveSessionsRequest& from) {
    GetActiveSessionsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetActiveSessionsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.user.GetActiveSessionsRequest";
  }
  protected:
  explicit GetActiveSessionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // @@protoc_insertion_point(class_scope:sonet.user.GetActiveSessionsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fuser_2eproto;
};
// -------------------------------------------------------------------

class GetActiveSessionsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.user.GetActiveSessionsResponse) */ {
 public:
  inline GetActiveSessionsResponse() : GetActiveSessionsResponse(nullptr) {}
  ~GetActiveSessionsResponse() override;
  explicit PROTOBUF_CONSTEXPR GetActiveSessionsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetActiveSessionsResponse(const GetActiveSessionsResponse& from);
  GetActiveSessionsResponse(GetActiveSessionsResponse&& from) noexcept
    : GetActiveSessionsResponse() {
    *this = ::std::move(from);
  }

  inline GetActiveSessionsResponse& operator=(const GetActiveSessionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetActiveSessionsResponse& operator=(GetActiveSessionsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetActiveSessionsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetActiveSessionsResponse* internal_default_instance() {
    return reinterpret_cast<const GetActiveSessionsResponse*>(
               &_GetActiveSessionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(GetActiveSessionsResponse& a, GetActiveSessionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetActiveSessionsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetActiveSessionsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetActiveSessionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetActiveSessionsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetActiveSessionsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetActiveSessionsResponse& from) {
    GetActiveSessionsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetActiveSessionsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.user.GetActiveSessionsResponse";
  }
  protected:
  explicit GetActiveSessionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionsFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // repeated .sonet.user.Session sessions = 2;
  int sessions_size() const;
  private:
  int _internal_sessions_size() const;
  public:
  void clear_sessions();
  ::sonet::user::Session* mutable_sessions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::user::Session >*
      mutable_sessions();
  private:
  const ::sonet::user::Session& _internal_sessions(int index) const;
  ::sonet::user::Session* _internal_add_sessions();
  public:
  const ::sonet::user::Session& sessions(int index) const;
  ::sonet::user::Session* add_sessions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::user::Session >&
      sessions() const;

  // .sonet.common.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::sonet::common::Status& status() const;
  PROTOBUF_NODISCARD ::sonet::common::Status* release_status();
  ::sonet::common::Status* mutable_status();
  void set_allocated_status(::sonet::common::Status* status);
  private:
  const ::sonet::common::Status& _internal_status() const;
  ::sonet::common::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::sonet::common::Status* status);
  ::sonet::common::Status* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:sonet.user.GetActiveSessionsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::user::Session > sessions_;
    ::sonet::common::Status* status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fuser_2eproto;
};
// -------------------------------------------------------------------

class TerminateSessionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.user.TerminateSessionRequest) */ {
 public:
  inline TerminateSessionRequest() : TerminateSessionRequest(nullptr) {}
  ~TerminateSessionRequest() override;
  explicit PROTOBUF_CONSTEXPR TerminateSessionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TerminateSessionRequest(const TerminateSessionRequest& from);
  TerminateSessionRequest(TerminateSessionRequest&& from) noexcept
    : TerminateSessionRequest() {
    *this = ::std::move(from);
  }

  inline TerminateSessionRequest& operator=(const TerminateSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TerminateSessionRequest& operator=(TerminateSessionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TerminateSessionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TerminateSessionRequest* internal_default_instance() {
    return reinterpret_cast<const TerminateSessionRequest*>(
               &_TerminateSessionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(TerminateSessionRequest& a, TerminateSessionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TerminateSessionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TerminateSessionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TerminateSessionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TerminateSessionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TerminateSessionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TerminateSessionRequest& from) {
    TerminateSessionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TerminateSessionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.user.TerminateSessionRequest";
  }
  protected:
  explicit TerminateSessionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
  };
  // string session_id = 1;
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // @@protoc_insertion_point(class_scope:sonet.user.TerminateSessionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fuser_2eproto;
};
// -------------------------------------------------------------------

class TerminateSessionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.user.TerminateSessionResponse) */ {
 public:
  inline TerminateSessionResponse() : TerminateSessionResponse(nullptr) {}
  ~TerminateSessionResponse() override;
  explicit PROTOBUF_CONSTEXPR TerminateSessionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TerminateSessionResponse(const TerminateSessionResponse& from);
  TerminateSessionResponse(TerminateSessionResponse&& from) noexcept
    : TerminateSessionResponse() {
    *this = ::std::move(from);
  }

  inline TerminateSessionResponse& operator=(const TerminateSessionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TerminateSessionResponse& operator=(TerminateSessionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TerminateSessionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TerminateSessionResponse* internal_default_instance() {
    return reinterpret_cast<const TerminateSessionResponse*>(
               &_TerminateSessionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(TerminateSessionResponse& a, TerminateSessionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TerminateSessionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TerminateSessionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TerminateSessionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TerminateSessionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TerminateSessionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TerminateSessionResponse& from) {
    TerminateSessionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TerminateSessionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.user.TerminateSessionResponse";
  }
  protected:
  explicit TerminateSessionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .sonet.common.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::sonet::common::Status& status() const;
  PROTOBUF_NODISCARD ::sonet::common::Status* release_status();
  ::sonet::common::Status* mutable_status();
  void set_allocated_status(::sonet::common::Status* status);
  private:
  const ::sonet::common::Status& _internal_status() const;
  ::sonet::common::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::sonet::common::Status* status);
  ::sonet::common::Status* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:sonet.user.TerminateSessionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sonet::common::Status* status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fuser_2eproto;
};
// -------------------------------------------------------------------

class GetUserProfileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.user.GetUserProfileRequest) */ {
 public:
  inline GetUserProfileRequest() : GetUserProfileRequest(nullptr) {}
  ~GetUserProfileRequest() override;
  explicit PROTOBUF_CONSTEXPR GetUserProfileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUserProfileRequest(const GetUserProfileRequest& from);
  GetUserProfileRequest(GetUserProfileRequest&& from) noexcept
    : GetUserProfileRequest() {
    *this = ::std::move(from);
  }

  inline GetUserProfileRequest& operator=(const GetUserProfileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserProfileRequest& operator=(GetUserProfileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUserProfileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserProfileRequest* internal_default_instance() {
    return reinterpret_cast<const GetUserProfileRequest*>(
               &_GetUserProfileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(GetUserProfileRequest& a, GetUserProfileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserProfileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserProfileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserProfileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUserProfileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetUserProfileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetUserProfileRequest& from) {
    GetUserProfileRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUserProfileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.user.GetUserProfileRequest";
  }
  protected:
  explicit GetUserProfileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // @@protoc_insertion_point(class_scope:sonet.user.GetUserProfileRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fuser_2eproto;
};
// -------------------------------------------------------------------

class GetUserProfileResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.user.GetUserProfileResponse) */ {
 public:
  inline GetUserProfileResponse() : GetUserProfileResponse(nullptr) {}
  ~GetUserProfileResponse() override;
  explicit PROTOBUF_CONSTEXPR GetUserProfileResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUserProfileResponse(const GetUserProfileResponse& from);
  GetUserProfileResponse(GetUserProfileResponse&& from) noexcept
    : GetUserProfileResponse() {
    *this = ::std::move(from);
  }

  inline GetUserProfileResponse& operator=(const GetUserProfileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserProfileResponse& operator=(GetUserProfileResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUserProfileResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserProfileResponse* internal_default_instance() {
    return reinterpret_cast<const GetUserProfileResponse*>(
               &_GetUserProfileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(GetUserProfileResponse& a, GetUserProfileResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserProfileResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserProfileResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserProfileResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUserProfileResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetUserProfileResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetUserProfileResponse& from) {
    GetUserProfileResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUserProfileResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.user.GetUserProfileResponse";
  }
  protected:
  explicit GetUserProfileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kUserFieldNumber = 2,
  };
  // .sonet.common.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::sonet::common::Status& status() const;
  PROTOBUF_NODISCARD ::sonet::common::Status* release_status();
  ::sonet::common::Status* mutable_status();
  void set_allocated_status(::sonet::common::Status* status);
  private:
  const ::sonet::common::Status& _internal_status() const;
  ::sonet::common::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::sonet::common::Status* status);
  ::sonet::common::Status* unsafe_arena_release_status();

  // .sonet.user.UserProfile user = 2;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::sonet::user::UserProfile& user() const;
  PROTOBUF_NODISCARD ::sonet::user::UserProfile* release_user();
  ::sonet::user::UserProfile* mutable_user();
  void set_allocated_user(::sonet::user::UserProfile* user);
  private:
  const ::sonet::user::UserProfile& _internal_user() const;
  ::sonet::user::UserProfile* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::sonet::user::UserProfile* user);
  ::sonet::user::UserProfile* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:sonet.user.GetUserProfileResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sonet::common::Status* status_;
    ::sonet::user::UserProfile* user_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fuser_2eproto;
};
// -------------------------------------------------------------------

class UpdateUserProfileRequest_SettingsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<UpdateUserProfileRequest_SettingsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<UpdateUserProfileRequest_SettingsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  UpdateUserProfileRequest_SettingsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR UpdateUserProfileRequest_SettingsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit UpdateUserProfileRequest_SettingsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const UpdateUserProfileRequest_SettingsEntry_DoNotUse& other);
  static const UpdateUserProfileRequest_SettingsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const UpdateUserProfileRequest_SettingsEntry_DoNotUse*>(&_UpdateUserProfileRequest_SettingsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "sonet.user.UpdateUserProfileRequest.SettingsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "sonet.user.UpdateUserProfileRequest.SettingsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_services_2fuser_2eproto;
};

// -------------------------------------------------------------------

class UpdateUserProfileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.user.UpdateUserProfileRequest) */ {
 public:
  inline UpdateUserProfileRequest() : UpdateUserProfileRequest(nullptr) {}
  ~UpdateUserProfileRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateUserProfileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateUserProfileRequest(const UpdateUserProfileRequest& from);
  UpdateUserProfileRequest(UpdateUserProfileRequest&& from) noexcept
    : UpdateUserProfileRequest() {
    *this = ::std::move(from);
  }

  inline UpdateUserProfileRequest& operator=(const UpdateUserProfileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateUserProfileRequest& operator=(UpdateUserProfileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateUserProfileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateUserProfileRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateUserProfileRequest*>(
               &_UpdateUserProfileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(UpdateUserProfileRequest& a, UpdateUserProfileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateUserProfileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateUserProfileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateUserProfileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateUserProfileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateUserProfileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateUserProfileRequest& from) {
    UpdateUserProfileRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateUserProfileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.user.UpdateUserProfileRequest";
  }
  protected:
  explicit UpdateUserProfileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSettingsFieldNumber = 7,
    kUserIdFieldNumber = 1,
    kDisplayNameFieldNumber = 2,
    kBioFieldNumber = 3,
    kLocationFieldNumber = 4,
    kWebsiteFieldNumber = 5,
    kIsPrivateFieldNumber = 6,
  };
  // map<string, string> settings = 7;
  int settings_size() const;
  private:
  int _internal_settings_size() const;
  public:
  void clear_settings();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_settings() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_settings();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      settings() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_settings();

  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string display_name = 2;
  void clear_display_name();
  const std::string& display_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_display_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_display_name();
  PROTOBUF_NODISCARD std::string* release_display_name();
  void set_allocated_display_name(std::string* display_name);
  private:
  const std::string& _internal_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(const std::string& value);
  std::string* _internal_mutable_display_name();
  public:

  // string bio = 3;
  void clear_bio();
  const std::string& bio() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bio(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bio();
  PROTOBUF_NODISCARD std::string* release_bio();
  void set_allocated_bio(std::string* bio);
  private:
  const std::string& _internal_bio() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bio(const std::string& value);
  std::string* _internal_mutable_bio();
  public:

  // string location = 4;
  void clear_location();
  const std::string& location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // string website = 5;
  void clear_website();
  const std::string& website() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_website(ArgT0&& arg0, ArgT... args);
  std::string* mutable_website();
  PROTOBUF_NODISCARD std::string* release_website();
  void set_allocated_website(std::string* website);
  private:
  const std::string& _internal_website() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_website(const std::string& value);
  std::string* _internal_mutable_website();
  public:

  // bool is_private = 6;
  void clear_is_private();
  bool is_private() const;
  void set_is_private(bool value);
  private:
  bool _internal_is_private() const;
  void _internal_set_is_private(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.user.UpdateUserProfileRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        UpdateUserProfileRequest_SettingsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> settings_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr display_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bio_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr website_;
    bool is_private_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fuser_2eproto;
};
// -------------------------------------------------------------------

class UpdateUserProfileResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.user.UpdateUserProfileResponse) */ {
 public:
  inline UpdateUserProfileResponse() : UpdateUserProfileResponse(nullptr) {}
  ~UpdateUserProfileResponse() override;
  explicit PROTOBUF_CONSTEXPR UpdateUserProfileResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateUserProfileResponse(const UpdateUserProfileResponse& from);
  UpdateUserProfileResponse(UpdateUserProfileResponse&& from) noexcept
    : UpdateUserProfileResponse() {
    *this = ::std::move(from);
  }

  inline UpdateUserProfileResponse& operator=(const UpdateUserProfileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateUserProfileResponse& operator=(UpdateUserProfileResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateUserProfileResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateUserProfileResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateUserProfileResponse*>(
               &_UpdateUserProfileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(UpdateUserProfileResponse& a, UpdateUserProfileResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateUserProfileResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateUserProfileResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateUserProfileResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateUserProfileResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateUserProfileResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateUserProfileResponse& from) {
    UpdateUserProfileResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateUserProfileResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.user.UpdateUserProfileResponse";
  }
  protected:
  explicit UpdateUserProfileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kUserFieldNumber = 2,
  };
  // .sonet.common.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::sonet::common::Status& status() const;
  PROTOBUF_NODISCARD ::sonet::common::Status* release_status();
  ::sonet::common::Status* mutable_status();
  void set_allocated_status(::sonet::common::Status* status);
  private:
  const ::sonet::common::Status& _internal_status() const;
  ::sonet::common::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::sonet::common::Status* status);
  ::sonet::common::Status* unsafe_arena_release_status();

  // .sonet.user.UserProfile user = 2;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::sonet::user::UserProfile& user() const;
  PROTOBUF_NODISCARD ::sonet::user::UserProfile* release_user();
  ::sonet::user::UserProfile* mutable_user();
  void set_allocated_user(::sonet::user::UserProfile* user);
  private:
  const ::sonet::user::UserProfile& _internal_user() const;
  ::sonet::user::UserProfile* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::sonet::user::UserProfile* user);
  ::sonet::user::UserProfile* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:sonet.user.UpdateUserProfileResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sonet::common::Status* status_;
    ::sonet::user::UserProfile* user_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fuser_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// UserProfile

// string user_id = 1;
inline void UserProfile::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& UserProfile::user_id() const {
  // @@protoc_insertion_point(field_get:sonet.user.UserProfile.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserProfile::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.UserProfile.user_id)
}
inline std::string* UserProfile::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:sonet.user.UserProfile.user_id)
  return _s;
}
inline const std::string& UserProfile::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void UserProfile::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UserProfile::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UserProfile::release_user_id() {
  // @@protoc_insertion_point(field_release:sonet.user.UserProfile.user_id)
  return _impl_.user_id_.Release();
}
inline void UserProfile::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.UserProfile.user_id)
}

// string username = 2;
inline void UserProfile::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& UserProfile::username() const {
  // @@protoc_insertion_point(field_get:sonet.user.UserProfile.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserProfile::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.UserProfile.username)
}
inline std::string* UserProfile::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:sonet.user.UserProfile.username)
  return _s;
}
inline const std::string& UserProfile::_internal_username() const {
  return _impl_.username_.Get();
}
inline void UserProfile::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* UserProfile::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* UserProfile::release_username() {
  // @@protoc_insertion_point(field_release:sonet.user.UserProfile.username)
  return _impl_.username_.Release();
}
inline void UserProfile::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.UserProfile.username)
}

// string email = 3;
inline void UserProfile::clear_email() {
  _impl_.email_.ClearToEmpty();
}
inline const std::string& UserProfile::email() const {
  // @@protoc_insertion_point(field_get:sonet.user.UserProfile.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserProfile::set_email(ArgT0&& arg0, ArgT... args) {
 
 _impl_.email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.UserProfile.email)
}
inline std::string* UserProfile::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:sonet.user.UserProfile.email)
  return _s;
}
inline const std::string& UserProfile::_internal_email() const {
  return _impl_.email_.Get();
}
inline void UserProfile::_internal_set_email(const std::string& value) {
  
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* UserProfile::_internal_mutable_email() {
  
  return _impl_.email_.Mutable(GetArenaForAllocation());
}
inline std::string* UserProfile::release_email() {
  // @@protoc_insertion_point(field_release:sonet.user.UserProfile.email)
  return _impl_.email_.Release();
}
inline void UserProfile::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.UserProfile.email)
}

// string display_name = 4;
inline void UserProfile::clear_display_name() {
  _impl_.display_name_.ClearToEmpty();
}
inline const std::string& UserProfile::display_name() const {
  // @@protoc_insertion_point(field_get:sonet.user.UserProfile.display_name)
  return _internal_display_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserProfile::set_display_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.display_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.UserProfile.display_name)
}
inline std::string* UserProfile::mutable_display_name() {
  std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:sonet.user.UserProfile.display_name)
  return _s;
}
inline const std::string& UserProfile::_internal_display_name() const {
  return _impl_.display_name_.Get();
}
inline void UserProfile::_internal_set_display_name(const std::string& value) {
  
  _impl_.display_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UserProfile::_internal_mutable_display_name() {
  
  return _impl_.display_name_.Mutable(GetArenaForAllocation());
}
inline std::string* UserProfile::release_display_name() {
  // @@protoc_insertion_point(field_release:sonet.user.UserProfile.display_name)
  return _impl_.display_name_.Release();
}
inline void UserProfile::set_allocated_display_name(std::string* display_name) {
  if (display_name != nullptr) {
    
  } else {
    
  }
  _impl_.display_name_.SetAllocated(display_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.display_name_.IsDefault()) {
    _impl_.display_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.UserProfile.display_name)
}

// string bio = 5;
inline void UserProfile::clear_bio() {
  _impl_.bio_.ClearToEmpty();
}
inline const std::string& UserProfile::bio() const {
  // @@protoc_insertion_point(field_get:sonet.user.UserProfile.bio)
  return _internal_bio();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserProfile::set_bio(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bio_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.UserProfile.bio)
}
inline std::string* UserProfile::mutable_bio() {
  std::string* _s = _internal_mutable_bio();
  // @@protoc_insertion_point(field_mutable:sonet.user.UserProfile.bio)
  return _s;
}
inline const std::string& UserProfile::_internal_bio() const {
  return _impl_.bio_.Get();
}
inline void UserProfile::_internal_set_bio(const std::string& value) {
  
  _impl_.bio_.Set(value, GetArenaForAllocation());
}
inline std::string* UserProfile::_internal_mutable_bio() {
  
  return _impl_.bio_.Mutable(GetArenaForAllocation());
}
inline std::string* UserProfile::release_bio() {
  // @@protoc_insertion_point(field_release:sonet.user.UserProfile.bio)
  return _impl_.bio_.Release();
}
inline void UserProfile::set_allocated_bio(std::string* bio) {
  if (bio != nullptr) {
    
  } else {
    
  }
  _impl_.bio_.SetAllocated(bio, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bio_.IsDefault()) {
    _impl_.bio_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.UserProfile.bio)
}

// string avatar_url = 6;
inline void UserProfile::clear_avatar_url() {
  _impl_.avatar_url_.ClearToEmpty();
}
inline const std::string& UserProfile::avatar_url() const {
  // @@protoc_insertion_point(field_get:sonet.user.UserProfile.avatar_url)
  return _internal_avatar_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserProfile::set_avatar_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.avatar_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.UserProfile.avatar_url)
}
inline std::string* UserProfile::mutable_avatar_url() {
  std::string* _s = _internal_mutable_avatar_url();
  // @@protoc_insertion_point(field_mutable:sonet.user.UserProfile.avatar_url)
  return _s;
}
inline const std::string& UserProfile::_internal_avatar_url() const {
  return _impl_.avatar_url_.Get();
}
inline void UserProfile::_internal_set_avatar_url(const std::string& value) {
  
  _impl_.avatar_url_.Set(value, GetArenaForAllocation());
}
inline std::string* UserProfile::_internal_mutable_avatar_url() {
  
  return _impl_.avatar_url_.Mutable(GetArenaForAllocation());
}
inline std::string* UserProfile::release_avatar_url() {
  // @@protoc_insertion_point(field_release:sonet.user.UserProfile.avatar_url)
  return _impl_.avatar_url_.Release();
}
inline void UserProfile::set_allocated_avatar_url(std::string* avatar_url) {
  if (avatar_url != nullptr) {
    
  } else {
    
  }
  _impl_.avatar_url_.SetAllocated(avatar_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.avatar_url_.IsDefault()) {
    _impl_.avatar_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.UserProfile.avatar_url)
}

// string location = 7;
inline void UserProfile::clear_location() {
  _impl_.location_.ClearToEmpty();
}
inline const std::string& UserProfile::location() const {
  // @@protoc_insertion_point(field_get:sonet.user.UserProfile.location)
  return _internal_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserProfile::set_location(ArgT0&& arg0, ArgT... args) {
 
 _impl_.location_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.UserProfile.location)
}
inline std::string* UserProfile::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:sonet.user.UserProfile.location)
  return _s;
}
inline const std::string& UserProfile::_internal_location() const {
  return _impl_.location_.Get();
}
inline void UserProfile::_internal_set_location(const std::string& value) {
  
  _impl_.location_.Set(value, GetArenaForAllocation());
}
inline std::string* UserProfile::_internal_mutable_location() {
  
  return _impl_.location_.Mutable(GetArenaForAllocation());
}
inline std::string* UserProfile::release_location() {
  // @@protoc_insertion_point(field_release:sonet.user.UserProfile.location)
  return _impl_.location_.Release();
}
inline void UserProfile::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    
  } else {
    
  }
  _impl_.location_.SetAllocated(location, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.location_.IsDefault()) {
    _impl_.location_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.UserProfile.location)
}

// string website = 8;
inline void UserProfile::clear_website() {
  _impl_.website_.ClearToEmpty();
}
inline const std::string& UserProfile::website() const {
  // @@protoc_insertion_point(field_get:sonet.user.UserProfile.website)
  return _internal_website();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserProfile::set_website(ArgT0&& arg0, ArgT... args) {
 
 _impl_.website_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.UserProfile.website)
}
inline std::string* UserProfile::mutable_website() {
  std::string* _s = _internal_mutable_website();
  // @@protoc_insertion_point(field_mutable:sonet.user.UserProfile.website)
  return _s;
}
inline const std::string& UserProfile::_internal_website() const {
  return _impl_.website_.Get();
}
inline void UserProfile::_internal_set_website(const std::string& value) {
  
  _impl_.website_.Set(value, GetArenaForAllocation());
}
inline std::string* UserProfile::_internal_mutable_website() {
  
  return _impl_.website_.Mutable(GetArenaForAllocation());
}
inline std::string* UserProfile::release_website() {
  // @@protoc_insertion_point(field_release:sonet.user.UserProfile.website)
  return _impl_.website_.Release();
}
inline void UserProfile::set_allocated_website(std::string* website) {
  if (website != nullptr) {
    
  } else {
    
  }
  _impl_.website_.SetAllocated(website, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.website_.IsDefault()) {
    _impl_.website_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.UserProfile.website)
}

// .sonet.user.UserStatus status = 9;
inline void UserProfile::clear_status() {
  _impl_.status_ = 0;
}
inline ::sonet::user::UserStatus UserProfile::_internal_status() const {
  return static_cast< ::sonet::user::UserStatus >(_impl_.status_);
}
inline ::sonet::user::UserStatus UserProfile::status() const {
  // @@protoc_insertion_point(field_get:sonet.user.UserProfile.status)
  return _internal_status();
}
inline void UserProfile::_internal_set_status(::sonet::user::UserStatus value) {
  
  _impl_.status_ = value;
}
inline void UserProfile::set_status(::sonet::user::UserStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:sonet.user.UserProfile.status)
}

// bool is_verified = 10;
inline void UserProfile::clear_is_verified() {
  _impl_.is_verified_ = false;
}
inline bool UserProfile::_internal_is_verified() const {
  return _impl_.is_verified_;
}
inline bool UserProfile::is_verified() const {
  // @@protoc_insertion_point(field_get:sonet.user.UserProfile.is_verified)
  return _internal_is_verified();
}
inline void UserProfile::_internal_set_is_verified(bool value) {
  
  _impl_.is_verified_ = value;
}
inline void UserProfile::set_is_verified(bool value) {
  _internal_set_is_verified(value);
  // @@protoc_insertion_point(field_set:sonet.user.UserProfile.is_verified)
}

// bool is_private = 11;
inline void UserProfile::clear_is_private() {
  _impl_.is_private_ = false;
}
inline bool UserProfile::_internal_is_private() const {
  return _impl_.is_private_;
}
inline bool UserProfile::is_private() const {
  // @@protoc_insertion_point(field_get:sonet.user.UserProfile.is_private)
  return _internal_is_private();
}
inline void UserProfile::_internal_set_is_private(bool value) {
  
  _impl_.is_private_ = value;
}
inline void UserProfile::set_is_private(bool value) {
  _internal_set_is_private(value);
  // @@protoc_insertion_point(field_set:sonet.user.UserProfile.is_private)
}

// .sonet.common.Timestamp created_at = 12;
inline bool UserProfile::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool UserProfile::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::sonet::common::Timestamp& UserProfile::_internal_created_at() const {
  const ::sonet::common::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Timestamp&>(
      ::sonet::common::_Timestamp_default_instance_);
}
inline const ::sonet::common::Timestamp& UserProfile::created_at() const {
  // @@protoc_insertion_point(field_get:sonet.user.UserProfile.created_at)
  return _internal_created_at();
}
inline void UserProfile::unsafe_arena_set_allocated_created_at(
    ::sonet::common::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.user.UserProfile.created_at)
}
inline ::sonet::common::Timestamp* UserProfile::release_created_at() {
  
  ::sonet::common::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Timestamp* UserProfile::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:sonet.user.UserProfile.created_at)
  
  ::sonet::common::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::sonet::common::Timestamp* UserProfile::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::sonet::common::Timestamp* UserProfile::mutable_created_at() {
  ::sonet::common::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:sonet.user.UserProfile.created_at)
  return _msg;
}
inline void UserProfile::set_allocated_created_at(::sonet::common::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:sonet.user.UserProfile.created_at)
}

// .sonet.common.Timestamp updated_at = 13;
inline bool UserProfile::_internal_has_updated_at() const {
  return this != internal_default_instance() && _impl_.updated_at_ != nullptr;
}
inline bool UserProfile::has_updated_at() const {
  return _internal_has_updated_at();
}
inline const ::sonet::common::Timestamp& UserProfile::_internal_updated_at() const {
  const ::sonet::common::Timestamp* p = _impl_.updated_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Timestamp&>(
      ::sonet::common::_Timestamp_default_instance_);
}
inline const ::sonet::common::Timestamp& UserProfile::updated_at() const {
  // @@protoc_insertion_point(field_get:sonet.user.UserProfile.updated_at)
  return _internal_updated_at();
}
inline void UserProfile::unsafe_arena_set_allocated_updated_at(
    ::sonet::common::Timestamp* updated_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.updated_at_);
  }
  _impl_.updated_at_ = updated_at;
  if (updated_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.user.UserProfile.updated_at)
}
inline ::sonet::common::Timestamp* UserProfile::release_updated_at() {
  
  ::sonet::common::Timestamp* temp = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Timestamp* UserProfile::unsafe_arena_release_updated_at() {
  // @@protoc_insertion_point(field_release:sonet.user.UserProfile.updated_at)
  
  ::sonet::common::Timestamp* temp = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
  return temp;
}
inline ::sonet::common::Timestamp* UserProfile::_internal_mutable_updated_at() {
  
  if (_impl_.updated_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Timestamp>(GetArenaForAllocation());
    _impl_.updated_at_ = p;
  }
  return _impl_.updated_at_;
}
inline ::sonet::common::Timestamp* UserProfile::mutable_updated_at() {
  ::sonet::common::Timestamp* _msg = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:sonet.user.UserProfile.updated_at)
  return _msg;
}
inline void UserProfile::set_allocated_updated_at(::sonet::common::Timestamp* updated_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.updated_at_);
  }
  if (updated_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at));
    if (message_arena != submessage_arena) {
      updated_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, updated_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.updated_at_ = updated_at;
  // @@protoc_insertion_point(field_set_allocated:sonet.user.UserProfile.updated_at)
}

// .sonet.common.Timestamp last_login = 14;
inline bool UserProfile::_internal_has_last_login() const {
  return this != internal_default_instance() && _impl_.last_login_ != nullptr;
}
inline bool UserProfile::has_last_login() const {
  return _internal_has_last_login();
}
inline const ::sonet::common::Timestamp& UserProfile::_internal_last_login() const {
  const ::sonet::common::Timestamp* p = _impl_.last_login_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Timestamp&>(
      ::sonet::common::_Timestamp_default_instance_);
}
inline const ::sonet::common::Timestamp& UserProfile::last_login() const {
  // @@protoc_insertion_point(field_get:sonet.user.UserProfile.last_login)
  return _internal_last_login();
}
inline void UserProfile::unsafe_arena_set_allocated_last_login(
    ::sonet::common::Timestamp* last_login) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_login_);
  }
  _impl_.last_login_ = last_login;
  if (last_login) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.user.UserProfile.last_login)
}
inline ::sonet::common::Timestamp* UserProfile::release_last_login() {
  
  ::sonet::common::Timestamp* temp = _impl_.last_login_;
  _impl_.last_login_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Timestamp* UserProfile::unsafe_arena_release_last_login() {
  // @@protoc_insertion_point(field_release:sonet.user.UserProfile.last_login)
  
  ::sonet::common::Timestamp* temp = _impl_.last_login_;
  _impl_.last_login_ = nullptr;
  return temp;
}
inline ::sonet::common::Timestamp* UserProfile::_internal_mutable_last_login() {
  
  if (_impl_.last_login_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Timestamp>(GetArenaForAllocation());
    _impl_.last_login_ = p;
  }
  return _impl_.last_login_;
}
inline ::sonet::common::Timestamp* UserProfile::mutable_last_login() {
  ::sonet::common::Timestamp* _msg = _internal_mutable_last_login();
  // @@protoc_insertion_point(field_mutable:sonet.user.UserProfile.last_login)
  return _msg;
}
inline void UserProfile::set_allocated_last_login(::sonet::common::Timestamp* last_login) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_login_);
  }
  if (last_login) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_login));
    if (message_arena != submessage_arena) {
      last_login = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_login, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.last_login_ = last_login;
  // @@protoc_insertion_point(field_set_allocated:sonet.user.UserProfile.last_login)
}

// uint64 follower_count = 15;
inline void UserProfile::clear_follower_count() {
  _impl_.follower_count_ = uint64_t{0u};
}
inline uint64_t UserProfile::_internal_follower_count() const {
  return _impl_.follower_count_;
}
inline uint64_t UserProfile::follower_count() const {
  // @@protoc_insertion_point(field_get:sonet.user.UserProfile.follower_count)
  return _internal_follower_count();
}
inline void UserProfile::_internal_set_follower_count(uint64_t value) {
  
  _impl_.follower_count_ = value;
}
inline void UserProfile::set_follower_count(uint64_t value) {
  _internal_set_follower_count(value);
  // @@protoc_insertion_point(field_set:sonet.user.UserProfile.follower_count)
}

// uint64 following_count = 16;
inline void UserProfile::clear_following_count() {
  _impl_.following_count_ = uint64_t{0u};
}
inline uint64_t UserProfile::_internal_following_count() const {
  return _impl_.following_count_;
}
inline uint64_t UserProfile::following_count() const {
  // @@protoc_insertion_point(field_get:sonet.user.UserProfile.following_count)
  return _internal_following_count();
}
inline void UserProfile::_internal_set_following_count(uint64_t value) {
  
  _impl_.following_count_ = value;
}
inline void UserProfile::set_following_count(uint64_t value) {
  _internal_set_following_count(value);
  // @@protoc_insertion_point(field_set:sonet.user.UserProfile.following_count)
}

// uint64 note_count = 17;
inline void UserProfile::clear_note_count() {
  _impl_.note_count_ = uint64_t{0u};
}
inline uint64_t UserProfile::_internal_note_count() const {
  return _impl_.note_count_;
}
inline uint64_t UserProfile::note_count() const {
  // @@protoc_insertion_point(field_get:sonet.user.UserProfile.note_count)
  return _internal_note_count();
}
inline void UserProfile::_internal_set_note_count(uint64_t value) {
  
  _impl_.note_count_ = value;
}
inline void UserProfile::set_note_count(uint64_t value) {
  _internal_set_note_count(value);
  // @@protoc_insertion_point(field_set:sonet.user.UserProfile.note_count)
}

// map<string, string> settings = 18;
inline int UserProfile::_internal_settings_size() const {
  return _impl_.settings_.size();
}
inline int UserProfile::settings_size() const {
  return _internal_settings_size();
}
inline void UserProfile::clear_settings() {
  _impl_.settings_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
UserProfile::_internal_settings() const {
  return _impl_.settings_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
UserProfile::settings() const {
  // @@protoc_insertion_point(field_map:sonet.user.UserProfile.settings)
  return _internal_settings();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
UserProfile::_internal_mutable_settings() {
  return _impl_.settings_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
UserProfile::mutable_settings() {
  // @@protoc_insertion_point(field_mutable_map:sonet.user.UserProfile.settings)
  return _internal_mutable_settings();
}

// map<string, string> privacy_settings = 19;
inline int UserProfile::_internal_privacy_settings_size() const {
  return _impl_.privacy_settings_.size();
}
inline int UserProfile::privacy_settings_size() const {
  return _internal_privacy_settings_size();
}
inline void UserProfile::clear_privacy_settings() {
  _impl_.privacy_settings_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
UserProfile::_internal_privacy_settings() const {
  return _impl_.privacy_settings_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
UserProfile::privacy_settings() const {
  // @@protoc_insertion_point(field_map:sonet.user.UserProfile.privacy_settings)
  return _internal_privacy_settings();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
UserProfile::_internal_mutable_privacy_settings() {
  return _impl_.privacy_settings_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
UserProfile::mutable_privacy_settings() {
  // @@protoc_insertion_point(field_mutable_map:sonet.user.UserProfile.privacy_settings)
  return _internal_mutable_privacy_settings();
}

// -------------------------------------------------------------------

// AuthCredentials

// string email = 1;
inline void AuthCredentials::clear_email() {
  _impl_.email_.ClearToEmpty();
}
inline const std::string& AuthCredentials::email() const {
  // @@protoc_insertion_point(field_get:sonet.user.AuthCredentials.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthCredentials::set_email(ArgT0&& arg0, ArgT... args) {
 
 _impl_.email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.AuthCredentials.email)
}
inline std::string* AuthCredentials::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:sonet.user.AuthCredentials.email)
  return _s;
}
inline const std::string& AuthCredentials::_internal_email() const {
  return _impl_.email_.Get();
}
inline void AuthCredentials::_internal_set_email(const std::string& value) {
  
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthCredentials::_internal_mutable_email() {
  
  return _impl_.email_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthCredentials::release_email() {
  // @@protoc_insertion_point(field_release:sonet.user.AuthCredentials.email)
  return _impl_.email_.Release();
}
inline void AuthCredentials::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.AuthCredentials.email)
}

// string password = 2;
inline void AuthCredentials::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& AuthCredentials::password() const {
  // @@protoc_insertion_point(field_get:sonet.user.AuthCredentials.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthCredentials::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.AuthCredentials.password)
}
inline std::string* AuthCredentials::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:sonet.user.AuthCredentials.password)
  return _s;
}
inline const std::string& AuthCredentials::_internal_password() const {
  return _impl_.password_.Get();
}
inline void AuthCredentials::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthCredentials::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthCredentials::release_password() {
  // @@protoc_insertion_point(field_release:sonet.user.AuthCredentials.password)
  return _impl_.password_.Release();
}
inline void AuthCredentials::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.AuthCredentials.password)
}

// string two_factor_code = 3;
inline void AuthCredentials::clear_two_factor_code() {
  _impl_.two_factor_code_.ClearToEmpty();
}
inline const std::string& AuthCredentials::two_factor_code() const {
  // @@protoc_insertion_point(field_get:sonet.user.AuthCredentials.two_factor_code)
  return _internal_two_factor_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthCredentials::set_two_factor_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.two_factor_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.AuthCredentials.two_factor_code)
}
inline std::string* AuthCredentials::mutable_two_factor_code() {
  std::string* _s = _internal_mutable_two_factor_code();
  // @@protoc_insertion_point(field_mutable:sonet.user.AuthCredentials.two_factor_code)
  return _s;
}
inline const std::string& AuthCredentials::_internal_two_factor_code() const {
  return _impl_.two_factor_code_.Get();
}
inline void AuthCredentials::_internal_set_two_factor_code(const std::string& value) {
  
  _impl_.two_factor_code_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthCredentials::_internal_mutable_two_factor_code() {
  
  return _impl_.two_factor_code_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthCredentials::release_two_factor_code() {
  // @@protoc_insertion_point(field_release:sonet.user.AuthCredentials.two_factor_code)
  return _impl_.two_factor_code_.Release();
}
inline void AuthCredentials::set_allocated_two_factor_code(std::string* two_factor_code) {
  if (two_factor_code != nullptr) {
    
  } else {
    
  }
  _impl_.two_factor_code_.SetAllocated(two_factor_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.two_factor_code_.IsDefault()) {
    _impl_.two_factor_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.AuthCredentials.two_factor_code)
}

// -------------------------------------------------------------------

// Session

// string session_id = 1;
inline void Session::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& Session::session_id() const {
  // @@protoc_insertion_point(field_get:sonet.user.Session.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Session::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.Session.session_id)
}
inline std::string* Session::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:sonet.user.Session.session_id)
  return _s;
}
inline const std::string& Session::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void Session::_internal_set_session_id(const std::string& value) {
  
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Session::_internal_mutable_session_id() {
  
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Session::release_session_id() {
  // @@protoc_insertion_point(field_release:sonet.user.Session.session_id)
  return _impl_.session_id_.Release();
}
inline void Session::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.Session.session_id)
}

// string user_id = 2;
inline void Session::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& Session::user_id() const {
  // @@protoc_insertion_point(field_get:sonet.user.Session.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Session::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.Session.user_id)
}
inline std::string* Session::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:sonet.user.Session.user_id)
  return _s;
}
inline const std::string& Session::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void Session::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Session::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Session::release_user_id() {
  // @@protoc_insertion_point(field_release:sonet.user.Session.user_id)
  return _impl_.user_id_.Release();
}
inline void Session::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.Session.user_id)
}

// string device_id = 3;
inline void Session::clear_device_id() {
  _impl_.device_id_.ClearToEmpty();
}
inline const std::string& Session::device_id() const {
  // @@protoc_insertion_point(field_get:sonet.user.Session.device_id)
  return _internal_device_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Session::set_device_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.device_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.Session.device_id)
}
inline std::string* Session::mutable_device_id() {
  std::string* _s = _internal_mutable_device_id();
  // @@protoc_insertion_point(field_mutable:sonet.user.Session.device_id)
  return _s;
}
inline const std::string& Session::_internal_device_id() const {
  return _impl_.device_id_.Get();
}
inline void Session::_internal_set_device_id(const std::string& value) {
  
  _impl_.device_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Session::_internal_mutable_device_id() {
  
  return _impl_.device_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Session::release_device_id() {
  // @@protoc_insertion_point(field_release:sonet.user.Session.device_id)
  return _impl_.device_id_.Release();
}
inline void Session::set_allocated_device_id(std::string* device_id) {
  if (device_id != nullptr) {
    
  } else {
    
  }
  _impl_.device_id_.SetAllocated(device_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_id_.IsDefault()) {
    _impl_.device_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.Session.device_id)
}

// string device_name = 4;
inline void Session::clear_device_name() {
  _impl_.device_name_.ClearToEmpty();
}
inline const std::string& Session::device_name() const {
  // @@protoc_insertion_point(field_get:sonet.user.Session.device_name)
  return _internal_device_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Session::set_device_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.device_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.Session.device_name)
}
inline std::string* Session::mutable_device_name() {
  std::string* _s = _internal_mutable_device_name();
  // @@protoc_insertion_point(field_mutable:sonet.user.Session.device_name)
  return _s;
}
inline const std::string& Session::_internal_device_name() const {
  return _impl_.device_name_.Get();
}
inline void Session::_internal_set_device_name(const std::string& value) {
  
  _impl_.device_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Session::_internal_mutable_device_name() {
  
  return _impl_.device_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Session::release_device_name() {
  // @@protoc_insertion_point(field_release:sonet.user.Session.device_name)
  return _impl_.device_name_.Release();
}
inline void Session::set_allocated_device_name(std::string* device_name) {
  if (device_name != nullptr) {
    
  } else {
    
  }
  _impl_.device_name_.SetAllocated(device_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_name_.IsDefault()) {
    _impl_.device_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.Session.device_name)
}

// string ip_address = 5;
inline void Session::clear_ip_address() {
  _impl_.ip_address_.ClearToEmpty();
}
inline const std::string& Session::ip_address() const {
  // @@protoc_insertion_point(field_get:sonet.user.Session.ip_address)
  return _internal_ip_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Session::set_ip_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ip_address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.Session.ip_address)
}
inline std::string* Session::mutable_ip_address() {
  std::string* _s = _internal_mutable_ip_address();
  // @@protoc_insertion_point(field_mutable:sonet.user.Session.ip_address)
  return _s;
}
inline const std::string& Session::_internal_ip_address() const {
  return _impl_.ip_address_.Get();
}
inline void Session::_internal_set_ip_address(const std::string& value) {
  
  _impl_.ip_address_.Set(value, GetArenaForAllocation());
}
inline std::string* Session::_internal_mutable_ip_address() {
  
  return _impl_.ip_address_.Mutable(GetArenaForAllocation());
}
inline std::string* Session::release_ip_address() {
  // @@protoc_insertion_point(field_release:sonet.user.Session.ip_address)
  return _impl_.ip_address_.Release();
}
inline void Session::set_allocated_ip_address(std::string* ip_address) {
  if (ip_address != nullptr) {
    
  } else {
    
  }
  _impl_.ip_address_.SetAllocated(ip_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ip_address_.IsDefault()) {
    _impl_.ip_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.Session.ip_address)
}

// string user_agent = 6;
inline void Session::clear_user_agent() {
  _impl_.user_agent_.ClearToEmpty();
}
inline const std::string& Session::user_agent() const {
  // @@protoc_insertion_point(field_get:sonet.user.Session.user_agent)
  return _internal_user_agent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Session::set_user_agent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_agent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.Session.user_agent)
}
inline std::string* Session::mutable_user_agent() {
  std::string* _s = _internal_mutable_user_agent();
  // @@protoc_insertion_point(field_mutable:sonet.user.Session.user_agent)
  return _s;
}
inline const std::string& Session::_internal_user_agent() const {
  return _impl_.user_agent_.Get();
}
inline void Session::_internal_set_user_agent(const std::string& value) {
  
  _impl_.user_agent_.Set(value, GetArenaForAllocation());
}
inline std::string* Session::_internal_mutable_user_agent() {
  
  return _impl_.user_agent_.Mutable(GetArenaForAllocation());
}
inline std::string* Session::release_user_agent() {
  // @@protoc_insertion_point(field_release:sonet.user.Session.user_agent)
  return _impl_.user_agent_.Release();
}
inline void Session::set_allocated_user_agent(std::string* user_agent) {
  if (user_agent != nullptr) {
    
  } else {
    
  }
  _impl_.user_agent_.SetAllocated(user_agent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_agent_.IsDefault()) {
    _impl_.user_agent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.Session.user_agent)
}

// .sonet.user.SessionType type = 7;
inline void Session::clear_type() {
  _impl_.type_ = 0;
}
inline ::sonet::user::SessionType Session::_internal_type() const {
  return static_cast< ::sonet::user::SessionType >(_impl_.type_);
}
inline ::sonet::user::SessionType Session::type() const {
  // @@protoc_insertion_point(field_get:sonet.user.Session.type)
  return _internal_type();
}
inline void Session::_internal_set_type(::sonet::user::SessionType value) {
  
  _impl_.type_ = value;
}
inline void Session::set_type(::sonet::user::SessionType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sonet.user.Session.type)
}

// .sonet.common.Timestamp created_at = 8;
inline bool Session::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool Session::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::sonet::common::Timestamp& Session::_internal_created_at() const {
  const ::sonet::common::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Timestamp&>(
      ::sonet::common::_Timestamp_default_instance_);
}
inline const ::sonet::common::Timestamp& Session::created_at() const {
  // @@protoc_insertion_point(field_get:sonet.user.Session.created_at)
  return _internal_created_at();
}
inline void Session::unsafe_arena_set_allocated_created_at(
    ::sonet::common::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.user.Session.created_at)
}
inline ::sonet::common::Timestamp* Session::release_created_at() {
  
  ::sonet::common::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Timestamp* Session::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:sonet.user.Session.created_at)
  
  ::sonet::common::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::sonet::common::Timestamp* Session::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::sonet::common::Timestamp* Session::mutable_created_at() {
  ::sonet::common::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:sonet.user.Session.created_at)
  return _msg;
}
inline void Session::set_allocated_created_at(::sonet::common::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:sonet.user.Session.created_at)
}

// .sonet.common.Timestamp last_activity = 9;
inline bool Session::_internal_has_last_activity() const {
  return this != internal_default_instance() && _impl_.last_activity_ != nullptr;
}
inline bool Session::has_last_activity() const {
  return _internal_has_last_activity();
}
inline const ::sonet::common::Timestamp& Session::_internal_last_activity() const {
  const ::sonet::common::Timestamp* p = _impl_.last_activity_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Timestamp&>(
      ::sonet::common::_Timestamp_default_instance_);
}
inline const ::sonet::common::Timestamp& Session::last_activity() const {
  // @@protoc_insertion_point(field_get:sonet.user.Session.last_activity)
  return _internal_last_activity();
}
inline void Session::unsafe_arena_set_allocated_last_activity(
    ::sonet::common::Timestamp* last_activity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_activity_);
  }
  _impl_.last_activity_ = last_activity;
  if (last_activity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.user.Session.last_activity)
}
inline ::sonet::common::Timestamp* Session::release_last_activity() {
  
  ::sonet::common::Timestamp* temp = _impl_.last_activity_;
  _impl_.last_activity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Timestamp* Session::unsafe_arena_release_last_activity() {
  // @@protoc_insertion_point(field_release:sonet.user.Session.last_activity)
  
  ::sonet::common::Timestamp* temp = _impl_.last_activity_;
  _impl_.last_activity_ = nullptr;
  return temp;
}
inline ::sonet::common::Timestamp* Session::_internal_mutable_last_activity() {
  
  if (_impl_.last_activity_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Timestamp>(GetArenaForAllocation());
    _impl_.last_activity_ = p;
  }
  return _impl_.last_activity_;
}
inline ::sonet::common::Timestamp* Session::mutable_last_activity() {
  ::sonet::common::Timestamp* _msg = _internal_mutable_last_activity();
  // @@protoc_insertion_point(field_mutable:sonet.user.Session.last_activity)
  return _msg;
}
inline void Session::set_allocated_last_activity(::sonet::common::Timestamp* last_activity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_activity_);
  }
  if (last_activity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_activity));
    if (message_arena != submessage_arena) {
      last_activity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_activity, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.last_activity_ = last_activity;
  // @@protoc_insertion_point(field_set_allocated:sonet.user.Session.last_activity)
}

// .sonet.common.Timestamp expires_at = 10;
inline bool Session::_internal_has_expires_at() const {
  return this != internal_default_instance() && _impl_.expires_at_ != nullptr;
}
inline bool Session::has_expires_at() const {
  return _internal_has_expires_at();
}
inline const ::sonet::common::Timestamp& Session::_internal_expires_at() const {
  const ::sonet::common::Timestamp* p = _impl_.expires_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Timestamp&>(
      ::sonet::common::_Timestamp_default_instance_);
}
inline const ::sonet::common::Timestamp& Session::expires_at() const {
  // @@protoc_insertion_point(field_get:sonet.user.Session.expires_at)
  return _internal_expires_at();
}
inline void Session::unsafe_arena_set_allocated_expires_at(
    ::sonet::common::Timestamp* expires_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expires_at_);
  }
  _impl_.expires_at_ = expires_at;
  if (expires_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.user.Session.expires_at)
}
inline ::sonet::common::Timestamp* Session::release_expires_at() {
  
  ::sonet::common::Timestamp* temp = _impl_.expires_at_;
  _impl_.expires_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Timestamp* Session::unsafe_arena_release_expires_at() {
  // @@protoc_insertion_point(field_release:sonet.user.Session.expires_at)
  
  ::sonet::common::Timestamp* temp = _impl_.expires_at_;
  _impl_.expires_at_ = nullptr;
  return temp;
}
inline ::sonet::common::Timestamp* Session::_internal_mutable_expires_at() {
  
  if (_impl_.expires_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Timestamp>(GetArenaForAllocation());
    _impl_.expires_at_ = p;
  }
  return _impl_.expires_at_;
}
inline ::sonet::common::Timestamp* Session::mutable_expires_at() {
  ::sonet::common::Timestamp* _msg = _internal_mutable_expires_at();
  // @@protoc_insertion_point(field_mutable:sonet.user.Session.expires_at)
  return _msg;
}
inline void Session::set_allocated_expires_at(::sonet::common::Timestamp* expires_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expires_at_);
  }
  if (expires_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expires_at));
    if (message_arena != submessage_arena) {
      expires_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expires_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.expires_at_ = expires_at;
  // @@protoc_insertion_point(field_set_allocated:sonet.user.Session.expires_at)
}

// bool is_active = 11;
inline void Session::clear_is_active() {
  _impl_.is_active_ = false;
}
inline bool Session::_internal_is_active() const {
  return _impl_.is_active_;
}
inline bool Session::is_active() const {
  // @@protoc_insertion_point(field_get:sonet.user.Session.is_active)
  return _internal_is_active();
}
inline void Session::_internal_set_is_active(bool value) {
  
  _impl_.is_active_ = value;
}
inline void Session::set_is_active(bool value) {
  _internal_set_is_active(value);
  // @@protoc_insertion_point(field_set:sonet.user.Session.is_active)
}

// bool is_suspicious = 12;
inline void Session::clear_is_suspicious() {
  _impl_.is_suspicious_ = false;
}
inline bool Session::_internal_is_suspicious() const {
  return _impl_.is_suspicious_;
}
inline bool Session::is_suspicious() const {
  // @@protoc_insertion_point(field_get:sonet.user.Session.is_suspicious)
  return _internal_is_suspicious();
}
inline void Session::_internal_set_is_suspicious(bool value) {
  
  _impl_.is_suspicious_ = value;
}
inline void Session::set_is_suspicious(bool value) {
  _internal_set_is_suspicious(value);
  // @@protoc_insertion_point(field_set:sonet.user.Session.is_suspicious)
}

// string location_info = 13;
inline void Session::clear_location_info() {
  _impl_.location_info_.ClearToEmpty();
}
inline const std::string& Session::location_info() const {
  // @@protoc_insertion_point(field_get:sonet.user.Session.location_info)
  return _internal_location_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Session::set_location_info(ArgT0&& arg0, ArgT... args) {
 
 _impl_.location_info_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.Session.location_info)
}
inline std::string* Session::mutable_location_info() {
  std::string* _s = _internal_mutable_location_info();
  // @@protoc_insertion_point(field_mutable:sonet.user.Session.location_info)
  return _s;
}
inline const std::string& Session::_internal_location_info() const {
  return _impl_.location_info_.Get();
}
inline void Session::_internal_set_location_info(const std::string& value) {
  
  _impl_.location_info_.Set(value, GetArenaForAllocation());
}
inline std::string* Session::_internal_mutable_location_info() {
  
  return _impl_.location_info_.Mutable(GetArenaForAllocation());
}
inline std::string* Session::release_location_info() {
  // @@protoc_insertion_point(field_release:sonet.user.Session.location_info)
  return _impl_.location_info_.Release();
}
inline void Session::set_allocated_location_info(std::string* location_info) {
  if (location_info != nullptr) {
    
  } else {
    
  }
  _impl_.location_info_.SetAllocated(location_info, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.location_info_.IsDefault()) {
    _impl_.location_info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.Session.location_info)
}

// -------------------------------------------------------------------

// TwoFactorAuth

// string user_id = 1;
inline void TwoFactorAuth::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& TwoFactorAuth::user_id() const {
  // @@protoc_insertion_point(field_get:sonet.user.TwoFactorAuth.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TwoFactorAuth::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.TwoFactorAuth.user_id)
}
inline std::string* TwoFactorAuth::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:sonet.user.TwoFactorAuth.user_id)
  return _s;
}
inline const std::string& TwoFactorAuth::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void TwoFactorAuth::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TwoFactorAuth::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TwoFactorAuth::release_user_id() {
  // @@protoc_insertion_point(field_release:sonet.user.TwoFactorAuth.user_id)
  return _impl_.user_id_.Release();
}
inline void TwoFactorAuth::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.TwoFactorAuth.user_id)
}

// bool is_enabled = 2;
inline void TwoFactorAuth::clear_is_enabled() {
  _impl_.is_enabled_ = false;
}
inline bool TwoFactorAuth::_internal_is_enabled() const {
  return _impl_.is_enabled_;
}
inline bool TwoFactorAuth::is_enabled() const {
  // @@protoc_insertion_point(field_get:sonet.user.TwoFactorAuth.is_enabled)
  return _internal_is_enabled();
}
inline void TwoFactorAuth::_internal_set_is_enabled(bool value) {
  
  _impl_.is_enabled_ = value;
}
inline void TwoFactorAuth::set_is_enabled(bool value) {
  _internal_set_is_enabled(value);
  // @@protoc_insertion_point(field_set:sonet.user.TwoFactorAuth.is_enabled)
}

// string qr_code_url = 3;
inline void TwoFactorAuth::clear_qr_code_url() {
  _impl_.qr_code_url_.ClearToEmpty();
}
inline const std::string& TwoFactorAuth::qr_code_url() const {
  // @@protoc_insertion_point(field_get:sonet.user.TwoFactorAuth.qr_code_url)
  return _internal_qr_code_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TwoFactorAuth::set_qr_code_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.qr_code_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.TwoFactorAuth.qr_code_url)
}
inline std::string* TwoFactorAuth::mutable_qr_code_url() {
  std::string* _s = _internal_mutable_qr_code_url();
  // @@protoc_insertion_point(field_mutable:sonet.user.TwoFactorAuth.qr_code_url)
  return _s;
}
inline const std::string& TwoFactorAuth::_internal_qr_code_url() const {
  return _impl_.qr_code_url_.Get();
}
inline void TwoFactorAuth::_internal_set_qr_code_url(const std::string& value) {
  
  _impl_.qr_code_url_.Set(value, GetArenaForAllocation());
}
inline std::string* TwoFactorAuth::_internal_mutable_qr_code_url() {
  
  return _impl_.qr_code_url_.Mutable(GetArenaForAllocation());
}
inline std::string* TwoFactorAuth::release_qr_code_url() {
  // @@protoc_insertion_point(field_release:sonet.user.TwoFactorAuth.qr_code_url)
  return _impl_.qr_code_url_.Release();
}
inline void TwoFactorAuth::set_allocated_qr_code_url(std::string* qr_code_url) {
  if (qr_code_url != nullptr) {
    
  } else {
    
  }
  _impl_.qr_code_url_.SetAllocated(qr_code_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.qr_code_url_.IsDefault()) {
    _impl_.qr_code_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.TwoFactorAuth.qr_code_url)
}

// repeated string backup_codes = 4;
inline int TwoFactorAuth::_internal_backup_codes_size() const {
  return _impl_.backup_codes_.size();
}
inline int TwoFactorAuth::backup_codes_size() const {
  return _internal_backup_codes_size();
}
inline void TwoFactorAuth::clear_backup_codes() {
  _impl_.backup_codes_.Clear();
}
inline std::string* TwoFactorAuth::add_backup_codes() {
  std::string* _s = _internal_add_backup_codes();
  // @@protoc_insertion_point(field_add_mutable:sonet.user.TwoFactorAuth.backup_codes)
  return _s;
}
inline const std::string& TwoFactorAuth::_internal_backup_codes(int index) const {
  return _impl_.backup_codes_.Get(index);
}
inline const std::string& TwoFactorAuth::backup_codes(int index) const {
  // @@protoc_insertion_point(field_get:sonet.user.TwoFactorAuth.backup_codes)
  return _internal_backup_codes(index);
}
inline std::string* TwoFactorAuth::mutable_backup_codes(int index) {
  // @@protoc_insertion_point(field_mutable:sonet.user.TwoFactorAuth.backup_codes)
  return _impl_.backup_codes_.Mutable(index);
}
inline void TwoFactorAuth::set_backup_codes(int index, const std::string& value) {
  _impl_.backup_codes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sonet.user.TwoFactorAuth.backup_codes)
}
inline void TwoFactorAuth::set_backup_codes(int index, std::string&& value) {
  _impl_.backup_codes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sonet.user.TwoFactorAuth.backup_codes)
}
inline void TwoFactorAuth::set_backup_codes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.backup_codes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sonet.user.TwoFactorAuth.backup_codes)
}
inline void TwoFactorAuth::set_backup_codes(int index, const char* value, size_t size) {
  _impl_.backup_codes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sonet.user.TwoFactorAuth.backup_codes)
}
inline std::string* TwoFactorAuth::_internal_add_backup_codes() {
  return _impl_.backup_codes_.Add();
}
inline void TwoFactorAuth::add_backup_codes(const std::string& value) {
  _impl_.backup_codes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sonet.user.TwoFactorAuth.backup_codes)
}
inline void TwoFactorAuth::add_backup_codes(std::string&& value) {
  _impl_.backup_codes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sonet.user.TwoFactorAuth.backup_codes)
}
inline void TwoFactorAuth::add_backup_codes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.backup_codes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sonet.user.TwoFactorAuth.backup_codes)
}
inline void TwoFactorAuth::add_backup_codes(const char* value, size_t size) {
  _impl_.backup_codes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sonet.user.TwoFactorAuth.backup_codes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TwoFactorAuth::backup_codes() const {
  // @@protoc_insertion_point(field_list:sonet.user.TwoFactorAuth.backup_codes)
  return _impl_.backup_codes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TwoFactorAuth::mutable_backup_codes() {
  // @@protoc_insertion_point(field_mutable_list:sonet.user.TwoFactorAuth.backup_codes)
  return &_impl_.backup_codes_;
}

// .sonet.common.Timestamp setup_at = 5;
inline bool TwoFactorAuth::_internal_has_setup_at() const {
  return this != internal_default_instance() && _impl_.setup_at_ != nullptr;
}
inline bool TwoFactorAuth::has_setup_at() const {
  return _internal_has_setup_at();
}
inline const ::sonet::common::Timestamp& TwoFactorAuth::_internal_setup_at() const {
  const ::sonet::common::Timestamp* p = _impl_.setup_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Timestamp&>(
      ::sonet::common::_Timestamp_default_instance_);
}
inline const ::sonet::common::Timestamp& TwoFactorAuth::setup_at() const {
  // @@protoc_insertion_point(field_get:sonet.user.TwoFactorAuth.setup_at)
  return _internal_setup_at();
}
inline void TwoFactorAuth::unsafe_arena_set_allocated_setup_at(
    ::sonet::common::Timestamp* setup_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.setup_at_);
  }
  _impl_.setup_at_ = setup_at;
  if (setup_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.user.TwoFactorAuth.setup_at)
}
inline ::sonet::common::Timestamp* TwoFactorAuth::release_setup_at() {
  
  ::sonet::common::Timestamp* temp = _impl_.setup_at_;
  _impl_.setup_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Timestamp* TwoFactorAuth::unsafe_arena_release_setup_at() {
  // @@protoc_insertion_point(field_release:sonet.user.TwoFactorAuth.setup_at)
  
  ::sonet::common::Timestamp* temp = _impl_.setup_at_;
  _impl_.setup_at_ = nullptr;
  return temp;
}
inline ::sonet::common::Timestamp* TwoFactorAuth::_internal_mutable_setup_at() {
  
  if (_impl_.setup_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Timestamp>(GetArenaForAllocation());
    _impl_.setup_at_ = p;
  }
  return _impl_.setup_at_;
}
inline ::sonet::common::Timestamp* TwoFactorAuth::mutable_setup_at() {
  ::sonet::common::Timestamp* _msg = _internal_mutable_setup_at();
  // @@protoc_insertion_point(field_mutable:sonet.user.TwoFactorAuth.setup_at)
  return _msg;
}
inline void TwoFactorAuth::set_allocated_setup_at(::sonet::common::Timestamp* setup_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.setup_at_);
  }
  if (setup_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(setup_at));
    if (message_arena != submessage_arena) {
      setup_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, setup_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.setup_at_ = setup_at;
  // @@protoc_insertion_point(field_set_allocated:sonet.user.TwoFactorAuth.setup_at)
}

// -------------------------------------------------------------------

// RegisterUserRequest

// string username = 1;
inline void RegisterUserRequest::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& RegisterUserRequest::username() const {
  // @@protoc_insertion_point(field_get:sonet.user.RegisterUserRequest.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterUserRequest::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.RegisterUserRequest.username)
}
inline std::string* RegisterUserRequest::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:sonet.user.RegisterUserRequest.username)
  return _s;
}
inline const std::string& RegisterUserRequest::_internal_username() const {
  return _impl_.username_.Get();
}
inline void RegisterUserRequest::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterUserRequest::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterUserRequest::release_username() {
  // @@protoc_insertion_point(field_release:sonet.user.RegisterUserRequest.username)
  return _impl_.username_.Release();
}
inline void RegisterUserRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.RegisterUserRequest.username)
}

// string email = 2;
inline void RegisterUserRequest::clear_email() {
  _impl_.email_.ClearToEmpty();
}
inline const std::string& RegisterUserRequest::email() const {
  // @@protoc_insertion_point(field_get:sonet.user.RegisterUserRequest.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterUserRequest::set_email(ArgT0&& arg0, ArgT... args) {
 
 _impl_.email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.RegisterUserRequest.email)
}
inline std::string* RegisterUserRequest::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:sonet.user.RegisterUserRequest.email)
  return _s;
}
inline const std::string& RegisterUserRequest::_internal_email() const {
  return _impl_.email_.Get();
}
inline void RegisterUserRequest::_internal_set_email(const std::string& value) {
  
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterUserRequest::_internal_mutable_email() {
  
  return _impl_.email_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterUserRequest::release_email() {
  // @@protoc_insertion_point(field_release:sonet.user.RegisterUserRequest.email)
  return _impl_.email_.Release();
}
inline void RegisterUserRequest::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.RegisterUserRequest.email)
}

// string password = 3;
inline void RegisterUserRequest::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& RegisterUserRequest::password() const {
  // @@protoc_insertion_point(field_get:sonet.user.RegisterUserRequest.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterUserRequest::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.RegisterUserRequest.password)
}
inline std::string* RegisterUserRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:sonet.user.RegisterUserRequest.password)
  return _s;
}
inline const std::string& RegisterUserRequest::_internal_password() const {
  return _impl_.password_.Get();
}
inline void RegisterUserRequest::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterUserRequest::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterUserRequest::release_password() {
  // @@protoc_insertion_point(field_release:sonet.user.RegisterUserRequest.password)
  return _impl_.password_.Release();
}
inline void RegisterUserRequest::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.RegisterUserRequest.password)
}

// string display_name = 4;
inline void RegisterUserRequest::clear_display_name() {
  _impl_.display_name_.ClearToEmpty();
}
inline const std::string& RegisterUserRequest::display_name() const {
  // @@protoc_insertion_point(field_get:sonet.user.RegisterUserRequest.display_name)
  return _internal_display_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterUserRequest::set_display_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.display_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.RegisterUserRequest.display_name)
}
inline std::string* RegisterUserRequest::mutable_display_name() {
  std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:sonet.user.RegisterUserRequest.display_name)
  return _s;
}
inline const std::string& RegisterUserRequest::_internal_display_name() const {
  return _impl_.display_name_.Get();
}
inline void RegisterUserRequest::_internal_set_display_name(const std::string& value) {
  
  _impl_.display_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterUserRequest::_internal_mutable_display_name() {
  
  return _impl_.display_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterUserRequest::release_display_name() {
  // @@protoc_insertion_point(field_release:sonet.user.RegisterUserRequest.display_name)
  return _impl_.display_name_.Release();
}
inline void RegisterUserRequest::set_allocated_display_name(std::string* display_name) {
  if (display_name != nullptr) {
    
  } else {
    
  }
  _impl_.display_name_.SetAllocated(display_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.display_name_.IsDefault()) {
    _impl_.display_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.RegisterUserRequest.display_name)
}

// string invitation_code = 5;
inline void RegisterUserRequest::clear_invitation_code() {
  _impl_.invitation_code_.ClearToEmpty();
}
inline const std::string& RegisterUserRequest::invitation_code() const {
  // @@protoc_insertion_point(field_get:sonet.user.RegisterUserRequest.invitation_code)
  return _internal_invitation_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterUserRequest::set_invitation_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.invitation_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.RegisterUserRequest.invitation_code)
}
inline std::string* RegisterUserRequest::mutable_invitation_code() {
  std::string* _s = _internal_mutable_invitation_code();
  // @@protoc_insertion_point(field_mutable:sonet.user.RegisterUserRequest.invitation_code)
  return _s;
}
inline const std::string& RegisterUserRequest::_internal_invitation_code() const {
  return _impl_.invitation_code_.Get();
}
inline void RegisterUserRequest::_internal_set_invitation_code(const std::string& value) {
  
  _impl_.invitation_code_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterUserRequest::_internal_mutable_invitation_code() {
  
  return _impl_.invitation_code_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterUserRequest::release_invitation_code() {
  // @@protoc_insertion_point(field_release:sonet.user.RegisterUserRequest.invitation_code)
  return _impl_.invitation_code_.Release();
}
inline void RegisterUserRequest::set_allocated_invitation_code(std::string* invitation_code) {
  if (invitation_code != nullptr) {
    
  } else {
    
  }
  _impl_.invitation_code_.SetAllocated(invitation_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.invitation_code_.IsDefault()) {
    _impl_.invitation_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.RegisterUserRequest.invitation_code)
}

// bool accept_terms = 6;
inline void RegisterUserRequest::clear_accept_terms() {
  _impl_.accept_terms_ = false;
}
inline bool RegisterUserRequest::_internal_accept_terms() const {
  return _impl_.accept_terms_;
}
inline bool RegisterUserRequest::accept_terms() const {
  // @@protoc_insertion_point(field_get:sonet.user.RegisterUserRequest.accept_terms)
  return _internal_accept_terms();
}
inline void RegisterUserRequest::_internal_set_accept_terms(bool value) {
  
  _impl_.accept_terms_ = value;
}
inline void RegisterUserRequest::set_accept_terms(bool value) {
  _internal_set_accept_terms(value);
  // @@protoc_insertion_point(field_set:sonet.user.RegisterUserRequest.accept_terms)
}

// bool accept_privacy = 7;
inline void RegisterUserRequest::clear_accept_privacy() {
  _impl_.accept_privacy_ = false;
}
inline bool RegisterUserRequest::_internal_accept_privacy() const {
  return _impl_.accept_privacy_;
}
inline bool RegisterUserRequest::accept_privacy() const {
  // @@protoc_insertion_point(field_get:sonet.user.RegisterUserRequest.accept_privacy)
  return _internal_accept_privacy();
}
inline void RegisterUserRequest::_internal_set_accept_privacy(bool value) {
  
  _impl_.accept_privacy_ = value;
}
inline void RegisterUserRequest::set_accept_privacy(bool value) {
  _internal_set_accept_privacy(value);
  // @@protoc_insertion_point(field_set:sonet.user.RegisterUserRequest.accept_privacy)
}

// -------------------------------------------------------------------

// RegisterUserResponse

// .sonet.common.Status status = 1;
inline bool RegisterUserResponse::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool RegisterUserResponse::has_status() const {
  return _internal_has_status();
}
inline const ::sonet::common::Status& RegisterUserResponse::_internal_status() const {
  const ::sonet::common::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Status&>(
      ::sonet::common::_Status_default_instance_);
}
inline const ::sonet::common::Status& RegisterUserResponse::status() const {
  // @@protoc_insertion_point(field_get:sonet.user.RegisterUserResponse.status)
  return _internal_status();
}
inline void RegisterUserResponse::unsafe_arena_set_allocated_status(
    ::sonet::common::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.user.RegisterUserResponse.status)
}
inline ::sonet::common::Status* RegisterUserResponse::release_status() {
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Status* RegisterUserResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:sonet.user.RegisterUserResponse.status)
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::sonet::common::Status* RegisterUserResponse::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::sonet::common::Status* RegisterUserResponse::mutable_status() {
  ::sonet::common::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:sonet.user.RegisterUserResponse.status)
  return _msg;
}
inline void RegisterUserResponse::set_allocated_status(::sonet::common::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:sonet.user.RegisterUserResponse.status)
}

// .sonet.user.UserProfile user = 2;
inline bool RegisterUserResponse::_internal_has_user() const {
  return this != internal_default_instance() && _impl_.user_ != nullptr;
}
inline bool RegisterUserResponse::has_user() const {
  return _internal_has_user();
}
inline void RegisterUserResponse::clear_user() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_ != nullptr) {
    delete _impl_.user_;
  }
  _impl_.user_ = nullptr;
}
inline const ::sonet::user::UserProfile& RegisterUserResponse::_internal_user() const {
  const ::sonet::user::UserProfile* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::user::UserProfile&>(
      ::sonet::user::_UserProfile_default_instance_);
}
inline const ::sonet::user::UserProfile& RegisterUserResponse::user() const {
  // @@protoc_insertion_point(field_get:sonet.user.RegisterUserResponse.user)
  return _internal_user();
}
inline void RegisterUserResponse::unsafe_arena_set_allocated_user(
    ::sonet::user::UserProfile* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.user.RegisterUserResponse.user)
}
inline ::sonet::user::UserProfile* RegisterUserResponse::release_user() {
  
  ::sonet::user::UserProfile* temp = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::user::UserProfile* RegisterUserResponse::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:sonet.user.RegisterUserResponse.user)
  
  ::sonet::user::UserProfile* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::sonet::user::UserProfile* RegisterUserResponse::_internal_mutable_user() {
  
  if (_impl_.user_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::user::UserProfile>(GetArenaForAllocation());
    _impl_.user_ = p;
  }
  return _impl_.user_;
}
inline ::sonet::user::UserProfile* RegisterUserResponse::mutable_user() {
  ::sonet::user::UserProfile* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:sonet.user.RegisterUserResponse.user)
  return _msg;
}
inline void RegisterUserResponse::set_allocated_user(::sonet::user::UserProfile* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_ = user;
  // @@protoc_insertion_point(field_set_allocated:sonet.user.RegisterUserResponse.user)
}

// string verification_token = 3;
inline void RegisterUserResponse::clear_verification_token() {
  _impl_.verification_token_.ClearToEmpty();
}
inline const std::string& RegisterUserResponse::verification_token() const {
  // @@protoc_insertion_point(field_get:sonet.user.RegisterUserResponse.verification_token)
  return _internal_verification_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterUserResponse::set_verification_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.verification_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.RegisterUserResponse.verification_token)
}
inline std::string* RegisterUserResponse::mutable_verification_token() {
  std::string* _s = _internal_mutable_verification_token();
  // @@protoc_insertion_point(field_mutable:sonet.user.RegisterUserResponse.verification_token)
  return _s;
}
inline const std::string& RegisterUserResponse::_internal_verification_token() const {
  return _impl_.verification_token_.Get();
}
inline void RegisterUserResponse::_internal_set_verification_token(const std::string& value) {
  
  _impl_.verification_token_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterUserResponse::_internal_mutable_verification_token() {
  
  return _impl_.verification_token_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterUserResponse::release_verification_token() {
  // @@protoc_insertion_point(field_release:sonet.user.RegisterUserResponse.verification_token)
  return _impl_.verification_token_.Release();
}
inline void RegisterUserResponse::set_allocated_verification_token(std::string* verification_token) {
  if (verification_token != nullptr) {
    
  } else {
    
  }
  _impl_.verification_token_.SetAllocated(verification_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.verification_token_.IsDefault()) {
    _impl_.verification_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.RegisterUserResponse.verification_token)
}

// -------------------------------------------------------------------

// LoginUserRequest

// .sonet.user.AuthCredentials credentials = 1;
inline bool LoginUserRequest::_internal_has_credentials() const {
  return this != internal_default_instance() && _impl_.credentials_ != nullptr;
}
inline bool LoginUserRequest::has_credentials() const {
  return _internal_has_credentials();
}
inline void LoginUserRequest::clear_credentials() {
  if (GetArenaForAllocation() == nullptr && _impl_.credentials_ != nullptr) {
    delete _impl_.credentials_;
  }
  _impl_.credentials_ = nullptr;
}
inline const ::sonet::user::AuthCredentials& LoginUserRequest::_internal_credentials() const {
  const ::sonet::user::AuthCredentials* p = _impl_.credentials_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::user::AuthCredentials&>(
      ::sonet::user::_AuthCredentials_default_instance_);
}
inline const ::sonet::user::AuthCredentials& LoginUserRequest::credentials() const {
  // @@protoc_insertion_point(field_get:sonet.user.LoginUserRequest.credentials)
  return _internal_credentials();
}
inline void LoginUserRequest::unsafe_arena_set_allocated_credentials(
    ::sonet::user::AuthCredentials* credentials) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.credentials_);
  }
  _impl_.credentials_ = credentials;
  if (credentials) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.user.LoginUserRequest.credentials)
}
inline ::sonet::user::AuthCredentials* LoginUserRequest::release_credentials() {
  
  ::sonet::user::AuthCredentials* temp = _impl_.credentials_;
  _impl_.credentials_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::user::AuthCredentials* LoginUserRequest::unsafe_arena_release_credentials() {
  // @@protoc_insertion_point(field_release:sonet.user.LoginUserRequest.credentials)
  
  ::sonet::user::AuthCredentials* temp = _impl_.credentials_;
  _impl_.credentials_ = nullptr;
  return temp;
}
inline ::sonet::user::AuthCredentials* LoginUserRequest::_internal_mutable_credentials() {
  
  if (_impl_.credentials_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::user::AuthCredentials>(GetArenaForAllocation());
    _impl_.credentials_ = p;
  }
  return _impl_.credentials_;
}
inline ::sonet::user::AuthCredentials* LoginUserRequest::mutable_credentials() {
  ::sonet::user::AuthCredentials* _msg = _internal_mutable_credentials();
  // @@protoc_insertion_point(field_mutable:sonet.user.LoginUserRequest.credentials)
  return _msg;
}
inline void LoginUserRequest::set_allocated_credentials(::sonet::user::AuthCredentials* credentials) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.credentials_;
  }
  if (credentials) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(credentials);
    if (message_arena != submessage_arena) {
      credentials = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, credentials, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.credentials_ = credentials;
  // @@protoc_insertion_point(field_set_allocated:sonet.user.LoginUserRequest.credentials)
}

// string device_name = 2;
inline void LoginUserRequest::clear_device_name() {
  _impl_.device_name_.ClearToEmpty();
}
inline const std::string& LoginUserRequest::device_name() const {
  // @@protoc_insertion_point(field_get:sonet.user.LoginUserRequest.device_name)
  return _internal_device_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginUserRequest::set_device_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.device_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.LoginUserRequest.device_name)
}
inline std::string* LoginUserRequest::mutable_device_name() {
  std::string* _s = _internal_mutable_device_name();
  // @@protoc_insertion_point(field_mutable:sonet.user.LoginUserRequest.device_name)
  return _s;
}
inline const std::string& LoginUserRequest::_internal_device_name() const {
  return _impl_.device_name_.Get();
}
inline void LoginUserRequest::_internal_set_device_name(const std::string& value) {
  
  _impl_.device_name_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginUserRequest::_internal_mutable_device_name() {
  
  return _impl_.device_name_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginUserRequest::release_device_name() {
  // @@protoc_insertion_point(field_release:sonet.user.LoginUserRequest.device_name)
  return _impl_.device_name_.Release();
}
inline void LoginUserRequest::set_allocated_device_name(std::string* device_name) {
  if (device_name != nullptr) {
    
  } else {
    
  }
  _impl_.device_name_.SetAllocated(device_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_name_.IsDefault()) {
    _impl_.device_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.LoginUserRequest.device_name)
}

// -------------------------------------------------------------------

// LoginUserResponse

// .sonet.common.Status status = 1;
inline bool LoginUserResponse::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool LoginUserResponse::has_status() const {
  return _internal_has_status();
}
inline const ::sonet::common::Status& LoginUserResponse::_internal_status() const {
  const ::sonet::common::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Status&>(
      ::sonet::common::_Status_default_instance_);
}
inline const ::sonet::common::Status& LoginUserResponse::status() const {
  // @@protoc_insertion_point(field_get:sonet.user.LoginUserResponse.status)
  return _internal_status();
}
inline void LoginUserResponse::unsafe_arena_set_allocated_status(
    ::sonet::common::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.user.LoginUserResponse.status)
}
inline ::sonet::common::Status* LoginUserResponse::release_status() {
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Status* LoginUserResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:sonet.user.LoginUserResponse.status)
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::sonet::common::Status* LoginUserResponse::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::sonet::common::Status* LoginUserResponse::mutable_status() {
  ::sonet::common::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:sonet.user.LoginUserResponse.status)
  return _msg;
}
inline void LoginUserResponse::set_allocated_status(::sonet::common::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:sonet.user.LoginUserResponse.status)
}

// string access_token = 2;
inline void LoginUserResponse::clear_access_token() {
  _impl_.access_token_.ClearToEmpty();
}
inline const std::string& LoginUserResponse::access_token() const {
  // @@protoc_insertion_point(field_get:sonet.user.LoginUserResponse.access_token)
  return _internal_access_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginUserResponse::set_access_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.access_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.LoginUserResponse.access_token)
}
inline std::string* LoginUserResponse::mutable_access_token() {
  std::string* _s = _internal_mutable_access_token();
  // @@protoc_insertion_point(field_mutable:sonet.user.LoginUserResponse.access_token)
  return _s;
}
inline const std::string& LoginUserResponse::_internal_access_token() const {
  return _impl_.access_token_.Get();
}
inline void LoginUserResponse::_internal_set_access_token(const std::string& value) {
  
  _impl_.access_token_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginUserResponse::_internal_mutable_access_token() {
  
  return _impl_.access_token_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginUserResponse::release_access_token() {
  // @@protoc_insertion_point(field_release:sonet.user.LoginUserResponse.access_token)
  return _impl_.access_token_.Release();
}
inline void LoginUserResponse::set_allocated_access_token(std::string* access_token) {
  if (access_token != nullptr) {
    
  } else {
    
  }
  _impl_.access_token_.SetAllocated(access_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.access_token_.IsDefault()) {
    _impl_.access_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.LoginUserResponse.access_token)
}

// string refresh_token = 3;
inline void LoginUserResponse::clear_refresh_token() {
  _impl_.refresh_token_.ClearToEmpty();
}
inline const std::string& LoginUserResponse::refresh_token() const {
  // @@protoc_insertion_point(field_get:sonet.user.LoginUserResponse.refresh_token)
  return _internal_refresh_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginUserResponse::set_refresh_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.refresh_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.LoginUserResponse.refresh_token)
}
inline std::string* LoginUserResponse::mutable_refresh_token() {
  std::string* _s = _internal_mutable_refresh_token();
  // @@protoc_insertion_point(field_mutable:sonet.user.LoginUserResponse.refresh_token)
  return _s;
}
inline const std::string& LoginUserResponse::_internal_refresh_token() const {
  return _impl_.refresh_token_.Get();
}
inline void LoginUserResponse::_internal_set_refresh_token(const std::string& value) {
  
  _impl_.refresh_token_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginUserResponse::_internal_mutable_refresh_token() {
  
  return _impl_.refresh_token_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginUserResponse::release_refresh_token() {
  // @@protoc_insertion_point(field_release:sonet.user.LoginUserResponse.refresh_token)
  return _impl_.refresh_token_.Release();
}
inline void LoginUserResponse::set_allocated_refresh_token(std::string* refresh_token) {
  if (refresh_token != nullptr) {
    
  } else {
    
  }
  _impl_.refresh_token_.SetAllocated(refresh_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.refresh_token_.IsDefault()) {
    _impl_.refresh_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.LoginUserResponse.refresh_token)
}

// int32 expires_in = 4;
inline void LoginUserResponse::clear_expires_in() {
  _impl_.expires_in_ = 0;
}
inline int32_t LoginUserResponse::_internal_expires_in() const {
  return _impl_.expires_in_;
}
inline int32_t LoginUserResponse::expires_in() const {
  // @@protoc_insertion_point(field_get:sonet.user.LoginUserResponse.expires_in)
  return _internal_expires_in();
}
inline void LoginUserResponse::_internal_set_expires_in(int32_t value) {
  
  _impl_.expires_in_ = value;
}
inline void LoginUserResponse::set_expires_in(int32_t value) {
  _internal_set_expires_in(value);
  // @@protoc_insertion_point(field_set:sonet.user.LoginUserResponse.expires_in)
}

// .sonet.user.Session session = 5;
inline bool LoginUserResponse::_internal_has_session() const {
  return this != internal_default_instance() && _impl_.session_ != nullptr;
}
inline bool LoginUserResponse::has_session() const {
  return _internal_has_session();
}
inline void LoginUserResponse::clear_session() {
  if (GetArenaForAllocation() == nullptr && _impl_.session_ != nullptr) {
    delete _impl_.session_;
  }
  _impl_.session_ = nullptr;
}
inline const ::sonet::user::Session& LoginUserResponse::_internal_session() const {
  const ::sonet::user::Session* p = _impl_.session_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::user::Session&>(
      ::sonet::user::_Session_default_instance_);
}
inline const ::sonet::user::Session& LoginUserResponse::session() const {
  // @@protoc_insertion_point(field_get:sonet.user.LoginUserResponse.session)
  return _internal_session();
}
inline void LoginUserResponse::unsafe_arena_set_allocated_session(
    ::sonet::user::Session* session) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.session_);
  }
  _impl_.session_ = session;
  if (session) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.user.LoginUserResponse.session)
}
inline ::sonet::user::Session* LoginUserResponse::release_session() {
  
  ::sonet::user::Session* temp = _impl_.session_;
  _impl_.session_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::user::Session* LoginUserResponse::unsafe_arena_release_session() {
  // @@protoc_insertion_point(field_release:sonet.user.LoginUserResponse.session)
  
  ::sonet::user::Session* temp = _impl_.session_;
  _impl_.session_ = nullptr;
  return temp;
}
inline ::sonet::user::Session* LoginUserResponse::_internal_mutable_session() {
  
  if (_impl_.session_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::user::Session>(GetArenaForAllocation());
    _impl_.session_ = p;
  }
  return _impl_.session_;
}
inline ::sonet::user::Session* LoginUserResponse::mutable_session() {
  ::sonet::user::Session* _msg = _internal_mutable_session();
  // @@protoc_insertion_point(field_mutable:sonet.user.LoginUserResponse.session)
  return _msg;
}
inline void LoginUserResponse::set_allocated_session(::sonet::user::Session* session) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.session_;
  }
  if (session) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(session);
    if (message_arena != submessage_arena) {
      session = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, session, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.session_ = session;
  // @@protoc_insertion_point(field_set_allocated:sonet.user.LoginUserResponse.session)
}

// bool requires_2fa = 6;
inline void LoginUserResponse::clear_requires_2fa() {
  _impl_.requires_2fa_ = false;
}
inline bool LoginUserResponse::_internal_requires_2fa() const {
  return _impl_.requires_2fa_;
}
inline bool LoginUserResponse::requires_2fa() const {
  // @@protoc_insertion_point(field_get:sonet.user.LoginUserResponse.requires_2fa)
  return _internal_requires_2fa();
}
inline void LoginUserResponse::_internal_set_requires_2fa(bool value) {
  
  _impl_.requires_2fa_ = value;
}
inline void LoginUserResponse::set_requires_2fa(bool value) {
  _internal_set_requires_2fa(value);
  // @@protoc_insertion_point(field_set:sonet.user.LoginUserResponse.requires_2fa)
}

// -------------------------------------------------------------------

// VerifyTokenRequest

// string token = 1;
inline void VerifyTokenRequest::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& VerifyTokenRequest::token() const {
  // @@protoc_insertion_point(field_get:sonet.user.VerifyTokenRequest.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VerifyTokenRequest::set_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.VerifyTokenRequest.token)
}
inline std::string* VerifyTokenRequest::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:sonet.user.VerifyTokenRequest.token)
  return _s;
}
inline const std::string& VerifyTokenRequest::_internal_token() const {
  return _impl_.token_.Get();
}
inline void VerifyTokenRequest::_internal_set_token(const std::string& value) {
  
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* VerifyTokenRequest::_internal_mutable_token() {
  
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* VerifyTokenRequest::release_token() {
  // @@protoc_insertion_point(field_release:sonet.user.VerifyTokenRequest.token)
  return _impl_.token_.Release();
}
inline void VerifyTokenRequest::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.VerifyTokenRequest.token)
}

// -------------------------------------------------------------------

// VerifyTokenResponse

// .sonet.common.Status status = 1;
inline bool VerifyTokenResponse::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool VerifyTokenResponse::has_status() const {
  return _internal_has_status();
}
inline const ::sonet::common::Status& VerifyTokenResponse::_internal_status() const {
  const ::sonet::common::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Status&>(
      ::sonet::common::_Status_default_instance_);
}
inline const ::sonet::common::Status& VerifyTokenResponse::status() const {
  // @@protoc_insertion_point(field_get:sonet.user.VerifyTokenResponse.status)
  return _internal_status();
}
inline void VerifyTokenResponse::unsafe_arena_set_allocated_status(
    ::sonet::common::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.user.VerifyTokenResponse.status)
}
inline ::sonet::common::Status* VerifyTokenResponse::release_status() {
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Status* VerifyTokenResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:sonet.user.VerifyTokenResponse.status)
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::sonet::common::Status* VerifyTokenResponse::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::sonet::common::Status* VerifyTokenResponse::mutable_status() {
  ::sonet::common::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:sonet.user.VerifyTokenResponse.status)
  return _msg;
}
inline void VerifyTokenResponse::set_allocated_status(::sonet::common::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:sonet.user.VerifyTokenResponse.status)
}

// .sonet.user.UserProfile user = 2;
inline bool VerifyTokenResponse::_internal_has_user() const {
  return this != internal_default_instance() && _impl_.user_ != nullptr;
}
inline bool VerifyTokenResponse::has_user() const {
  return _internal_has_user();
}
inline void VerifyTokenResponse::clear_user() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_ != nullptr) {
    delete _impl_.user_;
  }
  _impl_.user_ = nullptr;
}
inline const ::sonet::user::UserProfile& VerifyTokenResponse::_internal_user() const {
  const ::sonet::user::UserProfile* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::user::UserProfile&>(
      ::sonet::user::_UserProfile_default_instance_);
}
inline const ::sonet::user::UserProfile& VerifyTokenResponse::user() const {
  // @@protoc_insertion_point(field_get:sonet.user.VerifyTokenResponse.user)
  return _internal_user();
}
inline void VerifyTokenResponse::unsafe_arena_set_allocated_user(
    ::sonet::user::UserProfile* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.user.VerifyTokenResponse.user)
}
inline ::sonet::user::UserProfile* VerifyTokenResponse::release_user() {
  
  ::sonet::user::UserProfile* temp = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::user::UserProfile* VerifyTokenResponse::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:sonet.user.VerifyTokenResponse.user)
  
  ::sonet::user::UserProfile* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::sonet::user::UserProfile* VerifyTokenResponse::_internal_mutable_user() {
  
  if (_impl_.user_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::user::UserProfile>(GetArenaForAllocation());
    _impl_.user_ = p;
  }
  return _impl_.user_;
}
inline ::sonet::user::UserProfile* VerifyTokenResponse::mutable_user() {
  ::sonet::user::UserProfile* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:sonet.user.VerifyTokenResponse.user)
  return _msg;
}
inline void VerifyTokenResponse::set_allocated_user(::sonet::user::UserProfile* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_ = user;
  // @@protoc_insertion_point(field_set_allocated:sonet.user.VerifyTokenResponse.user)
}

// .sonet.user.Session session = 3;
inline bool VerifyTokenResponse::_internal_has_session() const {
  return this != internal_default_instance() && _impl_.session_ != nullptr;
}
inline bool VerifyTokenResponse::has_session() const {
  return _internal_has_session();
}
inline void VerifyTokenResponse::clear_session() {
  if (GetArenaForAllocation() == nullptr && _impl_.session_ != nullptr) {
    delete _impl_.session_;
  }
  _impl_.session_ = nullptr;
}
inline const ::sonet::user::Session& VerifyTokenResponse::_internal_session() const {
  const ::sonet::user::Session* p = _impl_.session_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::user::Session&>(
      ::sonet::user::_Session_default_instance_);
}
inline const ::sonet::user::Session& VerifyTokenResponse::session() const {
  // @@protoc_insertion_point(field_get:sonet.user.VerifyTokenResponse.session)
  return _internal_session();
}
inline void VerifyTokenResponse::unsafe_arena_set_allocated_session(
    ::sonet::user::Session* session) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.session_);
  }
  _impl_.session_ = session;
  if (session) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.user.VerifyTokenResponse.session)
}
inline ::sonet::user::Session* VerifyTokenResponse::release_session() {
  
  ::sonet::user::Session* temp = _impl_.session_;
  _impl_.session_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::user::Session* VerifyTokenResponse::unsafe_arena_release_session() {
  // @@protoc_insertion_point(field_release:sonet.user.VerifyTokenResponse.session)
  
  ::sonet::user::Session* temp = _impl_.session_;
  _impl_.session_ = nullptr;
  return temp;
}
inline ::sonet::user::Session* VerifyTokenResponse::_internal_mutable_session() {
  
  if (_impl_.session_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::user::Session>(GetArenaForAllocation());
    _impl_.session_ = p;
  }
  return _impl_.session_;
}
inline ::sonet::user::Session* VerifyTokenResponse::mutable_session() {
  ::sonet::user::Session* _msg = _internal_mutable_session();
  // @@protoc_insertion_point(field_mutable:sonet.user.VerifyTokenResponse.session)
  return _msg;
}
inline void VerifyTokenResponse::set_allocated_session(::sonet::user::Session* session) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.session_;
  }
  if (session) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(session);
    if (message_arena != submessage_arena) {
      session = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, session, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.session_ = session;
  // @@protoc_insertion_point(field_set_allocated:sonet.user.VerifyTokenResponse.session)
}

// -------------------------------------------------------------------

// RefreshTokenRequest

// string refresh_token = 1;
inline void RefreshTokenRequest::clear_refresh_token() {
  _impl_.refresh_token_.ClearToEmpty();
}
inline const std::string& RefreshTokenRequest::refresh_token() const {
  // @@protoc_insertion_point(field_get:sonet.user.RefreshTokenRequest.refresh_token)
  return _internal_refresh_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RefreshTokenRequest::set_refresh_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.refresh_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.RefreshTokenRequest.refresh_token)
}
inline std::string* RefreshTokenRequest::mutable_refresh_token() {
  std::string* _s = _internal_mutable_refresh_token();
  // @@protoc_insertion_point(field_mutable:sonet.user.RefreshTokenRequest.refresh_token)
  return _s;
}
inline const std::string& RefreshTokenRequest::_internal_refresh_token() const {
  return _impl_.refresh_token_.Get();
}
inline void RefreshTokenRequest::_internal_set_refresh_token(const std::string& value) {
  
  _impl_.refresh_token_.Set(value, GetArenaForAllocation());
}
inline std::string* RefreshTokenRequest::_internal_mutable_refresh_token() {
  
  return _impl_.refresh_token_.Mutable(GetArenaForAllocation());
}
inline std::string* RefreshTokenRequest::release_refresh_token() {
  // @@protoc_insertion_point(field_release:sonet.user.RefreshTokenRequest.refresh_token)
  return _impl_.refresh_token_.Release();
}
inline void RefreshTokenRequest::set_allocated_refresh_token(std::string* refresh_token) {
  if (refresh_token != nullptr) {
    
  } else {
    
  }
  _impl_.refresh_token_.SetAllocated(refresh_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.refresh_token_.IsDefault()) {
    _impl_.refresh_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.RefreshTokenRequest.refresh_token)
}

// -------------------------------------------------------------------

// RefreshTokenResponse

// .sonet.common.Status status = 1;
inline bool RefreshTokenResponse::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool RefreshTokenResponse::has_status() const {
  return _internal_has_status();
}
inline const ::sonet::common::Status& RefreshTokenResponse::_internal_status() const {
  const ::sonet::common::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Status&>(
      ::sonet::common::_Status_default_instance_);
}
inline const ::sonet::common::Status& RefreshTokenResponse::status() const {
  // @@protoc_insertion_point(field_get:sonet.user.RefreshTokenResponse.status)
  return _internal_status();
}
inline void RefreshTokenResponse::unsafe_arena_set_allocated_status(
    ::sonet::common::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.user.RefreshTokenResponse.status)
}
inline ::sonet::common::Status* RefreshTokenResponse::release_status() {
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Status* RefreshTokenResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:sonet.user.RefreshTokenResponse.status)
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::sonet::common::Status* RefreshTokenResponse::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::sonet::common::Status* RefreshTokenResponse::mutable_status() {
  ::sonet::common::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:sonet.user.RefreshTokenResponse.status)
  return _msg;
}
inline void RefreshTokenResponse::set_allocated_status(::sonet::common::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:sonet.user.RefreshTokenResponse.status)
}

// string access_token = 2;
inline void RefreshTokenResponse::clear_access_token() {
  _impl_.access_token_.ClearToEmpty();
}
inline const std::string& RefreshTokenResponse::access_token() const {
  // @@protoc_insertion_point(field_get:sonet.user.RefreshTokenResponse.access_token)
  return _internal_access_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RefreshTokenResponse::set_access_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.access_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.RefreshTokenResponse.access_token)
}
inline std::string* RefreshTokenResponse::mutable_access_token() {
  std::string* _s = _internal_mutable_access_token();
  // @@protoc_insertion_point(field_mutable:sonet.user.RefreshTokenResponse.access_token)
  return _s;
}
inline const std::string& RefreshTokenResponse::_internal_access_token() const {
  return _impl_.access_token_.Get();
}
inline void RefreshTokenResponse::_internal_set_access_token(const std::string& value) {
  
  _impl_.access_token_.Set(value, GetArenaForAllocation());
}
inline std::string* RefreshTokenResponse::_internal_mutable_access_token() {
  
  return _impl_.access_token_.Mutable(GetArenaForAllocation());
}
inline std::string* RefreshTokenResponse::release_access_token() {
  // @@protoc_insertion_point(field_release:sonet.user.RefreshTokenResponse.access_token)
  return _impl_.access_token_.Release();
}
inline void RefreshTokenResponse::set_allocated_access_token(std::string* access_token) {
  if (access_token != nullptr) {
    
  } else {
    
  }
  _impl_.access_token_.SetAllocated(access_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.access_token_.IsDefault()) {
    _impl_.access_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.RefreshTokenResponse.access_token)
}

// int32 expires_in = 3;
inline void RefreshTokenResponse::clear_expires_in() {
  _impl_.expires_in_ = 0;
}
inline int32_t RefreshTokenResponse::_internal_expires_in() const {
  return _impl_.expires_in_;
}
inline int32_t RefreshTokenResponse::expires_in() const {
  // @@protoc_insertion_point(field_get:sonet.user.RefreshTokenResponse.expires_in)
  return _internal_expires_in();
}
inline void RefreshTokenResponse::_internal_set_expires_in(int32_t value) {
  
  _impl_.expires_in_ = value;
}
inline void RefreshTokenResponse::set_expires_in(int32_t value) {
  _internal_set_expires_in(value);
  // @@protoc_insertion_point(field_set:sonet.user.RefreshTokenResponse.expires_in)
}

// -------------------------------------------------------------------

// LogoutRequest

// string session_id = 1;
inline void LogoutRequest::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& LogoutRequest::session_id() const {
  // @@protoc_insertion_point(field_get:sonet.user.LogoutRequest.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogoutRequest::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.LogoutRequest.session_id)
}
inline std::string* LogoutRequest::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:sonet.user.LogoutRequest.session_id)
  return _s;
}
inline const std::string& LogoutRequest::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void LogoutRequest::_internal_set_session_id(const std::string& value) {
  
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* LogoutRequest::_internal_mutable_session_id() {
  
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* LogoutRequest::release_session_id() {
  // @@protoc_insertion_point(field_release:sonet.user.LogoutRequest.session_id)
  return _impl_.session_id_.Release();
}
inline void LogoutRequest::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.LogoutRequest.session_id)
}

// bool logout_all_devices = 2;
inline void LogoutRequest::clear_logout_all_devices() {
  _impl_.logout_all_devices_ = false;
}
inline bool LogoutRequest::_internal_logout_all_devices() const {
  return _impl_.logout_all_devices_;
}
inline bool LogoutRequest::logout_all_devices() const {
  // @@protoc_insertion_point(field_get:sonet.user.LogoutRequest.logout_all_devices)
  return _internal_logout_all_devices();
}
inline void LogoutRequest::_internal_set_logout_all_devices(bool value) {
  
  _impl_.logout_all_devices_ = value;
}
inline void LogoutRequest::set_logout_all_devices(bool value) {
  _internal_set_logout_all_devices(value);
  // @@protoc_insertion_point(field_set:sonet.user.LogoutRequest.logout_all_devices)
}

// -------------------------------------------------------------------

// LogoutResponse

// .sonet.common.Status status = 1;
inline bool LogoutResponse::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool LogoutResponse::has_status() const {
  return _internal_has_status();
}
inline const ::sonet::common::Status& LogoutResponse::_internal_status() const {
  const ::sonet::common::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Status&>(
      ::sonet::common::_Status_default_instance_);
}
inline const ::sonet::common::Status& LogoutResponse::status() const {
  // @@protoc_insertion_point(field_get:sonet.user.LogoutResponse.status)
  return _internal_status();
}
inline void LogoutResponse::unsafe_arena_set_allocated_status(
    ::sonet::common::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.user.LogoutResponse.status)
}
inline ::sonet::common::Status* LogoutResponse::release_status() {
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Status* LogoutResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:sonet.user.LogoutResponse.status)
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::sonet::common::Status* LogoutResponse::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::sonet::common::Status* LogoutResponse::mutable_status() {
  ::sonet::common::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:sonet.user.LogoutResponse.status)
  return _msg;
}
inline void LogoutResponse::set_allocated_status(::sonet::common::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:sonet.user.LogoutResponse.status)
}

// -------------------------------------------------------------------

// ChangePasswordRequest

// string old_password = 1;
inline void ChangePasswordRequest::clear_old_password() {
  _impl_.old_password_.ClearToEmpty();
}
inline const std::string& ChangePasswordRequest::old_password() const {
  // @@protoc_insertion_point(field_get:sonet.user.ChangePasswordRequest.old_password)
  return _internal_old_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangePasswordRequest::set_old_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.old_password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.ChangePasswordRequest.old_password)
}
inline std::string* ChangePasswordRequest::mutable_old_password() {
  std::string* _s = _internal_mutable_old_password();
  // @@protoc_insertion_point(field_mutable:sonet.user.ChangePasswordRequest.old_password)
  return _s;
}
inline const std::string& ChangePasswordRequest::_internal_old_password() const {
  return _impl_.old_password_.Get();
}
inline void ChangePasswordRequest::_internal_set_old_password(const std::string& value) {
  
  _impl_.old_password_.Set(value, GetArenaForAllocation());
}
inline std::string* ChangePasswordRequest::_internal_mutable_old_password() {
  
  return _impl_.old_password_.Mutable(GetArenaForAllocation());
}
inline std::string* ChangePasswordRequest::release_old_password() {
  // @@protoc_insertion_point(field_release:sonet.user.ChangePasswordRequest.old_password)
  return _impl_.old_password_.Release();
}
inline void ChangePasswordRequest::set_allocated_old_password(std::string* old_password) {
  if (old_password != nullptr) {
    
  } else {
    
  }
  _impl_.old_password_.SetAllocated(old_password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.old_password_.IsDefault()) {
    _impl_.old_password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.ChangePasswordRequest.old_password)
}

// string new_password = 2;
inline void ChangePasswordRequest::clear_new_password() {
  _impl_.new_password_.ClearToEmpty();
}
inline const std::string& ChangePasswordRequest::new_password() const {
  // @@protoc_insertion_point(field_get:sonet.user.ChangePasswordRequest.new_password)
  return _internal_new_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangePasswordRequest::set_new_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.new_password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.ChangePasswordRequest.new_password)
}
inline std::string* ChangePasswordRequest::mutable_new_password() {
  std::string* _s = _internal_mutable_new_password();
  // @@protoc_insertion_point(field_mutable:sonet.user.ChangePasswordRequest.new_password)
  return _s;
}
inline const std::string& ChangePasswordRequest::_internal_new_password() const {
  return _impl_.new_password_.Get();
}
inline void ChangePasswordRequest::_internal_set_new_password(const std::string& value) {
  
  _impl_.new_password_.Set(value, GetArenaForAllocation());
}
inline std::string* ChangePasswordRequest::_internal_mutable_new_password() {
  
  return _impl_.new_password_.Mutable(GetArenaForAllocation());
}
inline std::string* ChangePasswordRequest::release_new_password() {
  // @@protoc_insertion_point(field_release:sonet.user.ChangePasswordRequest.new_password)
  return _impl_.new_password_.Release();
}
inline void ChangePasswordRequest::set_allocated_new_password(std::string* new_password) {
  if (new_password != nullptr) {
    
  } else {
    
  }
  _impl_.new_password_.SetAllocated(new_password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_password_.IsDefault()) {
    _impl_.new_password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.ChangePasswordRequest.new_password)
}

// -------------------------------------------------------------------

// ChangePasswordResponse

// .sonet.common.Status status = 1;
inline bool ChangePasswordResponse::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool ChangePasswordResponse::has_status() const {
  return _internal_has_status();
}
inline const ::sonet::common::Status& ChangePasswordResponse::_internal_status() const {
  const ::sonet::common::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Status&>(
      ::sonet::common::_Status_default_instance_);
}
inline const ::sonet::common::Status& ChangePasswordResponse::status() const {
  // @@protoc_insertion_point(field_get:sonet.user.ChangePasswordResponse.status)
  return _internal_status();
}
inline void ChangePasswordResponse::unsafe_arena_set_allocated_status(
    ::sonet::common::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.user.ChangePasswordResponse.status)
}
inline ::sonet::common::Status* ChangePasswordResponse::release_status() {
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Status* ChangePasswordResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:sonet.user.ChangePasswordResponse.status)
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::sonet::common::Status* ChangePasswordResponse::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::sonet::common::Status* ChangePasswordResponse::mutable_status() {
  ::sonet::common::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:sonet.user.ChangePasswordResponse.status)
  return _msg;
}
inline void ChangePasswordResponse::set_allocated_status(::sonet::common::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:sonet.user.ChangePasswordResponse.status)
}

// -------------------------------------------------------------------

// ResetPasswordRequest

// string email = 1;
inline void ResetPasswordRequest::clear_email() {
  _impl_.email_.ClearToEmpty();
}
inline const std::string& ResetPasswordRequest::email() const {
  // @@protoc_insertion_point(field_get:sonet.user.ResetPasswordRequest.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResetPasswordRequest::set_email(ArgT0&& arg0, ArgT... args) {
 
 _impl_.email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.ResetPasswordRequest.email)
}
inline std::string* ResetPasswordRequest::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:sonet.user.ResetPasswordRequest.email)
  return _s;
}
inline const std::string& ResetPasswordRequest::_internal_email() const {
  return _impl_.email_.Get();
}
inline void ResetPasswordRequest::_internal_set_email(const std::string& value) {
  
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* ResetPasswordRequest::_internal_mutable_email() {
  
  return _impl_.email_.Mutable(GetArenaForAllocation());
}
inline std::string* ResetPasswordRequest::release_email() {
  // @@protoc_insertion_point(field_release:sonet.user.ResetPasswordRequest.email)
  return _impl_.email_.Release();
}
inline void ResetPasswordRequest::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.ResetPasswordRequest.email)
}

// -------------------------------------------------------------------

// ResetPasswordResponse

// .sonet.common.Status status = 1;
inline bool ResetPasswordResponse::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool ResetPasswordResponse::has_status() const {
  return _internal_has_status();
}
inline const ::sonet::common::Status& ResetPasswordResponse::_internal_status() const {
  const ::sonet::common::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Status&>(
      ::sonet::common::_Status_default_instance_);
}
inline const ::sonet::common::Status& ResetPasswordResponse::status() const {
  // @@protoc_insertion_point(field_get:sonet.user.ResetPasswordResponse.status)
  return _internal_status();
}
inline void ResetPasswordResponse::unsafe_arena_set_allocated_status(
    ::sonet::common::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.user.ResetPasswordResponse.status)
}
inline ::sonet::common::Status* ResetPasswordResponse::release_status() {
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Status* ResetPasswordResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:sonet.user.ResetPasswordResponse.status)
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::sonet::common::Status* ResetPasswordResponse::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::sonet::common::Status* ResetPasswordResponse::mutable_status() {
  ::sonet::common::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:sonet.user.ResetPasswordResponse.status)
  return _msg;
}
inline void ResetPasswordResponse::set_allocated_status(::sonet::common::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:sonet.user.ResetPasswordResponse.status)
}

// string reset_token = 2;
inline void ResetPasswordResponse::clear_reset_token() {
  _impl_.reset_token_.ClearToEmpty();
}
inline const std::string& ResetPasswordResponse::reset_token() const {
  // @@protoc_insertion_point(field_get:sonet.user.ResetPasswordResponse.reset_token)
  return _internal_reset_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResetPasswordResponse::set_reset_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.reset_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.ResetPasswordResponse.reset_token)
}
inline std::string* ResetPasswordResponse::mutable_reset_token() {
  std::string* _s = _internal_mutable_reset_token();
  // @@protoc_insertion_point(field_mutable:sonet.user.ResetPasswordResponse.reset_token)
  return _s;
}
inline const std::string& ResetPasswordResponse::_internal_reset_token() const {
  return _impl_.reset_token_.Get();
}
inline void ResetPasswordResponse::_internal_set_reset_token(const std::string& value) {
  
  _impl_.reset_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ResetPasswordResponse::_internal_mutable_reset_token() {
  
  return _impl_.reset_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ResetPasswordResponse::release_reset_token() {
  // @@protoc_insertion_point(field_release:sonet.user.ResetPasswordResponse.reset_token)
  return _impl_.reset_token_.Release();
}
inline void ResetPasswordResponse::set_allocated_reset_token(std::string* reset_token) {
  if (reset_token != nullptr) {
    
  } else {
    
  }
  _impl_.reset_token_.SetAllocated(reset_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reset_token_.IsDefault()) {
    _impl_.reset_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.ResetPasswordResponse.reset_token)
}

// -------------------------------------------------------------------

// ConfirmPasswordResetRequest

// string reset_token = 1;
inline void ConfirmPasswordResetRequest::clear_reset_token() {
  _impl_.reset_token_.ClearToEmpty();
}
inline const std::string& ConfirmPasswordResetRequest::reset_token() const {
  // @@protoc_insertion_point(field_get:sonet.user.ConfirmPasswordResetRequest.reset_token)
  return _internal_reset_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfirmPasswordResetRequest::set_reset_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.reset_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.ConfirmPasswordResetRequest.reset_token)
}
inline std::string* ConfirmPasswordResetRequest::mutable_reset_token() {
  std::string* _s = _internal_mutable_reset_token();
  // @@protoc_insertion_point(field_mutable:sonet.user.ConfirmPasswordResetRequest.reset_token)
  return _s;
}
inline const std::string& ConfirmPasswordResetRequest::_internal_reset_token() const {
  return _impl_.reset_token_.Get();
}
inline void ConfirmPasswordResetRequest::_internal_set_reset_token(const std::string& value) {
  
  _impl_.reset_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfirmPasswordResetRequest::_internal_mutable_reset_token() {
  
  return _impl_.reset_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfirmPasswordResetRequest::release_reset_token() {
  // @@protoc_insertion_point(field_release:sonet.user.ConfirmPasswordResetRequest.reset_token)
  return _impl_.reset_token_.Release();
}
inline void ConfirmPasswordResetRequest::set_allocated_reset_token(std::string* reset_token) {
  if (reset_token != nullptr) {
    
  } else {
    
  }
  _impl_.reset_token_.SetAllocated(reset_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reset_token_.IsDefault()) {
    _impl_.reset_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.ConfirmPasswordResetRequest.reset_token)
}

// string new_password = 2;
inline void ConfirmPasswordResetRequest::clear_new_password() {
  _impl_.new_password_.ClearToEmpty();
}
inline const std::string& ConfirmPasswordResetRequest::new_password() const {
  // @@protoc_insertion_point(field_get:sonet.user.ConfirmPasswordResetRequest.new_password)
  return _internal_new_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfirmPasswordResetRequest::set_new_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.new_password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.ConfirmPasswordResetRequest.new_password)
}
inline std::string* ConfirmPasswordResetRequest::mutable_new_password() {
  std::string* _s = _internal_mutable_new_password();
  // @@protoc_insertion_point(field_mutable:sonet.user.ConfirmPasswordResetRequest.new_password)
  return _s;
}
inline const std::string& ConfirmPasswordResetRequest::_internal_new_password() const {
  return _impl_.new_password_.Get();
}
inline void ConfirmPasswordResetRequest::_internal_set_new_password(const std::string& value) {
  
  _impl_.new_password_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfirmPasswordResetRequest::_internal_mutable_new_password() {
  
  return _impl_.new_password_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfirmPasswordResetRequest::release_new_password() {
  // @@protoc_insertion_point(field_release:sonet.user.ConfirmPasswordResetRequest.new_password)
  return _impl_.new_password_.Release();
}
inline void ConfirmPasswordResetRequest::set_allocated_new_password(std::string* new_password) {
  if (new_password != nullptr) {
    
  } else {
    
  }
  _impl_.new_password_.SetAllocated(new_password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_password_.IsDefault()) {
    _impl_.new_password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.ConfirmPasswordResetRequest.new_password)
}

// -------------------------------------------------------------------

// ConfirmPasswordResetResponse

// .sonet.common.Status status = 1;
inline bool ConfirmPasswordResetResponse::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool ConfirmPasswordResetResponse::has_status() const {
  return _internal_has_status();
}
inline const ::sonet::common::Status& ConfirmPasswordResetResponse::_internal_status() const {
  const ::sonet::common::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Status&>(
      ::sonet::common::_Status_default_instance_);
}
inline const ::sonet::common::Status& ConfirmPasswordResetResponse::status() const {
  // @@protoc_insertion_point(field_get:sonet.user.ConfirmPasswordResetResponse.status)
  return _internal_status();
}
inline void ConfirmPasswordResetResponse::unsafe_arena_set_allocated_status(
    ::sonet::common::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.user.ConfirmPasswordResetResponse.status)
}
inline ::sonet::common::Status* ConfirmPasswordResetResponse::release_status() {
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Status* ConfirmPasswordResetResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:sonet.user.ConfirmPasswordResetResponse.status)
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::sonet::common::Status* ConfirmPasswordResetResponse::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::sonet::common::Status* ConfirmPasswordResetResponse::mutable_status() {
  ::sonet::common::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:sonet.user.ConfirmPasswordResetResponse.status)
  return _msg;
}
inline void ConfirmPasswordResetResponse::set_allocated_status(::sonet::common::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:sonet.user.ConfirmPasswordResetResponse.status)
}

// -------------------------------------------------------------------

// VerifyEmailRequest

// string verification_token = 1;
inline void VerifyEmailRequest::clear_verification_token() {
  _impl_.verification_token_.ClearToEmpty();
}
inline const std::string& VerifyEmailRequest::verification_token() const {
  // @@protoc_insertion_point(field_get:sonet.user.VerifyEmailRequest.verification_token)
  return _internal_verification_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VerifyEmailRequest::set_verification_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.verification_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.VerifyEmailRequest.verification_token)
}
inline std::string* VerifyEmailRequest::mutable_verification_token() {
  std::string* _s = _internal_mutable_verification_token();
  // @@protoc_insertion_point(field_mutable:sonet.user.VerifyEmailRequest.verification_token)
  return _s;
}
inline const std::string& VerifyEmailRequest::_internal_verification_token() const {
  return _impl_.verification_token_.Get();
}
inline void VerifyEmailRequest::_internal_set_verification_token(const std::string& value) {
  
  _impl_.verification_token_.Set(value, GetArenaForAllocation());
}
inline std::string* VerifyEmailRequest::_internal_mutable_verification_token() {
  
  return _impl_.verification_token_.Mutable(GetArenaForAllocation());
}
inline std::string* VerifyEmailRequest::release_verification_token() {
  // @@protoc_insertion_point(field_release:sonet.user.VerifyEmailRequest.verification_token)
  return _impl_.verification_token_.Release();
}
inline void VerifyEmailRequest::set_allocated_verification_token(std::string* verification_token) {
  if (verification_token != nullptr) {
    
  } else {
    
  }
  _impl_.verification_token_.SetAllocated(verification_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.verification_token_.IsDefault()) {
    _impl_.verification_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.VerifyEmailRequest.verification_token)
}

// -------------------------------------------------------------------

// VerifyEmailResponse

// .sonet.common.Status status = 1;
inline bool VerifyEmailResponse::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool VerifyEmailResponse::has_status() const {
  return _internal_has_status();
}
inline const ::sonet::common::Status& VerifyEmailResponse::_internal_status() const {
  const ::sonet::common::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Status&>(
      ::sonet::common::_Status_default_instance_);
}
inline const ::sonet::common::Status& VerifyEmailResponse::status() const {
  // @@protoc_insertion_point(field_get:sonet.user.VerifyEmailResponse.status)
  return _internal_status();
}
inline void VerifyEmailResponse::unsafe_arena_set_allocated_status(
    ::sonet::common::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.user.VerifyEmailResponse.status)
}
inline ::sonet::common::Status* VerifyEmailResponse::release_status() {
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Status* VerifyEmailResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:sonet.user.VerifyEmailResponse.status)
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::sonet::common::Status* VerifyEmailResponse::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::sonet::common::Status* VerifyEmailResponse::mutable_status() {
  ::sonet::common::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:sonet.user.VerifyEmailResponse.status)
  return _msg;
}
inline void VerifyEmailResponse::set_allocated_status(::sonet::common::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:sonet.user.VerifyEmailResponse.status)
}

// -------------------------------------------------------------------

// ResendVerificationRequest

// string email = 1;
inline void ResendVerificationRequest::clear_email() {
  _impl_.email_.ClearToEmpty();
}
inline const std::string& ResendVerificationRequest::email() const {
  // @@protoc_insertion_point(field_get:sonet.user.ResendVerificationRequest.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResendVerificationRequest::set_email(ArgT0&& arg0, ArgT... args) {
 
 _impl_.email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.ResendVerificationRequest.email)
}
inline std::string* ResendVerificationRequest::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:sonet.user.ResendVerificationRequest.email)
  return _s;
}
inline const std::string& ResendVerificationRequest::_internal_email() const {
  return _impl_.email_.Get();
}
inline void ResendVerificationRequest::_internal_set_email(const std::string& value) {
  
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* ResendVerificationRequest::_internal_mutable_email() {
  
  return _impl_.email_.Mutable(GetArenaForAllocation());
}
inline std::string* ResendVerificationRequest::release_email() {
  // @@protoc_insertion_point(field_release:sonet.user.ResendVerificationRequest.email)
  return _impl_.email_.Release();
}
inline void ResendVerificationRequest::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.ResendVerificationRequest.email)
}

// -------------------------------------------------------------------

// ResendVerificationResponse

// .sonet.common.Status status = 1;
inline bool ResendVerificationResponse::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool ResendVerificationResponse::has_status() const {
  return _internal_has_status();
}
inline const ::sonet::common::Status& ResendVerificationResponse::_internal_status() const {
  const ::sonet::common::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Status&>(
      ::sonet::common::_Status_default_instance_);
}
inline const ::sonet::common::Status& ResendVerificationResponse::status() const {
  // @@protoc_insertion_point(field_get:sonet.user.ResendVerificationResponse.status)
  return _internal_status();
}
inline void ResendVerificationResponse::unsafe_arena_set_allocated_status(
    ::sonet::common::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.user.ResendVerificationResponse.status)
}
inline ::sonet::common::Status* ResendVerificationResponse::release_status() {
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Status* ResendVerificationResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:sonet.user.ResendVerificationResponse.status)
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::sonet::common::Status* ResendVerificationResponse::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::sonet::common::Status* ResendVerificationResponse::mutable_status() {
  ::sonet::common::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:sonet.user.ResendVerificationResponse.status)
  return _msg;
}
inline void ResendVerificationResponse::set_allocated_status(::sonet::common::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:sonet.user.ResendVerificationResponse.status)
}

// -------------------------------------------------------------------

// SetupTwoFactorRequest

// string user_id = 1;
inline void SetupTwoFactorRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& SetupTwoFactorRequest::user_id() const {
  // @@protoc_insertion_point(field_get:sonet.user.SetupTwoFactorRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetupTwoFactorRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.SetupTwoFactorRequest.user_id)
}
inline std::string* SetupTwoFactorRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:sonet.user.SetupTwoFactorRequest.user_id)
  return _s;
}
inline const std::string& SetupTwoFactorRequest::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void SetupTwoFactorRequest::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SetupTwoFactorRequest::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SetupTwoFactorRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:sonet.user.SetupTwoFactorRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void SetupTwoFactorRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.SetupTwoFactorRequest.user_id)
}

// -------------------------------------------------------------------

// SetupTwoFactorResponse

// .sonet.common.Status status = 1;
inline bool SetupTwoFactorResponse::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool SetupTwoFactorResponse::has_status() const {
  return _internal_has_status();
}
inline const ::sonet::common::Status& SetupTwoFactorResponse::_internal_status() const {
  const ::sonet::common::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Status&>(
      ::sonet::common::_Status_default_instance_);
}
inline const ::sonet::common::Status& SetupTwoFactorResponse::status() const {
  // @@protoc_insertion_point(field_get:sonet.user.SetupTwoFactorResponse.status)
  return _internal_status();
}
inline void SetupTwoFactorResponse::unsafe_arena_set_allocated_status(
    ::sonet::common::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.user.SetupTwoFactorResponse.status)
}
inline ::sonet::common::Status* SetupTwoFactorResponse::release_status() {
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Status* SetupTwoFactorResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:sonet.user.SetupTwoFactorResponse.status)
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::sonet::common::Status* SetupTwoFactorResponse::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::sonet::common::Status* SetupTwoFactorResponse::mutable_status() {
  ::sonet::common::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:sonet.user.SetupTwoFactorResponse.status)
  return _msg;
}
inline void SetupTwoFactorResponse::set_allocated_status(::sonet::common::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:sonet.user.SetupTwoFactorResponse.status)
}

// .sonet.user.TwoFactorAuth tfa_config = 2;
inline bool SetupTwoFactorResponse::_internal_has_tfa_config() const {
  return this != internal_default_instance() && _impl_.tfa_config_ != nullptr;
}
inline bool SetupTwoFactorResponse::has_tfa_config() const {
  return _internal_has_tfa_config();
}
inline void SetupTwoFactorResponse::clear_tfa_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.tfa_config_ != nullptr) {
    delete _impl_.tfa_config_;
  }
  _impl_.tfa_config_ = nullptr;
}
inline const ::sonet::user::TwoFactorAuth& SetupTwoFactorResponse::_internal_tfa_config() const {
  const ::sonet::user::TwoFactorAuth* p = _impl_.tfa_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::user::TwoFactorAuth&>(
      ::sonet::user::_TwoFactorAuth_default_instance_);
}
inline const ::sonet::user::TwoFactorAuth& SetupTwoFactorResponse::tfa_config() const {
  // @@protoc_insertion_point(field_get:sonet.user.SetupTwoFactorResponse.tfa_config)
  return _internal_tfa_config();
}
inline void SetupTwoFactorResponse::unsafe_arena_set_allocated_tfa_config(
    ::sonet::user::TwoFactorAuth* tfa_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tfa_config_);
  }
  _impl_.tfa_config_ = tfa_config;
  if (tfa_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.user.SetupTwoFactorResponse.tfa_config)
}
inline ::sonet::user::TwoFactorAuth* SetupTwoFactorResponse::release_tfa_config() {
  
  ::sonet::user::TwoFactorAuth* temp = _impl_.tfa_config_;
  _impl_.tfa_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::user::TwoFactorAuth* SetupTwoFactorResponse::unsafe_arena_release_tfa_config() {
  // @@protoc_insertion_point(field_release:sonet.user.SetupTwoFactorResponse.tfa_config)
  
  ::sonet::user::TwoFactorAuth* temp = _impl_.tfa_config_;
  _impl_.tfa_config_ = nullptr;
  return temp;
}
inline ::sonet::user::TwoFactorAuth* SetupTwoFactorResponse::_internal_mutable_tfa_config() {
  
  if (_impl_.tfa_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::user::TwoFactorAuth>(GetArenaForAllocation());
    _impl_.tfa_config_ = p;
  }
  return _impl_.tfa_config_;
}
inline ::sonet::user::TwoFactorAuth* SetupTwoFactorResponse::mutable_tfa_config() {
  ::sonet::user::TwoFactorAuth* _msg = _internal_mutable_tfa_config();
  // @@protoc_insertion_point(field_mutable:sonet.user.SetupTwoFactorResponse.tfa_config)
  return _msg;
}
inline void SetupTwoFactorResponse::set_allocated_tfa_config(::sonet::user::TwoFactorAuth* tfa_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tfa_config_;
  }
  if (tfa_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tfa_config);
    if (message_arena != submessage_arena) {
      tfa_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tfa_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.tfa_config_ = tfa_config;
  // @@protoc_insertion_point(field_set_allocated:sonet.user.SetupTwoFactorResponse.tfa_config)
}

// -------------------------------------------------------------------

// VerifyTwoFactorRequest

// string user_id = 1;
inline void VerifyTwoFactorRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& VerifyTwoFactorRequest::user_id() const {
  // @@protoc_insertion_point(field_get:sonet.user.VerifyTwoFactorRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VerifyTwoFactorRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.VerifyTwoFactorRequest.user_id)
}
inline std::string* VerifyTwoFactorRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:sonet.user.VerifyTwoFactorRequest.user_id)
  return _s;
}
inline const std::string& VerifyTwoFactorRequest::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void VerifyTwoFactorRequest::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* VerifyTwoFactorRequest::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* VerifyTwoFactorRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:sonet.user.VerifyTwoFactorRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void VerifyTwoFactorRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.VerifyTwoFactorRequest.user_id)
}

// string code = 2;
inline void VerifyTwoFactorRequest::clear_code() {
  _impl_.code_.ClearToEmpty();
}
inline const std::string& VerifyTwoFactorRequest::code() const {
  // @@protoc_insertion_point(field_get:sonet.user.VerifyTwoFactorRequest.code)
  return _internal_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VerifyTwoFactorRequest::set_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.VerifyTwoFactorRequest.code)
}
inline std::string* VerifyTwoFactorRequest::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:sonet.user.VerifyTwoFactorRequest.code)
  return _s;
}
inline const std::string& VerifyTwoFactorRequest::_internal_code() const {
  return _impl_.code_.Get();
}
inline void VerifyTwoFactorRequest::_internal_set_code(const std::string& value) {
  
  _impl_.code_.Set(value, GetArenaForAllocation());
}
inline std::string* VerifyTwoFactorRequest::_internal_mutable_code() {
  
  return _impl_.code_.Mutable(GetArenaForAllocation());
}
inline std::string* VerifyTwoFactorRequest::release_code() {
  // @@protoc_insertion_point(field_release:sonet.user.VerifyTwoFactorRequest.code)
  return _impl_.code_.Release();
}
inline void VerifyTwoFactorRequest::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    
  } else {
    
  }
  _impl_.code_.SetAllocated(code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.code_.IsDefault()) {
    _impl_.code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.VerifyTwoFactorRequest.code)
}

// -------------------------------------------------------------------

// VerifyTwoFactorResponse

// .sonet.common.Status status = 1;
inline bool VerifyTwoFactorResponse::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool VerifyTwoFactorResponse::has_status() const {
  return _internal_has_status();
}
inline const ::sonet::common::Status& VerifyTwoFactorResponse::_internal_status() const {
  const ::sonet::common::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Status&>(
      ::sonet::common::_Status_default_instance_);
}
inline const ::sonet::common::Status& VerifyTwoFactorResponse::status() const {
  // @@protoc_insertion_point(field_get:sonet.user.VerifyTwoFactorResponse.status)
  return _internal_status();
}
inline void VerifyTwoFactorResponse::unsafe_arena_set_allocated_status(
    ::sonet::common::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.user.VerifyTwoFactorResponse.status)
}
inline ::sonet::common::Status* VerifyTwoFactorResponse::release_status() {
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Status* VerifyTwoFactorResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:sonet.user.VerifyTwoFactorResponse.status)
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::sonet::common::Status* VerifyTwoFactorResponse::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::sonet::common::Status* VerifyTwoFactorResponse::mutable_status() {
  ::sonet::common::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:sonet.user.VerifyTwoFactorResponse.status)
  return _msg;
}
inline void VerifyTwoFactorResponse::set_allocated_status(::sonet::common::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:sonet.user.VerifyTwoFactorResponse.status)
}

// bool is_verified = 2;
inline void VerifyTwoFactorResponse::clear_is_verified() {
  _impl_.is_verified_ = false;
}
inline bool VerifyTwoFactorResponse::_internal_is_verified() const {
  return _impl_.is_verified_;
}
inline bool VerifyTwoFactorResponse::is_verified() const {
  // @@protoc_insertion_point(field_get:sonet.user.VerifyTwoFactorResponse.is_verified)
  return _internal_is_verified();
}
inline void VerifyTwoFactorResponse::_internal_set_is_verified(bool value) {
  
  _impl_.is_verified_ = value;
}
inline void VerifyTwoFactorResponse::set_is_verified(bool value) {
  _internal_set_is_verified(value);
  // @@protoc_insertion_point(field_set:sonet.user.VerifyTwoFactorResponse.is_verified)
}

// -------------------------------------------------------------------

// DisableTwoFactorRequest

// string password = 1;
inline void DisableTwoFactorRequest::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& DisableTwoFactorRequest::password() const {
  // @@protoc_insertion_point(field_get:sonet.user.DisableTwoFactorRequest.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DisableTwoFactorRequest::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.DisableTwoFactorRequest.password)
}
inline std::string* DisableTwoFactorRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:sonet.user.DisableTwoFactorRequest.password)
  return _s;
}
inline const std::string& DisableTwoFactorRequest::_internal_password() const {
  return _impl_.password_.Get();
}
inline void DisableTwoFactorRequest::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* DisableTwoFactorRequest::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* DisableTwoFactorRequest::release_password() {
  // @@protoc_insertion_point(field_release:sonet.user.DisableTwoFactorRequest.password)
  return _impl_.password_.Release();
}
inline void DisableTwoFactorRequest::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.DisableTwoFactorRequest.password)
}

// -------------------------------------------------------------------

// DisableTwoFactorResponse

// .sonet.common.Status status = 1;
inline bool DisableTwoFactorResponse::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool DisableTwoFactorResponse::has_status() const {
  return _internal_has_status();
}
inline const ::sonet::common::Status& DisableTwoFactorResponse::_internal_status() const {
  const ::sonet::common::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Status&>(
      ::sonet::common::_Status_default_instance_);
}
inline const ::sonet::common::Status& DisableTwoFactorResponse::status() const {
  // @@protoc_insertion_point(field_get:sonet.user.DisableTwoFactorResponse.status)
  return _internal_status();
}
inline void DisableTwoFactorResponse::unsafe_arena_set_allocated_status(
    ::sonet::common::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.user.DisableTwoFactorResponse.status)
}
inline ::sonet::common::Status* DisableTwoFactorResponse::release_status() {
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Status* DisableTwoFactorResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:sonet.user.DisableTwoFactorResponse.status)
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::sonet::common::Status* DisableTwoFactorResponse::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::sonet::common::Status* DisableTwoFactorResponse::mutable_status() {
  ::sonet::common::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:sonet.user.DisableTwoFactorResponse.status)
  return _msg;
}
inline void DisableTwoFactorResponse::set_allocated_status(::sonet::common::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:sonet.user.DisableTwoFactorResponse.status)
}

// -------------------------------------------------------------------

// GetActiveSessionsRequest

// string user_id = 1;
inline void GetActiveSessionsRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& GetActiveSessionsRequest::user_id() const {
  // @@protoc_insertion_point(field_get:sonet.user.GetActiveSessionsRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetActiveSessionsRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.GetActiveSessionsRequest.user_id)
}
inline std::string* GetActiveSessionsRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:sonet.user.GetActiveSessionsRequest.user_id)
  return _s;
}
inline const std::string& GetActiveSessionsRequest::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void GetActiveSessionsRequest::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetActiveSessionsRequest::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetActiveSessionsRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:sonet.user.GetActiveSessionsRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void GetActiveSessionsRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.GetActiveSessionsRequest.user_id)
}

// -------------------------------------------------------------------

// GetActiveSessionsResponse

// .sonet.common.Status status = 1;
inline bool GetActiveSessionsResponse::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool GetActiveSessionsResponse::has_status() const {
  return _internal_has_status();
}
inline const ::sonet::common::Status& GetActiveSessionsResponse::_internal_status() const {
  const ::sonet::common::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Status&>(
      ::sonet::common::_Status_default_instance_);
}
inline const ::sonet::common::Status& GetActiveSessionsResponse::status() const {
  // @@protoc_insertion_point(field_get:sonet.user.GetActiveSessionsResponse.status)
  return _internal_status();
}
inline void GetActiveSessionsResponse::unsafe_arena_set_allocated_status(
    ::sonet::common::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.user.GetActiveSessionsResponse.status)
}
inline ::sonet::common::Status* GetActiveSessionsResponse::release_status() {
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Status* GetActiveSessionsResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:sonet.user.GetActiveSessionsResponse.status)
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::sonet::common::Status* GetActiveSessionsResponse::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::sonet::common::Status* GetActiveSessionsResponse::mutable_status() {
  ::sonet::common::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:sonet.user.GetActiveSessionsResponse.status)
  return _msg;
}
inline void GetActiveSessionsResponse::set_allocated_status(::sonet::common::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:sonet.user.GetActiveSessionsResponse.status)
}

// repeated .sonet.user.Session sessions = 2;
inline int GetActiveSessionsResponse::_internal_sessions_size() const {
  return _impl_.sessions_.size();
}
inline int GetActiveSessionsResponse::sessions_size() const {
  return _internal_sessions_size();
}
inline void GetActiveSessionsResponse::clear_sessions() {
  _impl_.sessions_.Clear();
}
inline ::sonet::user::Session* GetActiveSessionsResponse::mutable_sessions(int index) {
  // @@protoc_insertion_point(field_mutable:sonet.user.GetActiveSessionsResponse.sessions)
  return _impl_.sessions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::user::Session >*
GetActiveSessionsResponse::mutable_sessions() {
  // @@protoc_insertion_point(field_mutable_list:sonet.user.GetActiveSessionsResponse.sessions)
  return &_impl_.sessions_;
}
inline const ::sonet::user::Session& GetActiveSessionsResponse::_internal_sessions(int index) const {
  return _impl_.sessions_.Get(index);
}
inline const ::sonet::user::Session& GetActiveSessionsResponse::sessions(int index) const {
  // @@protoc_insertion_point(field_get:sonet.user.GetActiveSessionsResponse.sessions)
  return _internal_sessions(index);
}
inline ::sonet::user::Session* GetActiveSessionsResponse::_internal_add_sessions() {
  return _impl_.sessions_.Add();
}
inline ::sonet::user::Session* GetActiveSessionsResponse::add_sessions() {
  ::sonet::user::Session* _add = _internal_add_sessions();
  // @@protoc_insertion_point(field_add:sonet.user.GetActiveSessionsResponse.sessions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::user::Session >&
GetActiveSessionsResponse::sessions() const {
  // @@protoc_insertion_point(field_list:sonet.user.GetActiveSessionsResponse.sessions)
  return _impl_.sessions_;
}

// -------------------------------------------------------------------

// TerminateSessionRequest

// string session_id = 1;
inline void TerminateSessionRequest::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& TerminateSessionRequest::session_id() const {
  // @@protoc_insertion_point(field_get:sonet.user.TerminateSessionRequest.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TerminateSessionRequest::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.TerminateSessionRequest.session_id)
}
inline std::string* TerminateSessionRequest::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:sonet.user.TerminateSessionRequest.session_id)
  return _s;
}
inline const std::string& TerminateSessionRequest::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void TerminateSessionRequest::_internal_set_session_id(const std::string& value) {
  
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TerminateSessionRequest::_internal_mutable_session_id() {
  
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TerminateSessionRequest::release_session_id() {
  // @@protoc_insertion_point(field_release:sonet.user.TerminateSessionRequest.session_id)
  return _impl_.session_id_.Release();
}
inline void TerminateSessionRequest::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.TerminateSessionRequest.session_id)
}

// -------------------------------------------------------------------

// TerminateSessionResponse

// .sonet.common.Status status = 1;
inline bool TerminateSessionResponse::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool TerminateSessionResponse::has_status() const {
  return _internal_has_status();
}
inline const ::sonet::common::Status& TerminateSessionResponse::_internal_status() const {
  const ::sonet::common::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Status&>(
      ::sonet::common::_Status_default_instance_);
}
inline const ::sonet::common::Status& TerminateSessionResponse::status() const {
  // @@protoc_insertion_point(field_get:sonet.user.TerminateSessionResponse.status)
  return _internal_status();
}
inline void TerminateSessionResponse::unsafe_arena_set_allocated_status(
    ::sonet::common::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.user.TerminateSessionResponse.status)
}
inline ::sonet::common::Status* TerminateSessionResponse::release_status() {
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Status* TerminateSessionResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:sonet.user.TerminateSessionResponse.status)
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::sonet::common::Status* TerminateSessionResponse::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::sonet::common::Status* TerminateSessionResponse::mutable_status() {
  ::sonet::common::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:sonet.user.TerminateSessionResponse.status)
  return _msg;
}
inline void TerminateSessionResponse::set_allocated_status(::sonet::common::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:sonet.user.TerminateSessionResponse.status)
}

// -------------------------------------------------------------------

// GetUserProfileRequest

// string user_id = 1;
inline void GetUserProfileRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& GetUserProfileRequest::user_id() const {
  // @@protoc_insertion_point(field_get:sonet.user.GetUserProfileRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetUserProfileRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.GetUserProfileRequest.user_id)
}
inline std::string* GetUserProfileRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:sonet.user.GetUserProfileRequest.user_id)
  return _s;
}
inline const std::string& GetUserProfileRequest::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void GetUserProfileRequest::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetUserProfileRequest::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetUserProfileRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:sonet.user.GetUserProfileRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void GetUserProfileRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.GetUserProfileRequest.user_id)
}

// -------------------------------------------------------------------

// GetUserProfileResponse

// .sonet.common.Status status = 1;
inline bool GetUserProfileResponse::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool GetUserProfileResponse::has_status() const {
  return _internal_has_status();
}
inline const ::sonet::common::Status& GetUserProfileResponse::_internal_status() const {
  const ::sonet::common::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Status&>(
      ::sonet::common::_Status_default_instance_);
}
inline const ::sonet::common::Status& GetUserProfileResponse::status() const {
  // @@protoc_insertion_point(field_get:sonet.user.GetUserProfileResponse.status)
  return _internal_status();
}
inline void GetUserProfileResponse::unsafe_arena_set_allocated_status(
    ::sonet::common::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.user.GetUserProfileResponse.status)
}
inline ::sonet::common::Status* GetUserProfileResponse::release_status() {
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Status* GetUserProfileResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:sonet.user.GetUserProfileResponse.status)
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::sonet::common::Status* GetUserProfileResponse::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::sonet::common::Status* GetUserProfileResponse::mutable_status() {
  ::sonet::common::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:sonet.user.GetUserProfileResponse.status)
  return _msg;
}
inline void GetUserProfileResponse::set_allocated_status(::sonet::common::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:sonet.user.GetUserProfileResponse.status)
}

// .sonet.user.UserProfile user = 2;
inline bool GetUserProfileResponse::_internal_has_user() const {
  return this != internal_default_instance() && _impl_.user_ != nullptr;
}
inline bool GetUserProfileResponse::has_user() const {
  return _internal_has_user();
}
inline void GetUserProfileResponse::clear_user() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_ != nullptr) {
    delete _impl_.user_;
  }
  _impl_.user_ = nullptr;
}
inline const ::sonet::user::UserProfile& GetUserProfileResponse::_internal_user() const {
  const ::sonet::user::UserProfile* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::user::UserProfile&>(
      ::sonet::user::_UserProfile_default_instance_);
}
inline const ::sonet::user::UserProfile& GetUserProfileResponse::user() const {
  // @@protoc_insertion_point(field_get:sonet.user.GetUserProfileResponse.user)
  return _internal_user();
}
inline void GetUserProfileResponse::unsafe_arena_set_allocated_user(
    ::sonet::user::UserProfile* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.user.GetUserProfileResponse.user)
}
inline ::sonet::user::UserProfile* GetUserProfileResponse::release_user() {
  
  ::sonet::user::UserProfile* temp = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::user::UserProfile* GetUserProfileResponse::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:sonet.user.GetUserProfileResponse.user)
  
  ::sonet::user::UserProfile* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::sonet::user::UserProfile* GetUserProfileResponse::_internal_mutable_user() {
  
  if (_impl_.user_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::user::UserProfile>(GetArenaForAllocation());
    _impl_.user_ = p;
  }
  return _impl_.user_;
}
inline ::sonet::user::UserProfile* GetUserProfileResponse::mutable_user() {
  ::sonet::user::UserProfile* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:sonet.user.GetUserProfileResponse.user)
  return _msg;
}
inline void GetUserProfileResponse::set_allocated_user(::sonet::user::UserProfile* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_ = user;
  // @@protoc_insertion_point(field_set_allocated:sonet.user.GetUserProfileResponse.user)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// UpdateUserProfileRequest

// string user_id = 1;
inline void UpdateUserProfileRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& UpdateUserProfileRequest::user_id() const {
  // @@protoc_insertion_point(field_get:sonet.user.UpdateUserProfileRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateUserProfileRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.UpdateUserProfileRequest.user_id)
}
inline std::string* UpdateUserProfileRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:sonet.user.UpdateUserProfileRequest.user_id)
  return _s;
}
inline const std::string& UpdateUserProfileRequest::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void UpdateUserProfileRequest::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateUserProfileRequest::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateUserProfileRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:sonet.user.UpdateUserProfileRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void UpdateUserProfileRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.UpdateUserProfileRequest.user_id)
}

// string display_name = 2;
inline void UpdateUserProfileRequest::clear_display_name() {
  _impl_.display_name_.ClearToEmpty();
}
inline const std::string& UpdateUserProfileRequest::display_name() const {
  // @@protoc_insertion_point(field_get:sonet.user.UpdateUserProfileRequest.display_name)
  return _internal_display_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateUserProfileRequest::set_display_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.display_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.UpdateUserProfileRequest.display_name)
}
inline std::string* UpdateUserProfileRequest::mutable_display_name() {
  std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:sonet.user.UpdateUserProfileRequest.display_name)
  return _s;
}
inline const std::string& UpdateUserProfileRequest::_internal_display_name() const {
  return _impl_.display_name_.Get();
}
inline void UpdateUserProfileRequest::_internal_set_display_name(const std::string& value) {
  
  _impl_.display_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateUserProfileRequest::_internal_mutable_display_name() {
  
  return _impl_.display_name_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateUserProfileRequest::release_display_name() {
  // @@protoc_insertion_point(field_release:sonet.user.UpdateUserProfileRequest.display_name)
  return _impl_.display_name_.Release();
}
inline void UpdateUserProfileRequest::set_allocated_display_name(std::string* display_name) {
  if (display_name != nullptr) {
    
  } else {
    
  }
  _impl_.display_name_.SetAllocated(display_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.display_name_.IsDefault()) {
    _impl_.display_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.UpdateUserProfileRequest.display_name)
}

// string bio = 3;
inline void UpdateUserProfileRequest::clear_bio() {
  _impl_.bio_.ClearToEmpty();
}
inline const std::string& UpdateUserProfileRequest::bio() const {
  // @@protoc_insertion_point(field_get:sonet.user.UpdateUserProfileRequest.bio)
  return _internal_bio();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateUserProfileRequest::set_bio(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bio_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.UpdateUserProfileRequest.bio)
}
inline std::string* UpdateUserProfileRequest::mutable_bio() {
  std::string* _s = _internal_mutable_bio();
  // @@protoc_insertion_point(field_mutable:sonet.user.UpdateUserProfileRequest.bio)
  return _s;
}
inline const std::string& UpdateUserProfileRequest::_internal_bio() const {
  return _impl_.bio_.Get();
}
inline void UpdateUserProfileRequest::_internal_set_bio(const std::string& value) {
  
  _impl_.bio_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateUserProfileRequest::_internal_mutable_bio() {
  
  return _impl_.bio_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateUserProfileRequest::release_bio() {
  // @@protoc_insertion_point(field_release:sonet.user.UpdateUserProfileRequest.bio)
  return _impl_.bio_.Release();
}
inline void UpdateUserProfileRequest::set_allocated_bio(std::string* bio) {
  if (bio != nullptr) {
    
  } else {
    
  }
  _impl_.bio_.SetAllocated(bio, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bio_.IsDefault()) {
    _impl_.bio_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.UpdateUserProfileRequest.bio)
}

// string location = 4;
inline void UpdateUserProfileRequest::clear_location() {
  _impl_.location_.ClearToEmpty();
}
inline const std::string& UpdateUserProfileRequest::location() const {
  // @@protoc_insertion_point(field_get:sonet.user.UpdateUserProfileRequest.location)
  return _internal_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateUserProfileRequest::set_location(ArgT0&& arg0, ArgT... args) {
 
 _impl_.location_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.UpdateUserProfileRequest.location)
}
inline std::string* UpdateUserProfileRequest::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:sonet.user.UpdateUserProfileRequest.location)
  return _s;
}
inline const std::string& UpdateUserProfileRequest::_internal_location() const {
  return _impl_.location_.Get();
}
inline void UpdateUserProfileRequest::_internal_set_location(const std::string& value) {
  
  _impl_.location_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateUserProfileRequest::_internal_mutable_location() {
  
  return _impl_.location_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateUserProfileRequest::release_location() {
  // @@protoc_insertion_point(field_release:sonet.user.UpdateUserProfileRequest.location)
  return _impl_.location_.Release();
}
inline void UpdateUserProfileRequest::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    
  } else {
    
  }
  _impl_.location_.SetAllocated(location, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.location_.IsDefault()) {
    _impl_.location_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.UpdateUserProfileRequest.location)
}

// string website = 5;
inline void UpdateUserProfileRequest::clear_website() {
  _impl_.website_.ClearToEmpty();
}
inline const std::string& UpdateUserProfileRequest::website() const {
  // @@protoc_insertion_point(field_get:sonet.user.UpdateUserProfileRequest.website)
  return _internal_website();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateUserProfileRequest::set_website(ArgT0&& arg0, ArgT... args) {
 
 _impl_.website_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.user.UpdateUserProfileRequest.website)
}
inline std::string* UpdateUserProfileRequest::mutable_website() {
  std::string* _s = _internal_mutable_website();
  // @@protoc_insertion_point(field_mutable:sonet.user.UpdateUserProfileRequest.website)
  return _s;
}
inline const std::string& UpdateUserProfileRequest::_internal_website() const {
  return _impl_.website_.Get();
}
inline void UpdateUserProfileRequest::_internal_set_website(const std::string& value) {
  
  _impl_.website_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateUserProfileRequest::_internal_mutable_website() {
  
  return _impl_.website_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateUserProfileRequest::release_website() {
  // @@protoc_insertion_point(field_release:sonet.user.UpdateUserProfileRequest.website)
  return _impl_.website_.Release();
}
inline void UpdateUserProfileRequest::set_allocated_website(std::string* website) {
  if (website != nullptr) {
    
  } else {
    
  }
  _impl_.website_.SetAllocated(website, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.website_.IsDefault()) {
    _impl_.website_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.user.UpdateUserProfileRequest.website)
}

// bool is_private = 6;
inline void UpdateUserProfileRequest::clear_is_private() {
  _impl_.is_private_ = false;
}
inline bool UpdateUserProfileRequest::_internal_is_private() const {
  return _impl_.is_private_;
}
inline bool UpdateUserProfileRequest::is_private() const {
  // @@protoc_insertion_point(field_get:sonet.user.UpdateUserProfileRequest.is_private)
  return _internal_is_private();
}
inline void UpdateUserProfileRequest::_internal_set_is_private(bool value) {
  
  _impl_.is_private_ = value;
}
inline void UpdateUserProfileRequest::set_is_private(bool value) {
  _internal_set_is_private(value);
  // @@protoc_insertion_point(field_set:sonet.user.UpdateUserProfileRequest.is_private)
}

// map<string, string> settings = 7;
inline int UpdateUserProfileRequest::_internal_settings_size() const {
  return _impl_.settings_.size();
}
inline int UpdateUserProfileRequest::settings_size() const {
  return _internal_settings_size();
}
inline void UpdateUserProfileRequest::clear_settings() {
  _impl_.settings_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
UpdateUserProfileRequest::_internal_settings() const {
  return _impl_.settings_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
UpdateUserProfileRequest::settings() const {
  // @@protoc_insertion_point(field_map:sonet.user.UpdateUserProfileRequest.settings)
  return _internal_settings();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
UpdateUserProfileRequest::_internal_mutable_settings() {
  return _impl_.settings_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
UpdateUserProfileRequest::mutable_settings() {
  // @@protoc_insertion_point(field_mutable_map:sonet.user.UpdateUserProfileRequest.settings)
  return _internal_mutable_settings();
}

// -------------------------------------------------------------------

// UpdateUserProfileResponse

// .sonet.common.Status status = 1;
inline bool UpdateUserProfileResponse::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool UpdateUserProfileResponse::has_status() const {
  return _internal_has_status();
}
inline const ::sonet::common::Status& UpdateUserProfileResponse::_internal_status() const {
  const ::sonet::common::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Status&>(
      ::sonet::common::_Status_default_instance_);
}
inline const ::sonet::common::Status& UpdateUserProfileResponse::status() const {
  // @@protoc_insertion_point(field_get:sonet.user.UpdateUserProfileResponse.status)
  return _internal_status();
}
inline void UpdateUserProfileResponse::unsafe_arena_set_allocated_status(
    ::sonet::common::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.user.UpdateUserProfileResponse.status)
}
inline ::sonet::common::Status* UpdateUserProfileResponse::release_status() {
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Status* UpdateUserProfileResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:sonet.user.UpdateUserProfileResponse.status)
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::sonet::common::Status* UpdateUserProfileResponse::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::sonet::common::Status* UpdateUserProfileResponse::mutable_status() {
  ::sonet::common::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:sonet.user.UpdateUserProfileResponse.status)
  return _msg;
}
inline void UpdateUserProfileResponse::set_allocated_status(::sonet::common::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:sonet.user.UpdateUserProfileResponse.status)
}

// .sonet.user.UserProfile user = 2;
inline bool UpdateUserProfileResponse::_internal_has_user() const {
  return this != internal_default_instance() && _impl_.user_ != nullptr;
}
inline bool UpdateUserProfileResponse::has_user() const {
  return _internal_has_user();
}
inline void UpdateUserProfileResponse::clear_user() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_ != nullptr) {
    delete _impl_.user_;
  }
  _impl_.user_ = nullptr;
}
inline const ::sonet::user::UserProfile& UpdateUserProfileResponse::_internal_user() const {
  const ::sonet::user::UserProfile* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::user::UserProfile&>(
      ::sonet::user::_UserProfile_default_instance_);
}
inline const ::sonet::user::UserProfile& UpdateUserProfileResponse::user() const {
  // @@protoc_insertion_point(field_get:sonet.user.UpdateUserProfileResponse.user)
  return _internal_user();
}
inline void UpdateUserProfileResponse::unsafe_arena_set_allocated_user(
    ::sonet::user::UserProfile* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.user.UpdateUserProfileResponse.user)
}
inline ::sonet::user::UserProfile* UpdateUserProfileResponse::release_user() {
  
  ::sonet::user::UserProfile* temp = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::user::UserProfile* UpdateUserProfileResponse::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:sonet.user.UpdateUserProfileResponse.user)
  
  ::sonet::user::UserProfile* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::sonet::user::UserProfile* UpdateUserProfileResponse::_internal_mutable_user() {
  
  if (_impl_.user_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::user::UserProfile>(GetArenaForAllocation());
    _impl_.user_ = p;
  }
  return _impl_.user_;
}
inline ::sonet::user::UserProfile* UpdateUserProfileResponse::mutable_user() {
  ::sonet::user::UserProfile* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:sonet.user.UpdateUserProfileResponse.user)
  return _msg;
}
inline void UpdateUserProfileResponse::set_allocated_user(::sonet::user::UserProfile* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_ = user;
  // @@protoc_insertion_point(field_set_allocated:sonet.user.UpdateUserProfileResponse.user)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace user
}  // namespace sonet

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::sonet::user::UserStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sonet::user::UserStatus>() {
  return ::sonet::user::UserStatus_descriptor();
}
template <> struct is_proto_enum< ::sonet::user::SessionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sonet::user::SessionType>() {
  return ::sonet::user::SessionType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_services_2fuser_2eproto
