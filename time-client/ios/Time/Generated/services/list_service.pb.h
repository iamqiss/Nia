// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: services/list_service.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_services_2flist_5fservice_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_services_2flist_5fservice_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_services_2flist_5fservice_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_services_2flist_5fservice_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_services_2flist_5fservice_2eproto;
namespace sonet {
namespace list {
namespace v1 {
class AddListMemberRequest;
struct AddListMemberRequestDefaultTypeInternal;
extern AddListMemberRequestDefaultTypeInternal _AddListMemberRequest_default_instance_;
class AddListMemberResponse;
struct AddListMemberResponseDefaultTypeInternal;
extern AddListMemberResponseDefaultTypeInternal _AddListMemberResponse_default_instance_;
class CreateListRequest;
struct CreateListRequestDefaultTypeInternal;
extern CreateListRequestDefaultTypeInternal _CreateListRequest_default_instance_;
class CreateListResponse;
struct CreateListResponseDefaultTypeInternal;
extern CreateListResponseDefaultTypeInternal _CreateListResponse_default_instance_;
class DeleteListRequest;
struct DeleteListRequestDefaultTypeInternal;
extern DeleteListRequestDefaultTypeInternal _DeleteListRequest_default_instance_;
class DeleteListResponse;
struct DeleteListResponseDefaultTypeInternal;
extern DeleteListResponseDefaultTypeInternal _DeleteListResponse_default_instance_;
class GetListMembersRequest;
struct GetListMembersRequestDefaultTypeInternal;
extern GetListMembersRequestDefaultTypeInternal _GetListMembersRequest_default_instance_;
class GetListMembersResponse;
struct GetListMembersResponseDefaultTypeInternal;
extern GetListMembersResponseDefaultTypeInternal _GetListMembersResponse_default_instance_;
class GetListRequest;
struct GetListRequestDefaultTypeInternal;
extern GetListRequestDefaultTypeInternal _GetListRequest_default_instance_;
class GetListResponse;
struct GetListResponseDefaultTypeInternal;
extern GetListResponseDefaultTypeInternal _GetListResponse_default_instance_;
class GetUserListsRequest;
struct GetUserListsRequestDefaultTypeInternal;
extern GetUserListsRequestDefaultTypeInternal _GetUserListsRequest_default_instance_;
class GetUserListsResponse;
struct GetUserListsResponseDefaultTypeInternal;
extern GetUserListsResponseDefaultTypeInternal _GetUserListsResponse_default_instance_;
class IsUserInListRequest;
struct IsUserInListRequestDefaultTypeInternal;
extern IsUserInListRequestDefaultTypeInternal _IsUserInListRequest_default_instance_;
class IsUserInListResponse;
struct IsUserInListResponseDefaultTypeInternal;
extern IsUserInListResponseDefaultTypeInternal _IsUserInListResponse_default_instance_;
class List;
struct ListDefaultTypeInternal;
extern ListDefaultTypeInternal _List_default_instance_;
class ListMember;
struct ListMemberDefaultTypeInternal;
extern ListMemberDefaultTypeInternal _ListMember_default_instance_;
class RemoveListMemberRequest;
struct RemoveListMemberRequestDefaultTypeInternal;
extern RemoveListMemberRequestDefaultTypeInternal _RemoveListMemberRequest_default_instance_;
class RemoveListMemberResponse;
struct RemoveListMemberResponseDefaultTypeInternal;
extern RemoveListMemberResponseDefaultTypeInternal _RemoveListMemberResponse_default_instance_;
class UpdateListRequest;
struct UpdateListRequestDefaultTypeInternal;
extern UpdateListRequestDefaultTypeInternal _UpdateListRequest_default_instance_;
class UpdateListResponse;
struct UpdateListResponseDefaultTypeInternal;
extern UpdateListResponseDefaultTypeInternal _UpdateListResponse_default_instance_;
}  // namespace v1
}  // namespace list
}  // namespace sonet
PROTOBUF_NAMESPACE_OPEN
template<> ::sonet::list::v1::AddListMemberRequest* Arena::CreateMaybeMessage<::sonet::list::v1::AddListMemberRequest>(Arena*);
template<> ::sonet::list::v1::AddListMemberResponse* Arena::CreateMaybeMessage<::sonet::list::v1::AddListMemberResponse>(Arena*);
template<> ::sonet::list::v1::CreateListRequest* Arena::CreateMaybeMessage<::sonet::list::v1::CreateListRequest>(Arena*);
template<> ::sonet::list::v1::CreateListResponse* Arena::CreateMaybeMessage<::sonet::list::v1::CreateListResponse>(Arena*);
template<> ::sonet::list::v1::DeleteListRequest* Arena::CreateMaybeMessage<::sonet::list::v1::DeleteListRequest>(Arena*);
template<> ::sonet::list::v1::DeleteListResponse* Arena::CreateMaybeMessage<::sonet::list::v1::DeleteListResponse>(Arena*);
template<> ::sonet::list::v1::GetListMembersRequest* Arena::CreateMaybeMessage<::sonet::list::v1::GetListMembersRequest>(Arena*);
template<> ::sonet::list::v1::GetListMembersResponse* Arena::CreateMaybeMessage<::sonet::list::v1::GetListMembersResponse>(Arena*);
template<> ::sonet::list::v1::GetListRequest* Arena::CreateMaybeMessage<::sonet::list::v1::GetListRequest>(Arena*);
template<> ::sonet::list::v1::GetListResponse* Arena::CreateMaybeMessage<::sonet::list::v1::GetListResponse>(Arena*);
template<> ::sonet::list::v1::GetUserListsRequest* Arena::CreateMaybeMessage<::sonet::list::v1::GetUserListsRequest>(Arena*);
template<> ::sonet::list::v1::GetUserListsResponse* Arena::CreateMaybeMessage<::sonet::list::v1::GetUserListsResponse>(Arena*);
template<> ::sonet::list::v1::IsUserInListRequest* Arena::CreateMaybeMessage<::sonet::list::v1::IsUserInListRequest>(Arena*);
template<> ::sonet::list::v1::IsUserInListResponse* Arena::CreateMaybeMessage<::sonet::list::v1::IsUserInListResponse>(Arena*);
template<> ::sonet::list::v1::List* Arena::CreateMaybeMessage<::sonet::list::v1::List>(Arena*);
template<> ::sonet::list::v1::ListMember* Arena::CreateMaybeMessage<::sonet::list::v1::ListMember>(Arena*);
template<> ::sonet::list::v1::RemoveListMemberRequest* Arena::CreateMaybeMessage<::sonet::list::v1::RemoveListMemberRequest>(Arena*);
template<> ::sonet::list::v1::RemoveListMemberResponse* Arena::CreateMaybeMessage<::sonet::list::v1::RemoveListMemberResponse>(Arena*);
template<> ::sonet::list::v1::UpdateListRequest* Arena::CreateMaybeMessage<::sonet::list::v1::UpdateListRequest>(Arena*);
template<> ::sonet::list::v1::UpdateListResponse* Arena::CreateMaybeMessage<::sonet::list::v1::UpdateListResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sonet {
namespace list {
namespace v1 {

enum ListType : int {
  LIST_TYPE_UNSPECIFIED = 0,
  LIST_TYPE_CUSTOM = 1,
  LIST_TYPE_CLOSE_FRIENDS = 2,
  LIST_TYPE_FAMILY = 3,
  LIST_TYPE_WORK = 4,
  LIST_TYPE_SCHOOL = 5,
  ListType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ListType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ListType_IsValid(int value);
constexpr ListType ListType_MIN = LIST_TYPE_UNSPECIFIED;
constexpr ListType ListType_MAX = LIST_TYPE_SCHOOL;
constexpr int ListType_ARRAYSIZE = ListType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ListType_descriptor();
template<typename T>
inline const std::string& ListType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ListType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ListType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ListType_descriptor(), enum_t_value);
}
inline bool ListType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ListType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ListType>(
    ListType_descriptor(), name, value);
}
// ===================================================================

class List final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.list.v1.List) */ {
 public:
  inline List() : List(nullptr) {}
  ~List() override;
  explicit PROTOBUF_CONSTEXPR List(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  List(const List& from);
  List(List&& from) noexcept
    : List() {
    *this = ::std::move(from);
  }

  inline List& operator=(const List& from) {
    CopyFrom(from);
    return *this;
  }
  inline List& operator=(List&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const List& default_instance() {
    return *internal_default_instance();
  }
  static inline const List* internal_default_instance() {
    return reinterpret_cast<const List*>(
               &_List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(List& a, List& b) {
    a.Swap(&b);
  }
  inline void Swap(List* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(List* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  List* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<List>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const List& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const List& from) {
    List::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(List* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.list.v1.List";
  }
  protected:
  explicit List(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListIdFieldNumber = 1,
    kOwnerIdFieldNumber = 2,
    kNameFieldNumber = 3,
    kDescriptionFieldNumber = 4,
    kCreatedAtFieldNumber = 7,
    kUpdatedAtFieldNumber = 8,
    kIsPublicFieldNumber = 5,
    kListTypeFieldNumber = 6,
    kMemberCountFieldNumber = 9,
  };
  // string list_id = 1;
  void clear_list_id();
  const std::string& list_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_list_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_list_id();
  PROTOBUF_NODISCARD std::string* release_list_id();
  void set_allocated_list_id(std::string* list_id);
  private:
  const std::string& _internal_list_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_list_id(const std::string& value);
  std::string* _internal_mutable_list_id();
  public:

  // string owner_id = 2;
  void clear_owner_id();
  const std::string& owner_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_id();
  PROTOBUF_NODISCARD std::string* release_owner_id();
  void set_allocated_owner_id(std::string* owner_id);
  private:
  const std::string& _internal_owner_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_id(const std::string& value);
  std::string* _internal_mutable_owner_id();
  public:

  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 4;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .google.protobuf.Timestamp created_at = 7;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .google.protobuf.Timestamp updated_at = 8;
  bool has_updated_at() const;
  private:
  bool _internal_has_updated_at() const;
  public:
  void clear_updated_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& updated_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_updated_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_updated_at();
  void set_allocated_updated_at(::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_updated_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_updated_at();
  public:
  void unsafe_arena_set_allocated_updated_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_updated_at();

  // bool is_public = 5;
  void clear_is_public();
  bool is_public() const;
  void set_is_public(bool value);
  private:
  bool _internal_is_public() const;
  void _internal_set_is_public(bool value);
  public:

  // .sonet.list.v1.ListType list_type = 6;
  void clear_list_type();
  ::sonet::list::v1::ListType list_type() const;
  void set_list_type(::sonet::list::v1::ListType value);
  private:
  ::sonet::list::v1::ListType _internal_list_type() const;
  void _internal_set_list_type(::sonet::list::v1::ListType value);
  public:

  // int32 member_count = 9;
  void clear_member_count();
  int32_t member_count() const;
  void set_member_count(int32_t value);
  private:
  int32_t _internal_member_count() const;
  void _internal_set_member_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.list.v1.List)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr list_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at_;
    bool is_public_;
    int list_type_;
    int32_t member_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2flist_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ListMember final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.list.v1.ListMember) */ {
 public:
  inline ListMember() : ListMember(nullptr) {}
  ~ListMember() override;
  explicit PROTOBUF_CONSTEXPR ListMember(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListMember(const ListMember& from);
  ListMember(ListMember&& from) noexcept
    : ListMember() {
    *this = ::std::move(from);
  }

  inline ListMember& operator=(const ListMember& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListMember& operator=(ListMember&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListMember& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListMember* internal_default_instance() {
    return reinterpret_cast<const ListMember*>(
               &_ListMember_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ListMember& a, ListMember& b) {
    a.Swap(&b);
  }
  inline void Swap(ListMember* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListMember* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListMember* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListMember>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListMember& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListMember& from) {
    ListMember::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListMember* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.list.v1.ListMember";
  }
  protected:
  explicit ListMember(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListIdFieldNumber = 1,
    kUserIdFieldNumber = 2,
    kAddedByFieldNumber = 3,
    kNotesFieldNumber = 4,
    kAddedAtFieldNumber = 5,
  };
  // string list_id = 1;
  void clear_list_id();
  const std::string& list_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_list_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_list_id();
  PROTOBUF_NODISCARD std::string* release_list_id();
  void set_allocated_list_id(std::string* list_id);
  private:
  const std::string& _internal_list_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_list_id(const std::string& value);
  std::string* _internal_mutable_list_id();
  public:

  // string user_id = 2;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string added_by = 3;
  void clear_added_by();
  const std::string& added_by() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_added_by(ArgT0&& arg0, ArgT... args);
  std::string* mutable_added_by();
  PROTOBUF_NODISCARD std::string* release_added_by();
  void set_allocated_added_by(std::string* added_by);
  private:
  const std::string& _internal_added_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_added_by(const std::string& value);
  std::string* _internal_mutable_added_by();
  public:

  // string notes = 4;
  void clear_notes();
  const std::string& notes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_notes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_notes();
  PROTOBUF_NODISCARD std::string* release_notes();
  void set_allocated_notes(std::string* notes);
  private:
  const std::string& _internal_notes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_notes(const std::string& value);
  std::string* _internal_mutable_notes();
  public:

  // .google.protobuf.Timestamp added_at = 5;
  bool has_added_at() const;
  private:
  bool _internal_has_added_at() const;
  public:
  void clear_added_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& added_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_added_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_added_at();
  void set_allocated_added_at(::PROTOBUF_NAMESPACE_ID::Timestamp* added_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_added_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_added_at();
  public:
  void unsafe_arena_set_allocated_added_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* added_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_added_at();

  // @@protoc_insertion_point(class_scope:sonet.list.v1.ListMember)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr list_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr added_by_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr notes_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* added_at_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2flist_5fservice_2eproto;
};
// -------------------------------------------------------------------

class CreateListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.list.v1.CreateListRequest) */ {
 public:
  inline CreateListRequest() : CreateListRequest(nullptr) {}
  ~CreateListRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateListRequest(const CreateListRequest& from);
  CreateListRequest(CreateListRequest&& from) noexcept
    : CreateListRequest() {
    *this = ::std::move(from);
  }

  inline CreateListRequest& operator=(const CreateListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateListRequest& operator=(CreateListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateListRequest* internal_default_instance() {
    return reinterpret_cast<const CreateListRequest*>(
               &_CreateListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CreateListRequest& a, CreateListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateListRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateListRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateListRequest& from) {
    CreateListRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateListRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.list.v1.CreateListRequest";
  }
  protected:
  explicit CreateListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kIsPublicFieldNumber = 4,
    kListTypeFieldNumber = 5,
  };
  // string owner_id = 1;
  void clear_owner_id();
  const std::string& owner_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_id();
  PROTOBUF_NODISCARD std::string* release_owner_id();
  void set_allocated_owner_id(std::string* owner_id);
  private:
  const std::string& _internal_owner_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_id(const std::string& value);
  std::string* _internal_mutable_owner_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // bool is_public = 4;
  void clear_is_public();
  bool is_public() const;
  void set_is_public(bool value);
  private:
  bool _internal_is_public() const;
  void _internal_set_is_public(bool value);
  public:

  // .sonet.list.v1.ListType list_type = 5;
  void clear_list_type();
  ::sonet::list::v1::ListType list_type() const;
  void set_list_type(::sonet::list::v1::ListType value);
  private:
  ::sonet::list::v1::ListType _internal_list_type() const;
  void _internal_set_list_type(::sonet::list::v1::ListType value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.list.v1.CreateListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    bool is_public_;
    int list_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2flist_5fservice_2eproto;
};
// -------------------------------------------------------------------

class CreateListResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.list.v1.CreateListResponse) */ {
 public:
  inline CreateListResponse() : CreateListResponse(nullptr) {}
  ~CreateListResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateListResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateListResponse(const CreateListResponse& from);
  CreateListResponse(CreateListResponse&& from) noexcept
    : CreateListResponse() {
    *this = ::std::move(from);
  }

  inline CreateListResponse& operator=(const CreateListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateListResponse& operator=(CreateListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateListResponse* internal_default_instance() {
    return reinterpret_cast<const CreateListResponse*>(
               &_CreateListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CreateListResponse& a, CreateListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateListResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateListResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateListResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateListResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateListResponse& from) {
    CreateListResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateListResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.list.v1.CreateListResponse";
  }
  protected:
  explicit CreateListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 3,
    kListFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string error_message = 3;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // .sonet.list.v1.List list = 2;
  bool has_list() const;
  private:
  bool _internal_has_list() const;
  public:
  void clear_list();
  const ::sonet::list::v1::List& list() const;
  PROTOBUF_NODISCARD ::sonet::list::v1::List* release_list();
  ::sonet::list::v1::List* mutable_list();
  void set_allocated_list(::sonet::list::v1::List* list);
  private:
  const ::sonet::list::v1::List& _internal_list() const;
  ::sonet::list::v1::List* _internal_mutable_list();
  public:
  void unsafe_arena_set_allocated_list(
      ::sonet::list::v1::List* list);
  ::sonet::list::v1::List* unsafe_arena_release_list();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.list.v1.CreateListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    ::sonet::list::v1::List* list_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2flist_5fservice_2eproto;
};
// -------------------------------------------------------------------

class GetListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.list.v1.GetListRequest) */ {
 public:
  inline GetListRequest() : GetListRequest(nullptr) {}
  ~GetListRequest() override;
  explicit PROTOBUF_CONSTEXPR GetListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetListRequest(const GetListRequest& from);
  GetListRequest(GetListRequest&& from) noexcept
    : GetListRequest() {
    *this = ::std::move(from);
  }

  inline GetListRequest& operator=(const GetListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetListRequest& operator=(GetListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetListRequest* internal_default_instance() {
    return reinterpret_cast<const GetListRequest*>(
               &_GetListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetListRequest& a, GetListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetListRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetListRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetListRequest& from) {
    GetListRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetListRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.list.v1.GetListRequest";
  }
  protected:
  explicit GetListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListIdFieldNumber = 1,
    kRequesterIdFieldNumber = 2,
  };
  // string list_id = 1;
  void clear_list_id();
  const std::string& list_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_list_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_list_id();
  PROTOBUF_NODISCARD std::string* release_list_id();
  void set_allocated_list_id(std::string* list_id);
  private:
  const std::string& _internal_list_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_list_id(const std::string& value);
  std::string* _internal_mutable_list_id();
  public:

  // string requester_id = 2;
  void clear_requester_id();
  const std::string& requester_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_requester_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_requester_id();
  PROTOBUF_NODISCARD std::string* release_requester_id();
  void set_allocated_requester_id(std::string* requester_id);
  private:
  const std::string& _internal_requester_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_requester_id(const std::string& value);
  std::string* _internal_mutable_requester_id();
  public:

  // @@protoc_insertion_point(class_scope:sonet.list.v1.GetListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr list_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr requester_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2flist_5fservice_2eproto;
};
// -------------------------------------------------------------------

class GetListResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.list.v1.GetListResponse) */ {
 public:
  inline GetListResponse() : GetListResponse(nullptr) {}
  ~GetListResponse() override;
  explicit PROTOBUF_CONSTEXPR GetListResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetListResponse(const GetListResponse& from);
  GetListResponse(GetListResponse&& from) noexcept
    : GetListResponse() {
    *this = ::std::move(from);
  }

  inline GetListResponse& operator=(const GetListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetListResponse& operator=(GetListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetListResponse* internal_default_instance() {
    return reinterpret_cast<const GetListResponse*>(
               &_GetListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetListResponse& a, GetListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetListResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetListResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetListResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetListResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetListResponse& from) {
    GetListResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetListResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.list.v1.GetListResponse";
  }
  protected:
  explicit GetListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 3,
    kListFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string error_message = 3;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // .sonet.list.v1.List list = 2;
  bool has_list() const;
  private:
  bool _internal_has_list() const;
  public:
  void clear_list();
  const ::sonet::list::v1::List& list() const;
  PROTOBUF_NODISCARD ::sonet::list::v1::List* release_list();
  ::sonet::list::v1::List* mutable_list();
  void set_allocated_list(::sonet::list::v1::List* list);
  private:
  const ::sonet::list::v1::List& _internal_list() const;
  ::sonet::list::v1::List* _internal_mutable_list();
  public:
  void unsafe_arena_set_allocated_list(
      ::sonet::list::v1::List* list);
  ::sonet::list::v1::List* unsafe_arena_release_list();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.list.v1.GetListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    ::sonet::list::v1::List* list_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2flist_5fservice_2eproto;
};
// -------------------------------------------------------------------

class GetUserListsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.list.v1.GetUserListsRequest) */ {
 public:
  inline GetUserListsRequest() : GetUserListsRequest(nullptr) {}
  ~GetUserListsRequest() override;
  explicit PROTOBUF_CONSTEXPR GetUserListsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUserListsRequest(const GetUserListsRequest& from);
  GetUserListsRequest(GetUserListsRequest&& from) noexcept
    : GetUserListsRequest() {
    *this = ::std::move(from);
  }

  inline GetUserListsRequest& operator=(const GetUserListsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserListsRequest& operator=(GetUserListsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUserListsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserListsRequest* internal_default_instance() {
    return reinterpret_cast<const GetUserListsRequest*>(
               &_GetUserListsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetUserListsRequest& a, GetUserListsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserListsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserListsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserListsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUserListsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetUserListsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetUserListsRequest& from) {
    GetUserListsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUserListsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.list.v1.GetUserListsRequest";
  }
  protected:
  explicit GetUserListsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kRequesterIdFieldNumber = 2,
    kCursorFieldNumber = 4,
    kLimitFieldNumber = 3,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string requester_id = 2;
  void clear_requester_id();
  const std::string& requester_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_requester_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_requester_id();
  PROTOBUF_NODISCARD std::string* release_requester_id();
  void set_allocated_requester_id(std::string* requester_id);
  private:
  const std::string& _internal_requester_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_requester_id(const std::string& value);
  std::string* _internal_mutable_requester_id();
  public:

  // string cursor = 4;
  void clear_cursor();
  const std::string& cursor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cursor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cursor();
  PROTOBUF_NODISCARD std::string* release_cursor();
  void set_allocated_cursor(std::string* cursor);
  private:
  const std::string& _internal_cursor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cursor(const std::string& value);
  std::string* _internal_mutable_cursor();
  public:

  // int32 limit = 3;
  void clear_limit();
  int32_t limit() const;
  void set_limit(int32_t value);
  private:
  int32_t _internal_limit() const;
  void _internal_set_limit(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.list.v1.GetUserListsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr requester_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cursor_;
    int32_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2flist_5fservice_2eproto;
};
// -------------------------------------------------------------------

class GetUserListsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.list.v1.GetUserListsResponse) */ {
 public:
  inline GetUserListsResponse() : GetUserListsResponse(nullptr) {}
  ~GetUserListsResponse() override;
  explicit PROTOBUF_CONSTEXPR GetUserListsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUserListsResponse(const GetUserListsResponse& from);
  GetUserListsResponse(GetUserListsResponse&& from) noexcept
    : GetUserListsResponse() {
    *this = ::std::move(from);
  }

  inline GetUserListsResponse& operator=(const GetUserListsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserListsResponse& operator=(GetUserListsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUserListsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserListsResponse* internal_default_instance() {
    return reinterpret_cast<const GetUserListsResponse*>(
               &_GetUserListsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetUserListsResponse& a, GetUserListsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserListsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserListsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserListsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUserListsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetUserListsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetUserListsResponse& from) {
    GetUserListsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUserListsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.list.v1.GetUserListsResponse";
  }
  protected:
  explicit GetUserListsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListsFieldNumber = 2,
    kNextCursorFieldNumber = 3,
    kErrorMessageFieldNumber = 4,
    kSuccessFieldNumber = 1,
  };
  // repeated .sonet.list.v1.List lists = 2;
  int lists_size() const;
  private:
  int _internal_lists_size() const;
  public:
  void clear_lists();
  ::sonet::list::v1::List* mutable_lists(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::list::v1::List >*
      mutable_lists();
  private:
  const ::sonet::list::v1::List& _internal_lists(int index) const;
  ::sonet::list::v1::List* _internal_add_lists();
  public:
  const ::sonet::list::v1::List& lists(int index) const;
  ::sonet::list::v1::List* add_lists();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::list::v1::List >&
      lists() const;

  // string next_cursor = 3;
  void clear_next_cursor();
  const std::string& next_cursor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_cursor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_cursor();
  PROTOBUF_NODISCARD std::string* release_next_cursor();
  void set_allocated_next_cursor(std::string* next_cursor);
  private:
  const std::string& _internal_next_cursor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_cursor(const std::string& value);
  std::string* _internal_mutable_next_cursor();
  public:

  // string error_message = 4;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.list.v1.GetUserListsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::list::v1::List > lists_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_cursor_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2flist_5fservice_2eproto;
};
// -------------------------------------------------------------------

class UpdateListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.list.v1.UpdateListRequest) */ {
 public:
  inline UpdateListRequest() : UpdateListRequest(nullptr) {}
  ~UpdateListRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateListRequest(const UpdateListRequest& from);
  UpdateListRequest(UpdateListRequest&& from) noexcept
    : UpdateListRequest() {
    *this = ::std::move(from);
  }

  inline UpdateListRequest& operator=(const UpdateListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateListRequest& operator=(UpdateListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateListRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateListRequest*>(
               &_UpdateListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(UpdateListRequest& a, UpdateListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateListRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateListRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateListRequest& from) {
    UpdateListRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateListRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.list.v1.UpdateListRequest";
  }
  protected:
  explicit UpdateListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListIdFieldNumber = 1,
    kRequesterIdFieldNumber = 2,
    kNameFieldNumber = 3,
    kDescriptionFieldNumber = 4,
    kIsPublicFieldNumber = 5,
    kListTypeFieldNumber = 6,
  };
  // string list_id = 1;
  void clear_list_id();
  const std::string& list_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_list_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_list_id();
  PROTOBUF_NODISCARD std::string* release_list_id();
  void set_allocated_list_id(std::string* list_id);
  private:
  const std::string& _internal_list_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_list_id(const std::string& value);
  std::string* _internal_mutable_list_id();
  public:

  // string requester_id = 2;
  void clear_requester_id();
  const std::string& requester_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_requester_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_requester_id();
  PROTOBUF_NODISCARD std::string* release_requester_id();
  void set_allocated_requester_id(std::string* requester_id);
  private:
  const std::string& _internal_requester_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_requester_id(const std::string& value);
  std::string* _internal_mutable_requester_id();
  public:

  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 4;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // bool is_public = 5;
  void clear_is_public();
  bool is_public() const;
  void set_is_public(bool value);
  private:
  bool _internal_is_public() const;
  void _internal_set_is_public(bool value);
  public:

  // .sonet.list.v1.ListType list_type = 6;
  void clear_list_type();
  ::sonet::list::v1::ListType list_type() const;
  void set_list_type(::sonet::list::v1::ListType value);
  private:
  ::sonet::list::v1::ListType _internal_list_type() const;
  void _internal_set_list_type(::sonet::list::v1::ListType value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.list.v1.UpdateListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr list_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr requester_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    bool is_public_;
    int list_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2flist_5fservice_2eproto;
};
// -------------------------------------------------------------------

class UpdateListResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.list.v1.UpdateListResponse) */ {
 public:
  inline UpdateListResponse() : UpdateListResponse(nullptr) {}
  ~UpdateListResponse() override;
  explicit PROTOBUF_CONSTEXPR UpdateListResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateListResponse(const UpdateListResponse& from);
  UpdateListResponse(UpdateListResponse&& from) noexcept
    : UpdateListResponse() {
    *this = ::std::move(from);
  }

  inline UpdateListResponse& operator=(const UpdateListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateListResponse& operator=(UpdateListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateListResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateListResponse*>(
               &_UpdateListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UpdateListResponse& a, UpdateListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateListResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateListResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateListResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateListResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateListResponse& from) {
    UpdateListResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateListResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.list.v1.UpdateListResponse";
  }
  protected:
  explicit UpdateListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 3,
    kListFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string error_message = 3;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // .sonet.list.v1.List list = 2;
  bool has_list() const;
  private:
  bool _internal_has_list() const;
  public:
  void clear_list();
  const ::sonet::list::v1::List& list() const;
  PROTOBUF_NODISCARD ::sonet::list::v1::List* release_list();
  ::sonet::list::v1::List* mutable_list();
  void set_allocated_list(::sonet::list::v1::List* list);
  private:
  const ::sonet::list::v1::List& _internal_list() const;
  ::sonet::list::v1::List* _internal_mutable_list();
  public:
  void unsafe_arena_set_allocated_list(
      ::sonet::list::v1::List* list);
  ::sonet::list::v1::List* unsafe_arena_release_list();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.list.v1.UpdateListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    ::sonet::list::v1::List* list_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2flist_5fservice_2eproto;
};
// -------------------------------------------------------------------

class DeleteListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.list.v1.DeleteListRequest) */ {
 public:
  inline DeleteListRequest() : DeleteListRequest(nullptr) {}
  ~DeleteListRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteListRequest(const DeleteListRequest& from);
  DeleteListRequest(DeleteListRequest&& from) noexcept
    : DeleteListRequest() {
    *this = ::std::move(from);
  }

  inline DeleteListRequest& operator=(const DeleteListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteListRequest& operator=(DeleteListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteListRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteListRequest*>(
               &_DeleteListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(DeleteListRequest& a, DeleteListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteListRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteListRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteListRequest& from) {
    DeleteListRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteListRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.list.v1.DeleteListRequest";
  }
  protected:
  explicit DeleteListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListIdFieldNumber = 1,
    kRequesterIdFieldNumber = 2,
  };
  // string list_id = 1;
  void clear_list_id();
  const std::string& list_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_list_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_list_id();
  PROTOBUF_NODISCARD std::string* release_list_id();
  void set_allocated_list_id(std::string* list_id);
  private:
  const std::string& _internal_list_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_list_id(const std::string& value);
  std::string* _internal_mutable_list_id();
  public:

  // string requester_id = 2;
  void clear_requester_id();
  const std::string& requester_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_requester_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_requester_id();
  PROTOBUF_NODISCARD std::string* release_requester_id();
  void set_allocated_requester_id(std::string* requester_id);
  private:
  const std::string& _internal_requester_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_requester_id(const std::string& value);
  std::string* _internal_mutable_requester_id();
  public:

  // @@protoc_insertion_point(class_scope:sonet.list.v1.DeleteListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr list_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr requester_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2flist_5fservice_2eproto;
};
// -------------------------------------------------------------------

class DeleteListResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.list.v1.DeleteListResponse) */ {
 public:
  inline DeleteListResponse() : DeleteListResponse(nullptr) {}
  ~DeleteListResponse() override;
  explicit PROTOBUF_CONSTEXPR DeleteListResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteListResponse(const DeleteListResponse& from);
  DeleteListResponse(DeleteListResponse&& from) noexcept
    : DeleteListResponse() {
    *this = ::std::move(from);
  }

  inline DeleteListResponse& operator=(const DeleteListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteListResponse& operator=(DeleteListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteListResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteListResponse*>(
               &_DeleteListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(DeleteListResponse& a, DeleteListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteListResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteListResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteListResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteListResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteListResponse& from) {
    DeleteListResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteListResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.list.v1.DeleteListResponse";
  }
  protected:
  explicit DeleteListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string error_message = 2;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.list.v1.DeleteListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2flist_5fservice_2eproto;
};
// -------------------------------------------------------------------

class AddListMemberRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.list.v1.AddListMemberRequest) */ {
 public:
  inline AddListMemberRequest() : AddListMemberRequest(nullptr) {}
  ~AddListMemberRequest() override;
  explicit PROTOBUF_CONSTEXPR AddListMemberRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddListMemberRequest(const AddListMemberRequest& from);
  AddListMemberRequest(AddListMemberRequest&& from) noexcept
    : AddListMemberRequest() {
    *this = ::std::move(from);
  }

  inline AddListMemberRequest& operator=(const AddListMemberRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddListMemberRequest& operator=(AddListMemberRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddListMemberRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddListMemberRequest* internal_default_instance() {
    return reinterpret_cast<const AddListMemberRequest*>(
               &_AddListMemberRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(AddListMemberRequest& a, AddListMemberRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddListMemberRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddListMemberRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddListMemberRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddListMemberRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddListMemberRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddListMemberRequest& from) {
    AddListMemberRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddListMemberRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.list.v1.AddListMemberRequest";
  }
  protected:
  explicit AddListMemberRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListIdFieldNumber = 1,
    kUserIdFieldNumber = 2,
    kAddedByFieldNumber = 3,
    kNotesFieldNumber = 4,
  };
  // string list_id = 1;
  void clear_list_id();
  const std::string& list_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_list_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_list_id();
  PROTOBUF_NODISCARD std::string* release_list_id();
  void set_allocated_list_id(std::string* list_id);
  private:
  const std::string& _internal_list_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_list_id(const std::string& value);
  std::string* _internal_mutable_list_id();
  public:

  // string user_id = 2;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string added_by = 3;
  void clear_added_by();
  const std::string& added_by() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_added_by(ArgT0&& arg0, ArgT... args);
  std::string* mutable_added_by();
  PROTOBUF_NODISCARD std::string* release_added_by();
  void set_allocated_added_by(std::string* added_by);
  private:
  const std::string& _internal_added_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_added_by(const std::string& value);
  std::string* _internal_mutable_added_by();
  public:

  // string notes = 4;
  void clear_notes();
  const std::string& notes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_notes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_notes();
  PROTOBUF_NODISCARD std::string* release_notes();
  void set_allocated_notes(std::string* notes);
  private:
  const std::string& _internal_notes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_notes(const std::string& value);
  std::string* _internal_mutable_notes();
  public:

  // @@protoc_insertion_point(class_scope:sonet.list.v1.AddListMemberRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr list_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr added_by_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr notes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2flist_5fservice_2eproto;
};
// -------------------------------------------------------------------

class AddListMemberResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.list.v1.AddListMemberResponse) */ {
 public:
  inline AddListMemberResponse() : AddListMemberResponse(nullptr) {}
  ~AddListMemberResponse() override;
  explicit PROTOBUF_CONSTEXPR AddListMemberResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddListMemberResponse(const AddListMemberResponse& from);
  AddListMemberResponse(AddListMemberResponse&& from) noexcept
    : AddListMemberResponse() {
    *this = ::std::move(from);
  }

  inline AddListMemberResponse& operator=(const AddListMemberResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddListMemberResponse& operator=(AddListMemberResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddListMemberResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddListMemberResponse* internal_default_instance() {
    return reinterpret_cast<const AddListMemberResponse*>(
               &_AddListMemberResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(AddListMemberResponse& a, AddListMemberResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AddListMemberResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddListMemberResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddListMemberResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddListMemberResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddListMemberResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddListMemberResponse& from) {
    AddListMemberResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddListMemberResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.list.v1.AddListMemberResponse";
  }
  protected:
  explicit AddListMemberResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 3,
    kMemberFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string error_message = 3;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // .sonet.list.v1.ListMember member = 2;
  bool has_member() const;
  private:
  bool _internal_has_member() const;
  public:
  void clear_member();
  const ::sonet::list::v1::ListMember& member() const;
  PROTOBUF_NODISCARD ::sonet::list::v1::ListMember* release_member();
  ::sonet::list::v1::ListMember* mutable_member();
  void set_allocated_member(::sonet::list::v1::ListMember* member);
  private:
  const ::sonet::list::v1::ListMember& _internal_member() const;
  ::sonet::list::v1::ListMember* _internal_mutable_member();
  public:
  void unsafe_arena_set_allocated_member(
      ::sonet::list::v1::ListMember* member);
  ::sonet::list::v1::ListMember* unsafe_arena_release_member();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.list.v1.AddListMemberResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    ::sonet::list::v1::ListMember* member_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2flist_5fservice_2eproto;
};
// -------------------------------------------------------------------

class RemoveListMemberRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.list.v1.RemoveListMemberRequest) */ {
 public:
  inline RemoveListMemberRequest() : RemoveListMemberRequest(nullptr) {}
  ~RemoveListMemberRequest() override;
  explicit PROTOBUF_CONSTEXPR RemoveListMemberRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveListMemberRequest(const RemoveListMemberRequest& from);
  RemoveListMemberRequest(RemoveListMemberRequest&& from) noexcept
    : RemoveListMemberRequest() {
    *this = ::std::move(from);
  }

  inline RemoveListMemberRequest& operator=(const RemoveListMemberRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveListMemberRequest& operator=(RemoveListMemberRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveListMemberRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveListMemberRequest* internal_default_instance() {
    return reinterpret_cast<const RemoveListMemberRequest*>(
               &_RemoveListMemberRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(RemoveListMemberRequest& a, RemoveListMemberRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveListMemberRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveListMemberRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveListMemberRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveListMemberRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoveListMemberRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RemoveListMemberRequest& from) {
    RemoveListMemberRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveListMemberRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.list.v1.RemoveListMemberRequest";
  }
  protected:
  explicit RemoveListMemberRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListIdFieldNumber = 1,
    kUserIdFieldNumber = 2,
    kRemovedByFieldNumber = 3,
  };
  // string list_id = 1;
  void clear_list_id();
  const std::string& list_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_list_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_list_id();
  PROTOBUF_NODISCARD std::string* release_list_id();
  void set_allocated_list_id(std::string* list_id);
  private:
  const std::string& _internal_list_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_list_id(const std::string& value);
  std::string* _internal_mutable_list_id();
  public:

  // string user_id = 2;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string removed_by = 3;
  void clear_removed_by();
  const std::string& removed_by() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_removed_by(ArgT0&& arg0, ArgT... args);
  std::string* mutable_removed_by();
  PROTOBUF_NODISCARD std::string* release_removed_by();
  void set_allocated_removed_by(std::string* removed_by);
  private:
  const std::string& _internal_removed_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_removed_by(const std::string& value);
  std::string* _internal_mutable_removed_by();
  public:

  // @@protoc_insertion_point(class_scope:sonet.list.v1.RemoveListMemberRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr list_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr removed_by_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2flist_5fservice_2eproto;
};
// -------------------------------------------------------------------

class RemoveListMemberResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.list.v1.RemoveListMemberResponse) */ {
 public:
  inline RemoveListMemberResponse() : RemoveListMemberResponse(nullptr) {}
  ~RemoveListMemberResponse() override;
  explicit PROTOBUF_CONSTEXPR RemoveListMemberResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveListMemberResponse(const RemoveListMemberResponse& from);
  RemoveListMemberResponse(RemoveListMemberResponse&& from) noexcept
    : RemoveListMemberResponse() {
    *this = ::std::move(from);
  }

  inline RemoveListMemberResponse& operator=(const RemoveListMemberResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveListMemberResponse& operator=(RemoveListMemberResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveListMemberResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveListMemberResponse* internal_default_instance() {
    return reinterpret_cast<const RemoveListMemberResponse*>(
               &_RemoveListMemberResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(RemoveListMemberResponse& a, RemoveListMemberResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveListMemberResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveListMemberResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveListMemberResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveListMemberResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoveListMemberResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RemoveListMemberResponse& from) {
    RemoveListMemberResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveListMemberResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.list.v1.RemoveListMemberResponse";
  }
  protected:
  explicit RemoveListMemberResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string error_message = 2;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.list.v1.RemoveListMemberResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2flist_5fservice_2eproto;
};
// -------------------------------------------------------------------

class GetListMembersRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.list.v1.GetListMembersRequest) */ {
 public:
  inline GetListMembersRequest() : GetListMembersRequest(nullptr) {}
  ~GetListMembersRequest() override;
  explicit PROTOBUF_CONSTEXPR GetListMembersRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetListMembersRequest(const GetListMembersRequest& from);
  GetListMembersRequest(GetListMembersRequest&& from) noexcept
    : GetListMembersRequest() {
    *this = ::std::move(from);
  }

  inline GetListMembersRequest& operator=(const GetListMembersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetListMembersRequest& operator=(GetListMembersRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetListMembersRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetListMembersRequest* internal_default_instance() {
    return reinterpret_cast<const GetListMembersRequest*>(
               &_GetListMembersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GetListMembersRequest& a, GetListMembersRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetListMembersRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetListMembersRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetListMembersRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetListMembersRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetListMembersRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetListMembersRequest& from) {
    GetListMembersRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetListMembersRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.list.v1.GetListMembersRequest";
  }
  protected:
  explicit GetListMembersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListIdFieldNumber = 1,
    kRequesterIdFieldNumber = 2,
    kCursorFieldNumber = 4,
    kLimitFieldNumber = 3,
  };
  // string list_id = 1;
  void clear_list_id();
  const std::string& list_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_list_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_list_id();
  PROTOBUF_NODISCARD std::string* release_list_id();
  void set_allocated_list_id(std::string* list_id);
  private:
  const std::string& _internal_list_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_list_id(const std::string& value);
  std::string* _internal_mutable_list_id();
  public:

  // string requester_id = 2;
  void clear_requester_id();
  const std::string& requester_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_requester_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_requester_id();
  PROTOBUF_NODISCARD std::string* release_requester_id();
  void set_allocated_requester_id(std::string* requester_id);
  private:
  const std::string& _internal_requester_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_requester_id(const std::string& value);
  std::string* _internal_mutable_requester_id();
  public:

  // string cursor = 4;
  void clear_cursor();
  const std::string& cursor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cursor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cursor();
  PROTOBUF_NODISCARD std::string* release_cursor();
  void set_allocated_cursor(std::string* cursor);
  private:
  const std::string& _internal_cursor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cursor(const std::string& value);
  std::string* _internal_mutable_cursor();
  public:

  // int32 limit = 3;
  void clear_limit();
  int32_t limit() const;
  void set_limit(int32_t value);
  private:
  int32_t _internal_limit() const;
  void _internal_set_limit(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.list.v1.GetListMembersRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr list_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr requester_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cursor_;
    int32_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2flist_5fservice_2eproto;
};
// -------------------------------------------------------------------

class GetListMembersResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.list.v1.GetListMembersResponse) */ {
 public:
  inline GetListMembersResponse() : GetListMembersResponse(nullptr) {}
  ~GetListMembersResponse() override;
  explicit PROTOBUF_CONSTEXPR GetListMembersResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetListMembersResponse(const GetListMembersResponse& from);
  GetListMembersResponse(GetListMembersResponse&& from) noexcept
    : GetListMembersResponse() {
    *this = ::std::move(from);
  }

  inline GetListMembersResponse& operator=(const GetListMembersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetListMembersResponse& operator=(GetListMembersResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetListMembersResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetListMembersResponse* internal_default_instance() {
    return reinterpret_cast<const GetListMembersResponse*>(
               &_GetListMembersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(GetListMembersResponse& a, GetListMembersResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetListMembersResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetListMembersResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetListMembersResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetListMembersResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetListMembersResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetListMembersResponse& from) {
    GetListMembersResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetListMembersResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.list.v1.GetListMembersResponse";
  }
  protected:
  explicit GetListMembersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMembersFieldNumber = 2,
    kNextCursorFieldNumber = 3,
    kErrorMessageFieldNumber = 4,
    kSuccessFieldNumber = 1,
  };
  // repeated .sonet.list.v1.ListMember members = 2;
  int members_size() const;
  private:
  int _internal_members_size() const;
  public:
  void clear_members();
  ::sonet::list::v1::ListMember* mutable_members(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::list::v1::ListMember >*
      mutable_members();
  private:
  const ::sonet::list::v1::ListMember& _internal_members(int index) const;
  ::sonet::list::v1::ListMember* _internal_add_members();
  public:
  const ::sonet::list::v1::ListMember& members(int index) const;
  ::sonet::list::v1::ListMember* add_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::list::v1::ListMember >&
      members() const;

  // string next_cursor = 3;
  void clear_next_cursor();
  const std::string& next_cursor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_cursor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_cursor();
  PROTOBUF_NODISCARD std::string* release_next_cursor();
  void set_allocated_next_cursor(std::string* next_cursor);
  private:
  const std::string& _internal_next_cursor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_cursor(const std::string& value);
  std::string* _internal_mutable_next_cursor();
  public:

  // string error_message = 4;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.list.v1.GetListMembersResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::list::v1::ListMember > members_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_cursor_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2flist_5fservice_2eproto;
};
// -------------------------------------------------------------------

class IsUserInListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.list.v1.IsUserInListRequest) */ {
 public:
  inline IsUserInListRequest() : IsUserInListRequest(nullptr) {}
  ~IsUserInListRequest() override;
  explicit PROTOBUF_CONSTEXPR IsUserInListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IsUserInListRequest(const IsUserInListRequest& from);
  IsUserInListRequest(IsUserInListRequest&& from) noexcept
    : IsUserInListRequest() {
    *this = ::std::move(from);
  }

  inline IsUserInListRequest& operator=(const IsUserInListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline IsUserInListRequest& operator=(IsUserInListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IsUserInListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const IsUserInListRequest* internal_default_instance() {
    return reinterpret_cast<const IsUserInListRequest*>(
               &_IsUserInListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(IsUserInListRequest& a, IsUserInListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(IsUserInListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IsUserInListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IsUserInListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IsUserInListRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IsUserInListRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IsUserInListRequest& from) {
    IsUserInListRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IsUserInListRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.list.v1.IsUserInListRequest";
  }
  protected:
  explicit IsUserInListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListIdFieldNumber = 1,
    kUserIdFieldNumber = 2,
    kRequesterIdFieldNumber = 3,
  };
  // string list_id = 1;
  void clear_list_id();
  const std::string& list_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_list_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_list_id();
  PROTOBUF_NODISCARD std::string* release_list_id();
  void set_allocated_list_id(std::string* list_id);
  private:
  const std::string& _internal_list_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_list_id(const std::string& value);
  std::string* _internal_mutable_list_id();
  public:

  // string user_id = 2;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string requester_id = 3;
  void clear_requester_id();
  const std::string& requester_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_requester_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_requester_id();
  PROTOBUF_NODISCARD std::string* release_requester_id();
  void set_allocated_requester_id(std::string* requester_id);
  private:
  const std::string& _internal_requester_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_requester_id(const std::string& value);
  std::string* _internal_mutable_requester_id();
  public:

  // @@protoc_insertion_point(class_scope:sonet.list.v1.IsUserInListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr list_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr requester_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2flist_5fservice_2eproto;
};
// -------------------------------------------------------------------

class IsUserInListResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.list.v1.IsUserInListResponse) */ {
 public:
  inline IsUserInListResponse() : IsUserInListResponse(nullptr) {}
  ~IsUserInListResponse() override;
  explicit PROTOBUF_CONSTEXPR IsUserInListResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IsUserInListResponse(const IsUserInListResponse& from);
  IsUserInListResponse(IsUserInListResponse&& from) noexcept
    : IsUserInListResponse() {
    *this = ::std::move(from);
  }

  inline IsUserInListResponse& operator=(const IsUserInListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline IsUserInListResponse& operator=(IsUserInListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IsUserInListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const IsUserInListResponse* internal_default_instance() {
    return reinterpret_cast<const IsUserInListResponse*>(
               &_IsUserInListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(IsUserInListResponse& a, IsUserInListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(IsUserInListResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IsUserInListResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IsUserInListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IsUserInListResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IsUserInListResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IsUserInListResponse& from) {
    IsUserInListResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IsUserInListResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.list.v1.IsUserInListResponse";
  }
  protected:
  explicit IsUserInListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 3,
    kSuccessFieldNumber = 1,
    kIsMemberFieldNumber = 2,
  };
  // string error_message = 3;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // bool is_member = 2;
  void clear_is_member();
  bool is_member() const;
  void set_is_member(bool value);
  private:
  bool _internal_is_member() const;
  void _internal_set_is_member(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.list.v1.IsUserInListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    bool success_;
    bool is_member_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2flist_5fservice_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// List

// string list_id = 1;
inline void List::clear_list_id() {
  _impl_.list_id_.ClearToEmpty();
}
inline const std::string& List::list_id() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.List.list_id)
  return _internal_list_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void List::set_list_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.list_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.List.list_id)
}
inline std::string* List::mutable_list_id() {
  std::string* _s = _internal_mutable_list_id();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.List.list_id)
  return _s;
}
inline const std::string& List::_internal_list_id() const {
  return _impl_.list_id_.Get();
}
inline void List::_internal_set_list_id(const std::string& value) {
  
  _impl_.list_id_.Set(value, GetArenaForAllocation());
}
inline std::string* List::_internal_mutable_list_id() {
  
  return _impl_.list_id_.Mutable(GetArenaForAllocation());
}
inline std::string* List::release_list_id() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.List.list_id)
  return _impl_.list_id_.Release();
}
inline void List::set_allocated_list_id(std::string* list_id) {
  if (list_id != nullptr) {
    
  } else {
    
  }
  _impl_.list_id_.SetAllocated(list_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.list_id_.IsDefault()) {
    _impl_.list_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.List.list_id)
}

// string owner_id = 2;
inline void List::clear_owner_id() {
  _impl_.owner_id_.ClearToEmpty();
}
inline const std::string& List::owner_id() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.List.owner_id)
  return _internal_owner_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void List::set_owner_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.List.owner_id)
}
inline std::string* List::mutable_owner_id() {
  std::string* _s = _internal_mutable_owner_id();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.List.owner_id)
  return _s;
}
inline const std::string& List::_internal_owner_id() const {
  return _impl_.owner_id_.Get();
}
inline void List::_internal_set_owner_id(const std::string& value) {
  
  _impl_.owner_id_.Set(value, GetArenaForAllocation());
}
inline std::string* List::_internal_mutable_owner_id() {
  
  return _impl_.owner_id_.Mutable(GetArenaForAllocation());
}
inline std::string* List::release_owner_id() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.List.owner_id)
  return _impl_.owner_id_.Release();
}
inline void List::set_allocated_owner_id(std::string* owner_id) {
  if (owner_id != nullptr) {
    
  } else {
    
  }
  _impl_.owner_id_.SetAllocated(owner_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_id_.IsDefault()) {
    _impl_.owner_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.List.owner_id)
}

// string name = 3;
inline void List::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& List::name() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.List.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void List::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.List.name)
}
inline std::string* List::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.List.name)
  return _s;
}
inline const std::string& List::_internal_name() const {
  return _impl_.name_.Get();
}
inline void List::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* List::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* List::release_name() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.List.name)
  return _impl_.name_.Release();
}
inline void List::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.List.name)
}

// string description = 4;
inline void List::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& List::description() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.List.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void List::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.List.description)
}
inline std::string* List::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.List.description)
  return _s;
}
inline const std::string& List::_internal_description() const {
  return _impl_.description_.Get();
}
inline void List::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* List::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* List::release_description() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.List.description)
  return _impl_.description_.Release();
}
inline void List::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.List.description)
}

// bool is_public = 5;
inline void List::clear_is_public() {
  _impl_.is_public_ = false;
}
inline bool List::_internal_is_public() const {
  return _impl_.is_public_;
}
inline bool List::is_public() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.List.is_public)
  return _internal_is_public();
}
inline void List::_internal_set_is_public(bool value) {
  
  _impl_.is_public_ = value;
}
inline void List::set_is_public(bool value) {
  _internal_set_is_public(value);
  // @@protoc_insertion_point(field_set:sonet.list.v1.List.is_public)
}

// .sonet.list.v1.ListType list_type = 6;
inline void List::clear_list_type() {
  _impl_.list_type_ = 0;
}
inline ::sonet::list::v1::ListType List::_internal_list_type() const {
  return static_cast< ::sonet::list::v1::ListType >(_impl_.list_type_);
}
inline ::sonet::list::v1::ListType List::list_type() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.List.list_type)
  return _internal_list_type();
}
inline void List::_internal_set_list_type(::sonet::list::v1::ListType value) {
  
  _impl_.list_type_ = value;
}
inline void List::set_list_type(::sonet::list::v1::ListType value) {
  _internal_set_list_type(value);
  // @@protoc_insertion_point(field_set:sonet.list.v1.List.list_type)
}

// .google.protobuf.Timestamp created_at = 7;
inline bool List::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool List::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& List::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& List::created_at() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.List.created_at)
  return _internal_created_at();
}
inline void List::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.list.v1.List.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* List::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* List::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.List.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* List::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* List::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.List.created_at)
  return _msg;
}
inline void List::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.List.created_at)
}

// .google.protobuf.Timestamp updated_at = 8;
inline bool List::_internal_has_updated_at() const {
  return this != internal_default_instance() && _impl_.updated_at_ != nullptr;
}
inline bool List::has_updated_at() const {
  return _internal_has_updated_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& List::_internal_updated_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.updated_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& List::updated_at() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.List.updated_at)
  return _internal_updated_at();
}
inline void List::unsafe_arena_set_allocated_updated_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.updated_at_);
  }
  _impl_.updated_at_ = updated_at;
  if (updated_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.list.v1.List.updated_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* List::release_updated_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* List::unsafe_arena_release_updated_at() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.List.updated_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* List::_internal_mutable_updated_at() {
  
  if (_impl_.updated_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.updated_at_ = p;
  }
  return _impl_.updated_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* List::mutable_updated_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.List.updated_at)
  return _msg;
}
inline void List::set_allocated_updated_at(::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.updated_at_);
  }
  if (updated_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at));
    if (message_arena != submessage_arena) {
      updated_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, updated_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.updated_at_ = updated_at;
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.List.updated_at)
}

// int32 member_count = 9;
inline void List::clear_member_count() {
  _impl_.member_count_ = 0;
}
inline int32_t List::_internal_member_count() const {
  return _impl_.member_count_;
}
inline int32_t List::member_count() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.List.member_count)
  return _internal_member_count();
}
inline void List::_internal_set_member_count(int32_t value) {
  
  _impl_.member_count_ = value;
}
inline void List::set_member_count(int32_t value) {
  _internal_set_member_count(value);
  // @@protoc_insertion_point(field_set:sonet.list.v1.List.member_count)
}

// -------------------------------------------------------------------

// ListMember

// string list_id = 1;
inline void ListMember::clear_list_id() {
  _impl_.list_id_.ClearToEmpty();
}
inline const std::string& ListMember::list_id() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.ListMember.list_id)
  return _internal_list_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListMember::set_list_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.list_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.ListMember.list_id)
}
inline std::string* ListMember::mutable_list_id() {
  std::string* _s = _internal_mutable_list_id();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.ListMember.list_id)
  return _s;
}
inline const std::string& ListMember::_internal_list_id() const {
  return _impl_.list_id_.Get();
}
inline void ListMember::_internal_set_list_id(const std::string& value) {
  
  _impl_.list_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListMember::_internal_mutable_list_id() {
  
  return _impl_.list_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListMember::release_list_id() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.ListMember.list_id)
  return _impl_.list_id_.Release();
}
inline void ListMember::set_allocated_list_id(std::string* list_id) {
  if (list_id != nullptr) {
    
  } else {
    
  }
  _impl_.list_id_.SetAllocated(list_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.list_id_.IsDefault()) {
    _impl_.list_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.ListMember.list_id)
}

// string user_id = 2;
inline void ListMember::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& ListMember::user_id() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.ListMember.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListMember::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.ListMember.user_id)
}
inline std::string* ListMember::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.ListMember.user_id)
  return _s;
}
inline const std::string& ListMember::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void ListMember::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListMember::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListMember::release_user_id() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.ListMember.user_id)
  return _impl_.user_id_.Release();
}
inline void ListMember::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.ListMember.user_id)
}

// string added_by = 3;
inline void ListMember::clear_added_by() {
  _impl_.added_by_.ClearToEmpty();
}
inline const std::string& ListMember::added_by() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.ListMember.added_by)
  return _internal_added_by();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListMember::set_added_by(ArgT0&& arg0, ArgT... args) {
 
 _impl_.added_by_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.ListMember.added_by)
}
inline std::string* ListMember::mutable_added_by() {
  std::string* _s = _internal_mutable_added_by();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.ListMember.added_by)
  return _s;
}
inline const std::string& ListMember::_internal_added_by() const {
  return _impl_.added_by_.Get();
}
inline void ListMember::_internal_set_added_by(const std::string& value) {
  
  _impl_.added_by_.Set(value, GetArenaForAllocation());
}
inline std::string* ListMember::_internal_mutable_added_by() {
  
  return _impl_.added_by_.Mutable(GetArenaForAllocation());
}
inline std::string* ListMember::release_added_by() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.ListMember.added_by)
  return _impl_.added_by_.Release();
}
inline void ListMember::set_allocated_added_by(std::string* added_by) {
  if (added_by != nullptr) {
    
  } else {
    
  }
  _impl_.added_by_.SetAllocated(added_by, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.added_by_.IsDefault()) {
    _impl_.added_by_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.ListMember.added_by)
}

// string notes = 4;
inline void ListMember::clear_notes() {
  _impl_.notes_.ClearToEmpty();
}
inline const std::string& ListMember::notes() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.ListMember.notes)
  return _internal_notes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListMember::set_notes(ArgT0&& arg0, ArgT... args) {
 
 _impl_.notes_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.ListMember.notes)
}
inline std::string* ListMember::mutable_notes() {
  std::string* _s = _internal_mutable_notes();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.ListMember.notes)
  return _s;
}
inline const std::string& ListMember::_internal_notes() const {
  return _impl_.notes_.Get();
}
inline void ListMember::_internal_set_notes(const std::string& value) {
  
  _impl_.notes_.Set(value, GetArenaForAllocation());
}
inline std::string* ListMember::_internal_mutable_notes() {
  
  return _impl_.notes_.Mutable(GetArenaForAllocation());
}
inline std::string* ListMember::release_notes() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.ListMember.notes)
  return _impl_.notes_.Release();
}
inline void ListMember::set_allocated_notes(std::string* notes) {
  if (notes != nullptr) {
    
  } else {
    
  }
  _impl_.notes_.SetAllocated(notes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.notes_.IsDefault()) {
    _impl_.notes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.ListMember.notes)
}

// .google.protobuf.Timestamp added_at = 5;
inline bool ListMember::_internal_has_added_at() const {
  return this != internal_default_instance() && _impl_.added_at_ != nullptr;
}
inline bool ListMember::has_added_at() const {
  return _internal_has_added_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ListMember::_internal_added_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.added_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ListMember::added_at() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.ListMember.added_at)
  return _internal_added_at();
}
inline void ListMember::unsafe_arena_set_allocated_added_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* added_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.added_at_);
  }
  _impl_.added_at_ = added_at;
  if (added_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.list.v1.ListMember.added_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListMember::release_added_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.added_at_;
  _impl_.added_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListMember::unsafe_arena_release_added_at() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.ListMember.added_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.added_at_;
  _impl_.added_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListMember::_internal_mutable_added_at() {
  
  if (_impl_.added_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.added_at_ = p;
  }
  return _impl_.added_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListMember::mutable_added_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_added_at();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.ListMember.added_at)
  return _msg;
}
inline void ListMember::set_allocated_added_at(::PROTOBUF_NAMESPACE_ID::Timestamp* added_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.added_at_);
  }
  if (added_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(added_at));
    if (message_arena != submessage_arena) {
      added_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, added_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.added_at_ = added_at;
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.ListMember.added_at)
}

// -------------------------------------------------------------------

// CreateListRequest

// string owner_id = 1;
inline void CreateListRequest::clear_owner_id() {
  _impl_.owner_id_.ClearToEmpty();
}
inline const std::string& CreateListRequest::owner_id() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.CreateListRequest.owner_id)
  return _internal_owner_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateListRequest::set_owner_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.CreateListRequest.owner_id)
}
inline std::string* CreateListRequest::mutable_owner_id() {
  std::string* _s = _internal_mutable_owner_id();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.CreateListRequest.owner_id)
  return _s;
}
inline const std::string& CreateListRequest::_internal_owner_id() const {
  return _impl_.owner_id_.Get();
}
inline void CreateListRequest::_internal_set_owner_id(const std::string& value) {
  
  _impl_.owner_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateListRequest::_internal_mutable_owner_id() {
  
  return _impl_.owner_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateListRequest::release_owner_id() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.CreateListRequest.owner_id)
  return _impl_.owner_id_.Release();
}
inline void CreateListRequest::set_allocated_owner_id(std::string* owner_id) {
  if (owner_id != nullptr) {
    
  } else {
    
  }
  _impl_.owner_id_.SetAllocated(owner_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_id_.IsDefault()) {
    _impl_.owner_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.CreateListRequest.owner_id)
}

// string name = 2;
inline void CreateListRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CreateListRequest::name() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.CreateListRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateListRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.CreateListRequest.name)
}
inline std::string* CreateListRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.CreateListRequest.name)
  return _s;
}
inline const std::string& CreateListRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CreateListRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateListRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateListRequest::release_name() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.CreateListRequest.name)
  return _impl_.name_.Release();
}
inline void CreateListRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.CreateListRequest.name)
}

// string description = 3;
inline void CreateListRequest::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& CreateListRequest::description() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.CreateListRequest.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateListRequest::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.CreateListRequest.description)
}
inline std::string* CreateListRequest::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.CreateListRequest.description)
  return _s;
}
inline const std::string& CreateListRequest::_internal_description() const {
  return _impl_.description_.Get();
}
inline void CreateListRequest::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateListRequest::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateListRequest::release_description() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.CreateListRequest.description)
  return _impl_.description_.Release();
}
inline void CreateListRequest::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.CreateListRequest.description)
}

// bool is_public = 4;
inline void CreateListRequest::clear_is_public() {
  _impl_.is_public_ = false;
}
inline bool CreateListRequest::_internal_is_public() const {
  return _impl_.is_public_;
}
inline bool CreateListRequest::is_public() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.CreateListRequest.is_public)
  return _internal_is_public();
}
inline void CreateListRequest::_internal_set_is_public(bool value) {
  
  _impl_.is_public_ = value;
}
inline void CreateListRequest::set_is_public(bool value) {
  _internal_set_is_public(value);
  // @@protoc_insertion_point(field_set:sonet.list.v1.CreateListRequest.is_public)
}

// .sonet.list.v1.ListType list_type = 5;
inline void CreateListRequest::clear_list_type() {
  _impl_.list_type_ = 0;
}
inline ::sonet::list::v1::ListType CreateListRequest::_internal_list_type() const {
  return static_cast< ::sonet::list::v1::ListType >(_impl_.list_type_);
}
inline ::sonet::list::v1::ListType CreateListRequest::list_type() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.CreateListRequest.list_type)
  return _internal_list_type();
}
inline void CreateListRequest::_internal_set_list_type(::sonet::list::v1::ListType value) {
  
  _impl_.list_type_ = value;
}
inline void CreateListRequest::set_list_type(::sonet::list::v1::ListType value) {
  _internal_set_list_type(value);
  // @@protoc_insertion_point(field_set:sonet.list.v1.CreateListRequest.list_type)
}

// -------------------------------------------------------------------

// CreateListResponse

// bool success = 1;
inline void CreateListResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool CreateListResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool CreateListResponse::success() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.CreateListResponse.success)
  return _internal_success();
}
inline void CreateListResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void CreateListResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:sonet.list.v1.CreateListResponse.success)
}

// .sonet.list.v1.List list = 2;
inline bool CreateListResponse::_internal_has_list() const {
  return this != internal_default_instance() && _impl_.list_ != nullptr;
}
inline bool CreateListResponse::has_list() const {
  return _internal_has_list();
}
inline void CreateListResponse::clear_list() {
  if (GetArenaForAllocation() == nullptr && _impl_.list_ != nullptr) {
    delete _impl_.list_;
  }
  _impl_.list_ = nullptr;
}
inline const ::sonet::list::v1::List& CreateListResponse::_internal_list() const {
  const ::sonet::list::v1::List* p = _impl_.list_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::list::v1::List&>(
      ::sonet::list::v1::_List_default_instance_);
}
inline const ::sonet::list::v1::List& CreateListResponse::list() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.CreateListResponse.list)
  return _internal_list();
}
inline void CreateListResponse::unsafe_arena_set_allocated_list(
    ::sonet::list::v1::List* list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.list_);
  }
  _impl_.list_ = list;
  if (list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.list.v1.CreateListResponse.list)
}
inline ::sonet::list::v1::List* CreateListResponse::release_list() {
  
  ::sonet::list::v1::List* temp = _impl_.list_;
  _impl_.list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::list::v1::List* CreateListResponse::unsafe_arena_release_list() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.CreateListResponse.list)
  
  ::sonet::list::v1::List* temp = _impl_.list_;
  _impl_.list_ = nullptr;
  return temp;
}
inline ::sonet::list::v1::List* CreateListResponse::_internal_mutable_list() {
  
  if (_impl_.list_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::list::v1::List>(GetArenaForAllocation());
    _impl_.list_ = p;
  }
  return _impl_.list_;
}
inline ::sonet::list::v1::List* CreateListResponse::mutable_list() {
  ::sonet::list::v1::List* _msg = _internal_mutable_list();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.CreateListResponse.list)
  return _msg;
}
inline void CreateListResponse::set_allocated_list(::sonet::list::v1::List* list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.list_;
  }
  if (list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(list);
    if (message_arena != submessage_arena) {
      list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, list, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.list_ = list;
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.CreateListResponse.list)
}

// string error_message = 3;
inline void CreateListResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& CreateListResponse::error_message() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.CreateListResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateListResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.CreateListResponse.error_message)
}
inline std::string* CreateListResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.CreateListResponse.error_message)
  return _s;
}
inline const std::string& CreateListResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void CreateListResponse::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateListResponse::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateListResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.CreateListResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void CreateListResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.CreateListResponse.error_message)
}

// -------------------------------------------------------------------

// GetListRequest

// string list_id = 1;
inline void GetListRequest::clear_list_id() {
  _impl_.list_id_.ClearToEmpty();
}
inline const std::string& GetListRequest::list_id() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.GetListRequest.list_id)
  return _internal_list_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetListRequest::set_list_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.list_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.GetListRequest.list_id)
}
inline std::string* GetListRequest::mutable_list_id() {
  std::string* _s = _internal_mutable_list_id();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.GetListRequest.list_id)
  return _s;
}
inline const std::string& GetListRequest::_internal_list_id() const {
  return _impl_.list_id_.Get();
}
inline void GetListRequest::_internal_set_list_id(const std::string& value) {
  
  _impl_.list_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetListRequest::_internal_mutable_list_id() {
  
  return _impl_.list_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetListRequest::release_list_id() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.GetListRequest.list_id)
  return _impl_.list_id_.Release();
}
inline void GetListRequest::set_allocated_list_id(std::string* list_id) {
  if (list_id != nullptr) {
    
  } else {
    
  }
  _impl_.list_id_.SetAllocated(list_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.list_id_.IsDefault()) {
    _impl_.list_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.GetListRequest.list_id)
}

// string requester_id = 2;
inline void GetListRequest::clear_requester_id() {
  _impl_.requester_id_.ClearToEmpty();
}
inline const std::string& GetListRequest::requester_id() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.GetListRequest.requester_id)
  return _internal_requester_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetListRequest::set_requester_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.requester_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.GetListRequest.requester_id)
}
inline std::string* GetListRequest::mutable_requester_id() {
  std::string* _s = _internal_mutable_requester_id();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.GetListRequest.requester_id)
  return _s;
}
inline const std::string& GetListRequest::_internal_requester_id() const {
  return _impl_.requester_id_.Get();
}
inline void GetListRequest::_internal_set_requester_id(const std::string& value) {
  
  _impl_.requester_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetListRequest::_internal_mutable_requester_id() {
  
  return _impl_.requester_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetListRequest::release_requester_id() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.GetListRequest.requester_id)
  return _impl_.requester_id_.Release();
}
inline void GetListRequest::set_allocated_requester_id(std::string* requester_id) {
  if (requester_id != nullptr) {
    
  } else {
    
  }
  _impl_.requester_id_.SetAllocated(requester_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.requester_id_.IsDefault()) {
    _impl_.requester_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.GetListRequest.requester_id)
}

// -------------------------------------------------------------------

// GetListResponse

// bool success = 1;
inline void GetListResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool GetListResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool GetListResponse::success() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.GetListResponse.success)
  return _internal_success();
}
inline void GetListResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void GetListResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:sonet.list.v1.GetListResponse.success)
}

// .sonet.list.v1.List list = 2;
inline bool GetListResponse::_internal_has_list() const {
  return this != internal_default_instance() && _impl_.list_ != nullptr;
}
inline bool GetListResponse::has_list() const {
  return _internal_has_list();
}
inline void GetListResponse::clear_list() {
  if (GetArenaForAllocation() == nullptr && _impl_.list_ != nullptr) {
    delete _impl_.list_;
  }
  _impl_.list_ = nullptr;
}
inline const ::sonet::list::v1::List& GetListResponse::_internal_list() const {
  const ::sonet::list::v1::List* p = _impl_.list_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::list::v1::List&>(
      ::sonet::list::v1::_List_default_instance_);
}
inline const ::sonet::list::v1::List& GetListResponse::list() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.GetListResponse.list)
  return _internal_list();
}
inline void GetListResponse::unsafe_arena_set_allocated_list(
    ::sonet::list::v1::List* list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.list_);
  }
  _impl_.list_ = list;
  if (list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.list.v1.GetListResponse.list)
}
inline ::sonet::list::v1::List* GetListResponse::release_list() {
  
  ::sonet::list::v1::List* temp = _impl_.list_;
  _impl_.list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::list::v1::List* GetListResponse::unsafe_arena_release_list() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.GetListResponse.list)
  
  ::sonet::list::v1::List* temp = _impl_.list_;
  _impl_.list_ = nullptr;
  return temp;
}
inline ::sonet::list::v1::List* GetListResponse::_internal_mutable_list() {
  
  if (_impl_.list_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::list::v1::List>(GetArenaForAllocation());
    _impl_.list_ = p;
  }
  return _impl_.list_;
}
inline ::sonet::list::v1::List* GetListResponse::mutable_list() {
  ::sonet::list::v1::List* _msg = _internal_mutable_list();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.GetListResponse.list)
  return _msg;
}
inline void GetListResponse::set_allocated_list(::sonet::list::v1::List* list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.list_;
  }
  if (list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(list);
    if (message_arena != submessage_arena) {
      list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, list, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.list_ = list;
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.GetListResponse.list)
}

// string error_message = 3;
inline void GetListResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& GetListResponse::error_message() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.GetListResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetListResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.GetListResponse.error_message)
}
inline std::string* GetListResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.GetListResponse.error_message)
  return _s;
}
inline const std::string& GetListResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void GetListResponse::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* GetListResponse::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* GetListResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.GetListResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void GetListResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.GetListResponse.error_message)
}

// -------------------------------------------------------------------

// GetUserListsRequest

// string user_id = 1;
inline void GetUserListsRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& GetUserListsRequest::user_id() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.GetUserListsRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetUserListsRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.GetUserListsRequest.user_id)
}
inline std::string* GetUserListsRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.GetUserListsRequest.user_id)
  return _s;
}
inline const std::string& GetUserListsRequest::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void GetUserListsRequest::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetUserListsRequest::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetUserListsRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.GetUserListsRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void GetUserListsRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.GetUserListsRequest.user_id)
}

// string requester_id = 2;
inline void GetUserListsRequest::clear_requester_id() {
  _impl_.requester_id_.ClearToEmpty();
}
inline const std::string& GetUserListsRequest::requester_id() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.GetUserListsRequest.requester_id)
  return _internal_requester_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetUserListsRequest::set_requester_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.requester_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.GetUserListsRequest.requester_id)
}
inline std::string* GetUserListsRequest::mutable_requester_id() {
  std::string* _s = _internal_mutable_requester_id();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.GetUserListsRequest.requester_id)
  return _s;
}
inline const std::string& GetUserListsRequest::_internal_requester_id() const {
  return _impl_.requester_id_.Get();
}
inline void GetUserListsRequest::_internal_set_requester_id(const std::string& value) {
  
  _impl_.requester_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetUserListsRequest::_internal_mutable_requester_id() {
  
  return _impl_.requester_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetUserListsRequest::release_requester_id() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.GetUserListsRequest.requester_id)
  return _impl_.requester_id_.Release();
}
inline void GetUserListsRequest::set_allocated_requester_id(std::string* requester_id) {
  if (requester_id != nullptr) {
    
  } else {
    
  }
  _impl_.requester_id_.SetAllocated(requester_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.requester_id_.IsDefault()) {
    _impl_.requester_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.GetUserListsRequest.requester_id)
}

// int32 limit = 3;
inline void GetUserListsRequest::clear_limit() {
  _impl_.limit_ = 0;
}
inline int32_t GetUserListsRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline int32_t GetUserListsRequest::limit() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.GetUserListsRequest.limit)
  return _internal_limit();
}
inline void GetUserListsRequest::_internal_set_limit(int32_t value) {
  
  _impl_.limit_ = value;
}
inline void GetUserListsRequest::set_limit(int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:sonet.list.v1.GetUserListsRequest.limit)
}

// string cursor = 4;
inline void GetUserListsRequest::clear_cursor() {
  _impl_.cursor_.ClearToEmpty();
}
inline const std::string& GetUserListsRequest::cursor() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.GetUserListsRequest.cursor)
  return _internal_cursor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetUserListsRequest::set_cursor(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cursor_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.GetUserListsRequest.cursor)
}
inline std::string* GetUserListsRequest::mutable_cursor() {
  std::string* _s = _internal_mutable_cursor();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.GetUserListsRequest.cursor)
  return _s;
}
inline const std::string& GetUserListsRequest::_internal_cursor() const {
  return _impl_.cursor_.Get();
}
inline void GetUserListsRequest::_internal_set_cursor(const std::string& value) {
  
  _impl_.cursor_.Set(value, GetArenaForAllocation());
}
inline std::string* GetUserListsRequest::_internal_mutable_cursor() {
  
  return _impl_.cursor_.Mutable(GetArenaForAllocation());
}
inline std::string* GetUserListsRequest::release_cursor() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.GetUserListsRequest.cursor)
  return _impl_.cursor_.Release();
}
inline void GetUserListsRequest::set_allocated_cursor(std::string* cursor) {
  if (cursor != nullptr) {
    
  } else {
    
  }
  _impl_.cursor_.SetAllocated(cursor, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cursor_.IsDefault()) {
    _impl_.cursor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.GetUserListsRequest.cursor)
}

// -------------------------------------------------------------------

// GetUserListsResponse

// bool success = 1;
inline void GetUserListsResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool GetUserListsResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool GetUserListsResponse::success() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.GetUserListsResponse.success)
  return _internal_success();
}
inline void GetUserListsResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void GetUserListsResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:sonet.list.v1.GetUserListsResponse.success)
}

// repeated .sonet.list.v1.List lists = 2;
inline int GetUserListsResponse::_internal_lists_size() const {
  return _impl_.lists_.size();
}
inline int GetUserListsResponse::lists_size() const {
  return _internal_lists_size();
}
inline void GetUserListsResponse::clear_lists() {
  _impl_.lists_.Clear();
}
inline ::sonet::list::v1::List* GetUserListsResponse::mutable_lists(int index) {
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.GetUserListsResponse.lists)
  return _impl_.lists_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::list::v1::List >*
GetUserListsResponse::mutable_lists() {
  // @@protoc_insertion_point(field_mutable_list:sonet.list.v1.GetUserListsResponse.lists)
  return &_impl_.lists_;
}
inline const ::sonet::list::v1::List& GetUserListsResponse::_internal_lists(int index) const {
  return _impl_.lists_.Get(index);
}
inline const ::sonet::list::v1::List& GetUserListsResponse::lists(int index) const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.GetUserListsResponse.lists)
  return _internal_lists(index);
}
inline ::sonet::list::v1::List* GetUserListsResponse::_internal_add_lists() {
  return _impl_.lists_.Add();
}
inline ::sonet::list::v1::List* GetUserListsResponse::add_lists() {
  ::sonet::list::v1::List* _add = _internal_add_lists();
  // @@protoc_insertion_point(field_add:sonet.list.v1.GetUserListsResponse.lists)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::list::v1::List >&
GetUserListsResponse::lists() const {
  // @@protoc_insertion_point(field_list:sonet.list.v1.GetUserListsResponse.lists)
  return _impl_.lists_;
}

// string next_cursor = 3;
inline void GetUserListsResponse::clear_next_cursor() {
  _impl_.next_cursor_.ClearToEmpty();
}
inline const std::string& GetUserListsResponse::next_cursor() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.GetUserListsResponse.next_cursor)
  return _internal_next_cursor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetUserListsResponse::set_next_cursor(ArgT0&& arg0, ArgT... args) {
 
 _impl_.next_cursor_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.GetUserListsResponse.next_cursor)
}
inline std::string* GetUserListsResponse::mutable_next_cursor() {
  std::string* _s = _internal_mutable_next_cursor();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.GetUserListsResponse.next_cursor)
  return _s;
}
inline const std::string& GetUserListsResponse::_internal_next_cursor() const {
  return _impl_.next_cursor_.Get();
}
inline void GetUserListsResponse::_internal_set_next_cursor(const std::string& value) {
  
  _impl_.next_cursor_.Set(value, GetArenaForAllocation());
}
inline std::string* GetUserListsResponse::_internal_mutable_next_cursor() {
  
  return _impl_.next_cursor_.Mutable(GetArenaForAllocation());
}
inline std::string* GetUserListsResponse::release_next_cursor() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.GetUserListsResponse.next_cursor)
  return _impl_.next_cursor_.Release();
}
inline void GetUserListsResponse::set_allocated_next_cursor(std::string* next_cursor) {
  if (next_cursor != nullptr) {
    
  } else {
    
  }
  _impl_.next_cursor_.SetAllocated(next_cursor, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_cursor_.IsDefault()) {
    _impl_.next_cursor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.GetUserListsResponse.next_cursor)
}

// string error_message = 4;
inline void GetUserListsResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& GetUserListsResponse::error_message() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.GetUserListsResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetUserListsResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.GetUserListsResponse.error_message)
}
inline std::string* GetUserListsResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.GetUserListsResponse.error_message)
  return _s;
}
inline const std::string& GetUserListsResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void GetUserListsResponse::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* GetUserListsResponse::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* GetUserListsResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.GetUserListsResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void GetUserListsResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.GetUserListsResponse.error_message)
}

// -------------------------------------------------------------------

// UpdateListRequest

// string list_id = 1;
inline void UpdateListRequest::clear_list_id() {
  _impl_.list_id_.ClearToEmpty();
}
inline const std::string& UpdateListRequest::list_id() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.UpdateListRequest.list_id)
  return _internal_list_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateListRequest::set_list_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.list_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.UpdateListRequest.list_id)
}
inline std::string* UpdateListRequest::mutable_list_id() {
  std::string* _s = _internal_mutable_list_id();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.UpdateListRequest.list_id)
  return _s;
}
inline const std::string& UpdateListRequest::_internal_list_id() const {
  return _impl_.list_id_.Get();
}
inline void UpdateListRequest::_internal_set_list_id(const std::string& value) {
  
  _impl_.list_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateListRequest::_internal_mutable_list_id() {
  
  return _impl_.list_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateListRequest::release_list_id() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.UpdateListRequest.list_id)
  return _impl_.list_id_.Release();
}
inline void UpdateListRequest::set_allocated_list_id(std::string* list_id) {
  if (list_id != nullptr) {
    
  } else {
    
  }
  _impl_.list_id_.SetAllocated(list_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.list_id_.IsDefault()) {
    _impl_.list_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.UpdateListRequest.list_id)
}

// string requester_id = 2;
inline void UpdateListRequest::clear_requester_id() {
  _impl_.requester_id_.ClearToEmpty();
}
inline const std::string& UpdateListRequest::requester_id() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.UpdateListRequest.requester_id)
  return _internal_requester_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateListRequest::set_requester_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.requester_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.UpdateListRequest.requester_id)
}
inline std::string* UpdateListRequest::mutable_requester_id() {
  std::string* _s = _internal_mutable_requester_id();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.UpdateListRequest.requester_id)
  return _s;
}
inline const std::string& UpdateListRequest::_internal_requester_id() const {
  return _impl_.requester_id_.Get();
}
inline void UpdateListRequest::_internal_set_requester_id(const std::string& value) {
  
  _impl_.requester_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateListRequest::_internal_mutable_requester_id() {
  
  return _impl_.requester_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateListRequest::release_requester_id() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.UpdateListRequest.requester_id)
  return _impl_.requester_id_.Release();
}
inline void UpdateListRequest::set_allocated_requester_id(std::string* requester_id) {
  if (requester_id != nullptr) {
    
  } else {
    
  }
  _impl_.requester_id_.SetAllocated(requester_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.requester_id_.IsDefault()) {
    _impl_.requester_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.UpdateListRequest.requester_id)
}

// string name = 3;
inline void UpdateListRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& UpdateListRequest::name() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.UpdateListRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateListRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.UpdateListRequest.name)
}
inline std::string* UpdateListRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.UpdateListRequest.name)
  return _s;
}
inline const std::string& UpdateListRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void UpdateListRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateListRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateListRequest::release_name() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.UpdateListRequest.name)
  return _impl_.name_.Release();
}
inline void UpdateListRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.UpdateListRequest.name)
}

// string description = 4;
inline void UpdateListRequest::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& UpdateListRequest::description() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.UpdateListRequest.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateListRequest::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.UpdateListRequest.description)
}
inline std::string* UpdateListRequest::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.UpdateListRequest.description)
  return _s;
}
inline const std::string& UpdateListRequest::_internal_description() const {
  return _impl_.description_.Get();
}
inline void UpdateListRequest::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateListRequest::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateListRequest::release_description() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.UpdateListRequest.description)
  return _impl_.description_.Release();
}
inline void UpdateListRequest::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.UpdateListRequest.description)
}

// bool is_public = 5;
inline void UpdateListRequest::clear_is_public() {
  _impl_.is_public_ = false;
}
inline bool UpdateListRequest::_internal_is_public() const {
  return _impl_.is_public_;
}
inline bool UpdateListRequest::is_public() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.UpdateListRequest.is_public)
  return _internal_is_public();
}
inline void UpdateListRequest::_internal_set_is_public(bool value) {
  
  _impl_.is_public_ = value;
}
inline void UpdateListRequest::set_is_public(bool value) {
  _internal_set_is_public(value);
  // @@protoc_insertion_point(field_set:sonet.list.v1.UpdateListRequest.is_public)
}

// .sonet.list.v1.ListType list_type = 6;
inline void UpdateListRequest::clear_list_type() {
  _impl_.list_type_ = 0;
}
inline ::sonet::list::v1::ListType UpdateListRequest::_internal_list_type() const {
  return static_cast< ::sonet::list::v1::ListType >(_impl_.list_type_);
}
inline ::sonet::list::v1::ListType UpdateListRequest::list_type() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.UpdateListRequest.list_type)
  return _internal_list_type();
}
inline void UpdateListRequest::_internal_set_list_type(::sonet::list::v1::ListType value) {
  
  _impl_.list_type_ = value;
}
inline void UpdateListRequest::set_list_type(::sonet::list::v1::ListType value) {
  _internal_set_list_type(value);
  // @@protoc_insertion_point(field_set:sonet.list.v1.UpdateListRequest.list_type)
}

// -------------------------------------------------------------------

// UpdateListResponse

// bool success = 1;
inline void UpdateListResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool UpdateListResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool UpdateListResponse::success() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.UpdateListResponse.success)
  return _internal_success();
}
inline void UpdateListResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void UpdateListResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:sonet.list.v1.UpdateListResponse.success)
}

// .sonet.list.v1.List list = 2;
inline bool UpdateListResponse::_internal_has_list() const {
  return this != internal_default_instance() && _impl_.list_ != nullptr;
}
inline bool UpdateListResponse::has_list() const {
  return _internal_has_list();
}
inline void UpdateListResponse::clear_list() {
  if (GetArenaForAllocation() == nullptr && _impl_.list_ != nullptr) {
    delete _impl_.list_;
  }
  _impl_.list_ = nullptr;
}
inline const ::sonet::list::v1::List& UpdateListResponse::_internal_list() const {
  const ::sonet::list::v1::List* p = _impl_.list_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::list::v1::List&>(
      ::sonet::list::v1::_List_default_instance_);
}
inline const ::sonet::list::v1::List& UpdateListResponse::list() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.UpdateListResponse.list)
  return _internal_list();
}
inline void UpdateListResponse::unsafe_arena_set_allocated_list(
    ::sonet::list::v1::List* list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.list_);
  }
  _impl_.list_ = list;
  if (list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.list.v1.UpdateListResponse.list)
}
inline ::sonet::list::v1::List* UpdateListResponse::release_list() {
  
  ::sonet::list::v1::List* temp = _impl_.list_;
  _impl_.list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::list::v1::List* UpdateListResponse::unsafe_arena_release_list() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.UpdateListResponse.list)
  
  ::sonet::list::v1::List* temp = _impl_.list_;
  _impl_.list_ = nullptr;
  return temp;
}
inline ::sonet::list::v1::List* UpdateListResponse::_internal_mutable_list() {
  
  if (_impl_.list_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::list::v1::List>(GetArenaForAllocation());
    _impl_.list_ = p;
  }
  return _impl_.list_;
}
inline ::sonet::list::v1::List* UpdateListResponse::mutable_list() {
  ::sonet::list::v1::List* _msg = _internal_mutable_list();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.UpdateListResponse.list)
  return _msg;
}
inline void UpdateListResponse::set_allocated_list(::sonet::list::v1::List* list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.list_;
  }
  if (list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(list);
    if (message_arena != submessage_arena) {
      list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, list, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.list_ = list;
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.UpdateListResponse.list)
}

// string error_message = 3;
inline void UpdateListResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& UpdateListResponse::error_message() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.UpdateListResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateListResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.UpdateListResponse.error_message)
}
inline std::string* UpdateListResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.UpdateListResponse.error_message)
  return _s;
}
inline const std::string& UpdateListResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void UpdateListResponse::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateListResponse::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateListResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.UpdateListResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void UpdateListResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.UpdateListResponse.error_message)
}

// -------------------------------------------------------------------

// DeleteListRequest

// string list_id = 1;
inline void DeleteListRequest::clear_list_id() {
  _impl_.list_id_.ClearToEmpty();
}
inline const std::string& DeleteListRequest::list_id() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.DeleteListRequest.list_id)
  return _internal_list_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteListRequest::set_list_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.list_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.DeleteListRequest.list_id)
}
inline std::string* DeleteListRequest::mutable_list_id() {
  std::string* _s = _internal_mutable_list_id();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.DeleteListRequest.list_id)
  return _s;
}
inline const std::string& DeleteListRequest::_internal_list_id() const {
  return _impl_.list_id_.Get();
}
inline void DeleteListRequest::_internal_set_list_id(const std::string& value) {
  
  _impl_.list_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteListRequest::_internal_mutable_list_id() {
  
  return _impl_.list_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteListRequest::release_list_id() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.DeleteListRequest.list_id)
  return _impl_.list_id_.Release();
}
inline void DeleteListRequest::set_allocated_list_id(std::string* list_id) {
  if (list_id != nullptr) {
    
  } else {
    
  }
  _impl_.list_id_.SetAllocated(list_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.list_id_.IsDefault()) {
    _impl_.list_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.DeleteListRequest.list_id)
}

// string requester_id = 2;
inline void DeleteListRequest::clear_requester_id() {
  _impl_.requester_id_.ClearToEmpty();
}
inline const std::string& DeleteListRequest::requester_id() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.DeleteListRequest.requester_id)
  return _internal_requester_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteListRequest::set_requester_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.requester_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.DeleteListRequest.requester_id)
}
inline std::string* DeleteListRequest::mutable_requester_id() {
  std::string* _s = _internal_mutable_requester_id();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.DeleteListRequest.requester_id)
  return _s;
}
inline const std::string& DeleteListRequest::_internal_requester_id() const {
  return _impl_.requester_id_.Get();
}
inline void DeleteListRequest::_internal_set_requester_id(const std::string& value) {
  
  _impl_.requester_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteListRequest::_internal_mutable_requester_id() {
  
  return _impl_.requester_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteListRequest::release_requester_id() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.DeleteListRequest.requester_id)
  return _impl_.requester_id_.Release();
}
inline void DeleteListRequest::set_allocated_requester_id(std::string* requester_id) {
  if (requester_id != nullptr) {
    
  } else {
    
  }
  _impl_.requester_id_.SetAllocated(requester_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.requester_id_.IsDefault()) {
    _impl_.requester_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.DeleteListRequest.requester_id)
}

// -------------------------------------------------------------------

// DeleteListResponse

// bool success = 1;
inline void DeleteListResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool DeleteListResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool DeleteListResponse::success() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.DeleteListResponse.success)
  return _internal_success();
}
inline void DeleteListResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void DeleteListResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:sonet.list.v1.DeleteListResponse.success)
}

// string error_message = 2;
inline void DeleteListResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& DeleteListResponse::error_message() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.DeleteListResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteListResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.DeleteListResponse.error_message)
}
inline std::string* DeleteListResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.DeleteListResponse.error_message)
  return _s;
}
inline const std::string& DeleteListResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void DeleteListResponse::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteListResponse::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteListResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.DeleteListResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void DeleteListResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.DeleteListResponse.error_message)
}

// -------------------------------------------------------------------

// AddListMemberRequest

// string list_id = 1;
inline void AddListMemberRequest::clear_list_id() {
  _impl_.list_id_.ClearToEmpty();
}
inline const std::string& AddListMemberRequest::list_id() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.AddListMemberRequest.list_id)
  return _internal_list_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddListMemberRequest::set_list_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.list_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.AddListMemberRequest.list_id)
}
inline std::string* AddListMemberRequest::mutable_list_id() {
  std::string* _s = _internal_mutable_list_id();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.AddListMemberRequest.list_id)
  return _s;
}
inline const std::string& AddListMemberRequest::_internal_list_id() const {
  return _impl_.list_id_.Get();
}
inline void AddListMemberRequest::_internal_set_list_id(const std::string& value) {
  
  _impl_.list_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AddListMemberRequest::_internal_mutable_list_id() {
  
  return _impl_.list_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AddListMemberRequest::release_list_id() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.AddListMemberRequest.list_id)
  return _impl_.list_id_.Release();
}
inline void AddListMemberRequest::set_allocated_list_id(std::string* list_id) {
  if (list_id != nullptr) {
    
  } else {
    
  }
  _impl_.list_id_.SetAllocated(list_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.list_id_.IsDefault()) {
    _impl_.list_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.AddListMemberRequest.list_id)
}

// string user_id = 2;
inline void AddListMemberRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& AddListMemberRequest::user_id() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.AddListMemberRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddListMemberRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.AddListMemberRequest.user_id)
}
inline std::string* AddListMemberRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.AddListMemberRequest.user_id)
  return _s;
}
inline const std::string& AddListMemberRequest::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void AddListMemberRequest::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AddListMemberRequest::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AddListMemberRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.AddListMemberRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void AddListMemberRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.AddListMemberRequest.user_id)
}

// string added_by = 3;
inline void AddListMemberRequest::clear_added_by() {
  _impl_.added_by_.ClearToEmpty();
}
inline const std::string& AddListMemberRequest::added_by() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.AddListMemberRequest.added_by)
  return _internal_added_by();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddListMemberRequest::set_added_by(ArgT0&& arg0, ArgT... args) {
 
 _impl_.added_by_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.AddListMemberRequest.added_by)
}
inline std::string* AddListMemberRequest::mutable_added_by() {
  std::string* _s = _internal_mutable_added_by();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.AddListMemberRequest.added_by)
  return _s;
}
inline const std::string& AddListMemberRequest::_internal_added_by() const {
  return _impl_.added_by_.Get();
}
inline void AddListMemberRequest::_internal_set_added_by(const std::string& value) {
  
  _impl_.added_by_.Set(value, GetArenaForAllocation());
}
inline std::string* AddListMemberRequest::_internal_mutable_added_by() {
  
  return _impl_.added_by_.Mutable(GetArenaForAllocation());
}
inline std::string* AddListMemberRequest::release_added_by() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.AddListMemberRequest.added_by)
  return _impl_.added_by_.Release();
}
inline void AddListMemberRequest::set_allocated_added_by(std::string* added_by) {
  if (added_by != nullptr) {
    
  } else {
    
  }
  _impl_.added_by_.SetAllocated(added_by, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.added_by_.IsDefault()) {
    _impl_.added_by_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.AddListMemberRequest.added_by)
}

// string notes = 4;
inline void AddListMemberRequest::clear_notes() {
  _impl_.notes_.ClearToEmpty();
}
inline const std::string& AddListMemberRequest::notes() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.AddListMemberRequest.notes)
  return _internal_notes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddListMemberRequest::set_notes(ArgT0&& arg0, ArgT... args) {
 
 _impl_.notes_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.AddListMemberRequest.notes)
}
inline std::string* AddListMemberRequest::mutable_notes() {
  std::string* _s = _internal_mutable_notes();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.AddListMemberRequest.notes)
  return _s;
}
inline const std::string& AddListMemberRequest::_internal_notes() const {
  return _impl_.notes_.Get();
}
inline void AddListMemberRequest::_internal_set_notes(const std::string& value) {
  
  _impl_.notes_.Set(value, GetArenaForAllocation());
}
inline std::string* AddListMemberRequest::_internal_mutable_notes() {
  
  return _impl_.notes_.Mutable(GetArenaForAllocation());
}
inline std::string* AddListMemberRequest::release_notes() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.AddListMemberRequest.notes)
  return _impl_.notes_.Release();
}
inline void AddListMemberRequest::set_allocated_notes(std::string* notes) {
  if (notes != nullptr) {
    
  } else {
    
  }
  _impl_.notes_.SetAllocated(notes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.notes_.IsDefault()) {
    _impl_.notes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.AddListMemberRequest.notes)
}

// -------------------------------------------------------------------

// AddListMemberResponse

// bool success = 1;
inline void AddListMemberResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool AddListMemberResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool AddListMemberResponse::success() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.AddListMemberResponse.success)
  return _internal_success();
}
inline void AddListMemberResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void AddListMemberResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:sonet.list.v1.AddListMemberResponse.success)
}

// .sonet.list.v1.ListMember member = 2;
inline bool AddListMemberResponse::_internal_has_member() const {
  return this != internal_default_instance() && _impl_.member_ != nullptr;
}
inline bool AddListMemberResponse::has_member() const {
  return _internal_has_member();
}
inline void AddListMemberResponse::clear_member() {
  if (GetArenaForAllocation() == nullptr && _impl_.member_ != nullptr) {
    delete _impl_.member_;
  }
  _impl_.member_ = nullptr;
}
inline const ::sonet::list::v1::ListMember& AddListMemberResponse::_internal_member() const {
  const ::sonet::list::v1::ListMember* p = _impl_.member_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::list::v1::ListMember&>(
      ::sonet::list::v1::_ListMember_default_instance_);
}
inline const ::sonet::list::v1::ListMember& AddListMemberResponse::member() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.AddListMemberResponse.member)
  return _internal_member();
}
inline void AddListMemberResponse::unsafe_arena_set_allocated_member(
    ::sonet::list::v1::ListMember* member) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.member_);
  }
  _impl_.member_ = member;
  if (member) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.list.v1.AddListMemberResponse.member)
}
inline ::sonet::list::v1::ListMember* AddListMemberResponse::release_member() {
  
  ::sonet::list::v1::ListMember* temp = _impl_.member_;
  _impl_.member_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::list::v1::ListMember* AddListMemberResponse::unsafe_arena_release_member() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.AddListMemberResponse.member)
  
  ::sonet::list::v1::ListMember* temp = _impl_.member_;
  _impl_.member_ = nullptr;
  return temp;
}
inline ::sonet::list::v1::ListMember* AddListMemberResponse::_internal_mutable_member() {
  
  if (_impl_.member_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::list::v1::ListMember>(GetArenaForAllocation());
    _impl_.member_ = p;
  }
  return _impl_.member_;
}
inline ::sonet::list::v1::ListMember* AddListMemberResponse::mutable_member() {
  ::sonet::list::v1::ListMember* _msg = _internal_mutable_member();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.AddListMemberResponse.member)
  return _msg;
}
inline void AddListMemberResponse::set_allocated_member(::sonet::list::v1::ListMember* member) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.member_;
  }
  if (member) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(member);
    if (message_arena != submessage_arena) {
      member = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, member, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.member_ = member;
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.AddListMemberResponse.member)
}

// string error_message = 3;
inline void AddListMemberResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& AddListMemberResponse::error_message() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.AddListMemberResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddListMemberResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.AddListMemberResponse.error_message)
}
inline std::string* AddListMemberResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.AddListMemberResponse.error_message)
  return _s;
}
inline const std::string& AddListMemberResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void AddListMemberResponse::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* AddListMemberResponse::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* AddListMemberResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.AddListMemberResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void AddListMemberResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.AddListMemberResponse.error_message)
}

// -------------------------------------------------------------------

// RemoveListMemberRequest

// string list_id = 1;
inline void RemoveListMemberRequest::clear_list_id() {
  _impl_.list_id_.ClearToEmpty();
}
inline const std::string& RemoveListMemberRequest::list_id() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.RemoveListMemberRequest.list_id)
  return _internal_list_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoveListMemberRequest::set_list_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.list_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.RemoveListMemberRequest.list_id)
}
inline std::string* RemoveListMemberRequest::mutable_list_id() {
  std::string* _s = _internal_mutable_list_id();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.RemoveListMemberRequest.list_id)
  return _s;
}
inline const std::string& RemoveListMemberRequest::_internal_list_id() const {
  return _impl_.list_id_.Get();
}
inline void RemoveListMemberRequest::_internal_set_list_id(const std::string& value) {
  
  _impl_.list_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RemoveListMemberRequest::_internal_mutable_list_id() {
  
  return _impl_.list_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RemoveListMemberRequest::release_list_id() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.RemoveListMemberRequest.list_id)
  return _impl_.list_id_.Release();
}
inline void RemoveListMemberRequest::set_allocated_list_id(std::string* list_id) {
  if (list_id != nullptr) {
    
  } else {
    
  }
  _impl_.list_id_.SetAllocated(list_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.list_id_.IsDefault()) {
    _impl_.list_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.RemoveListMemberRequest.list_id)
}

// string user_id = 2;
inline void RemoveListMemberRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& RemoveListMemberRequest::user_id() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.RemoveListMemberRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoveListMemberRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.RemoveListMemberRequest.user_id)
}
inline std::string* RemoveListMemberRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.RemoveListMemberRequest.user_id)
  return _s;
}
inline const std::string& RemoveListMemberRequest::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void RemoveListMemberRequest::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RemoveListMemberRequest::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RemoveListMemberRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.RemoveListMemberRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void RemoveListMemberRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.RemoveListMemberRequest.user_id)
}

// string removed_by = 3;
inline void RemoveListMemberRequest::clear_removed_by() {
  _impl_.removed_by_.ClearToEmpty();
}
inline const std::string& RemoveListMemberRequest::removed_by() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.RemoveListMemberRequest.removed_by)
  return _internal_removed_by();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoveListMemberRequest::set_removed_by(ArgT0&& arg0, ArgT... args) {
 
 _impl_.removed_by_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.RemoveListMemberRequest.removed_by)
}
inline std::string* RemoveListMemberRequest::mutable_removed_by() {
  std::string* _s = _internal_mutable_removed_by();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.RemoveListMemberRequest.removed_by)
  return _s;
}
inline const std::string& RemoveListMemberRequest::_internal_removed_by() const {
  return _impl_.removed_by_.Get();
}
inline void RemoveListMemberRequest::_internal_set_removed_by(const std::string& value) {
  
  _impl_.removed_by_.Set(value, GetArenaForAllocation());
}
inline std::string* RemoveListMemberRequest::_internal_mutable_removed_by() {
  
  return _impl_.removed_by_.Mutable(GetArenaForAllocation());
}
inline std::string* RemoveListMemberRequest::release_removed_by() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.RemoveListMemberRequest.removed_by)
  return _impl_.removed_by_.Release();
}
inline void RemoveListMemberRequest::set_allocated_removed_by(std::string* removed_by) {
  if (removed_by != nullptr) {
    
  } else {
    
  }
  _impl_.removed_by_.SetAllocated(removed_by, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.removed_by_.IsDefault()) {
    _impl_.removed_by_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.RemoveListMemberRequest.removed_by)
}

// -------------------------------------------------------------------

// RemoveListMemberResponse

// bool success = 1;
inline void RemoveListMemberResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool RemoveListMemberResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool RemoveListMemberResponse::success() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.RemoveListMemberResponse.success)
  return _internal_success();
}
inline void RemoveListMemberResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void RemoveListMemberResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:sonet.list.v1.RemoveListMemberResponse.success)
}

// string error_message = 2;
inline void RemoveListMemberResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& RemoveListMemberResponse::error_message() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.RemoveListMemberResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoveListMemberResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.RemoveListMemberResponse.error_message)
}
inline std::string* RemoveListMemberResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.RemoveListMemberResponse.error_message)
  return _s;
}
inline const std::string& RemoveListMemberResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void RemoveListMemberResponse::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* RemoveListMemberResponse::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* RemoveListMemberResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.RemoveListMemberResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void RemoveListMemberResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.RemoveListMemberResponse.error_message)
}

// -------------------------------------------------------------------

// GetListMembersRequest

// string list_id = 1;
inline void GetListMembersRequest::clear_list_id() {
  _impl_.list_id_.ClearToEmpty();
}
inline const std::string& GetListMembersRequest::list_id() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.GetListMembersRequest.list_id)
  return _internal_list_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetListMembersRequest::set_list_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.list_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.GetListMembersRequest.list_id)
}
inline std::string* GetListMembersRequest::mutable_list_id() {
  std::string* _s = _internal_mutable_list_id();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.GetListMembersRequest.list_id)
  return _s;
}
inline const std::string& GetListMembersRequest::_internal_list_id() const {
  return _impl_.list_id_.Get();
}
inline void GetListMembersRequest::_internal_set_list_id(const std::string& value) {
  
  _impl_.list_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetListMembersRequest::_internal_mutable_list_id() {
  
  return _impl_.list_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetListMembersRequest::release_list_id() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.GetListMembersRequest.list_id)
  return _impl_.list_id_.Release();
}
inline void GetListMembersRequest::set_allocated_list_id(std::string* list_id) {
  if (list_id != nullptr) {
    
  } else {
    
  }
  _impl_.list_id_.SetAllocated(list_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.list_id_.IsDefault()) {
    _impl_.list_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.GetListMembersRequest.list_id)
}

// string requester_id = 2;
inline void GetListMembersRequest::clear_requester_id() {
  _impl_.requester_id_.ClearToEmpty();
}
inline const std::string& GetListMembersRequest::requester_id() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.GetListMembersRequest.requester_id)
  return _internal_requester_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetListMembersRequest::set_requester_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.requester_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.GetListMembersRequest.requester_id)
}
inline std::string* GetListMembersRequest::mutable_requester_id() {
  std::string* _s = _internal_mutable_requester_id();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.GetListMembersRequest.requester_id)
  return _s;
}
inline const std::string& GetListMembersRequest::_internal_requester_id() const {
  return _impl_.requester_id_.Get();
}
inline void GetListMembersRequest::_internal_set_requester_id(const std::string& value) {
  
  _impl_.requester_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetListMembersRequest::_internal_mutable_requester_id() {
  
  return _impl_.requester_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetListMembersRequest::release_requester_id() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.GetListMembersRequest.requester_id)
  return _impl_.requester_id_.Release();
}
inline void GetListMembersRequest::set_allocated_requester_id(std::string* requester_id) {
  if (requester_id != nullptr) {
    
  } else {
    
  }
  _impl_.requester_id_.SetAllocated(requester_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.requester_id_.IsDefault()) {
    _impl_.requester_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.GetListMembersRequest.requester_id)
}

// int32 limit = 3;
inline void GetListMembersRequest::clear_limit() {
  _impl_.limit_ = 0;
}
inline int32_t GetListMembersRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline int32_t GetListMembersRequest::limit() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.GetListMembersRequest.limit)
  return _internal_limit();
}
inline void GetListMembersRequest::_internal_set_limit(int32_t value) {
  
  _impl_.limit_ = value;
}
inline void GetListMembersRequest::set_limit(int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:sonet.list.v1.GetListMembersRequest.limit)
}

// string cursor = 4;
inline void GetListMembersRequest::clear_cursor() {
  _impl_.cursor_.ClearToEmpty();
}
inline const std::string& GetListMembersRequest::cursor() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.GetListMembersRequest.cursor)
  return _internal_cursor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetListMembersRequest::set_cursor(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cursor_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.GetListMembersRequest.cursor)
}
inline std::string* GetListMembersRequest::mutable_cursor() {
  std::string* _s = _internal_mutable_cursor();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.GetListMembersRequest.cursor)
  return _s;
}
inline const std::string& GetListMembersRequest::_internal_cursor() const {
  return _impl_.cursor_.Get();
}
inline void GetListMembersRequest::_internal_set_cursor(const std::string& value) {
  
  _impl_.cursor_.Set(value, GetArenaForAllocation());
}
inline std::string* GetListMembersRequest::_internal_mutable_cursor() {
  
  return _impl_.cursor_.Mutable(GetArenaForAllocation());
}
inline std::string* GetListMembersRequest::release_cursor() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.GetListMembersRequest.cursor)
  return _impl_.cursor_.Release();
}
inline void GetListMembersRequest::set_allocated_cursor(std::string* cursor) {
  if (cursor != nullptr) {
    
  } else {
    
  }
  _impl_.cursor_.SetAllocated(cursor, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cursor_.IsDefault()) {
    _impl_.cursor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.GetListMembersRequest.cursor)
}

// -------------------------------------------------------------------

// GetListMembersResponse

// bool success = 1;
inline void GetListMembersResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool GetListMembersResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool GetListMembersResponse::success() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.GetListMembersResponse.success)
  return _internal_success();
}
inline void GetListMembersResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void GetListMembersResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:sonet.list.v1.GetListMembersResponse.success)
}

// repeated .sonet.list.v1.ListMember members = 2;
inline int GetListMembersResponse::_internal_members_size() const {
  return _impl_.members_.size();
}
inline int GetListMembersResponse::members_size() const {
  return _internal_members_size();
}
inline void GetListMembersResponse::clear_members() {
  _impl_.members_.Clear();
}
inline ::sonet::list::v1::ListMember* GetListMembersResponse::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.GetListMembersResponse.members)
  return _impl_.members_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::list::v1::ListMember >*
GetListMembersResponse::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:sonet.list.v1.GetListMembersResponse.members)
  return &_impl_.members_;
}
inline const ::sonet::list::v1::ListMember& GetListMembersResponse::_internal_members(int index) const {
  return _impl_.members_.Get(index);
}
inline const ::sonet::list::v1::ListMember& GetListMembersResponse::members(int index) const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.GetListMembersResponse.members)
  return _internal_members(index);
}
inline ::sonet::list::v1::ListMember* GetListMembersResponse::_internal_add_members() {
  return _impl_.members_.Add();
}
inline ::sonet::list::v1::ListMember* GetListMembersResponse::add_members() {
  ::sonet::list::v1::ListMember* _add = _internal_add_members();
  // @@protoc_insertion_point(field_add:sonet.list.v1.GetListMembersResponse.members)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::list::v1::ListMember >&
GetListMembersResponse::members() const {
  // @@protoc_insertion_point(field_list:sonet.list.v1.GetListMembersResponse.members)
  return _impl_.members_;
}

// string next_cursor = 3;
inline void GetListMembersResponse::clear_next_cursor() {
  _impl_.next_cursor_.ClearToEmpty();
}
inline const std::string& GetListMembersResponse::next_cursor() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.GetListMembersResponse.next_cursor)
  return _internal_next_cursor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetListMembersResponse::set_next_cursor(ArgT0&& arg0, ArgT... args) {
 
 _impl_.next_cursor_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.GetListMembersResponse.next_cursor)
}
inline std::string* GetListMembersResponse::mutable_next_cursor() {
  std::string* _s = _internal_mutable_next_cursor();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.GetListMembersResponse.next_cursor)
  return _s;
}
inline const std::string& GetListMembersResponse::_internal_next_cursor() const {
  return _impl_.next_cursor_.Get();
}
inline void GetListMembersResponse::_internal_set_next_cursor(const std::string& value) {
  
  _impl_.next_cursor_.Set(value, GetArenaForAllocation());
}
inline std::string* GetListMembersResponse::_internal_mutable_next_cursor() {
  
  return _impl_.next_cursor_.Mutable(GetArenaForAllocation());
}
inline std::string* GetListMembersResponse::release_next_cursor() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.GetListMembersResponse.next_cursor)
  return _impl_.next_cursor_.Release();
}
inline void GetListMembersResponse::set_allocated_next_cursor(std::string* next_cursor) {
  if (next_cursor != nullptr) {
    
  } else {
    
  }
  _impl_.next_cursor_.SetAllocated(next_cursor, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_cursor_.IsDefault()) {
    _impl_.next_cursor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.GetListMembersResponse.next_cursor)
}

// string error_message = 4;
inline void GetListMembersResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& GetListMembersResponse::error_message() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.GetListMembersResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetListMembersResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.GetListMembersResponse.error_message)
}
inline std::string* GetListMembersResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.GetListMembersResponse.error_message)
  return _s;
}
inline const std::string& GetListMembersResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void GetListMembersResponse::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* GetListMembersResponse::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* GetListMembersResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.GetListMembersResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void GetListMembersResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.GetListMembersResponse.error_message)
}

// -------------------------------------------------------------------

// IsUserInListRequest

// string list_id = 1;
inline void IsUserInListRequest::clear_list_id() {
  _impl_.list_id_.ClearToEmpty();
}
inline const std::string& IsUserInListRequest::list_id() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.IsUserInListRequest.list_id)
  return _internal_list_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IsUserInListRequest::set_list_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.list_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.IsUserInListRequest.list_id)
}
inline std::string* IsUserInListRequest::mutable_list_id() {
  std::string* _s = _internal_mutable_list_id();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.IsUserInListRequest.list_id)
  return _s;
}
inline const std::string& IsUserInListRequest::_internal_list_id() const {
  return _impl_.list_id_.Get();
}
inline void IsUserInListRequest::_internal_set_list_id(const std::string& value) {
  
  _impl_.list_id_.Set(value, GetArenaForAllocation());
}
inline std::string* IsUserInListRequest::_internal_mutable_list_id() {
  
  return _impl_.list_id_.Mutable(GetArenaForAllocation());
}
inline std::string* IsUserInListRequest::release_list_id() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.IsUserInListRequest.list_id)
  return _impl_.list_id_.Release();
}
inline void IsUserInListRequest::set_allocated_list_id(std::string* list_id) {
  if (list_id != nullptr) {
    
  } else {
    
  }
  _impl_.list_id_.SetAllocated(list_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.list_id_.IsDefault()) {
    _impl_.list_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.IsUserInListRequest.list_id)
}

// string user_id = 2;
inline void IsUserInListRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& IsUserInListRequest::user_id() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.IsUserInListRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IsUserInListRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.IsUserInListRequest.user_id)
}
inline std::string* IsUserInListRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.IsUserInListRequest.user_id)
  return _s;
}
inline const std::string& IsUserInListRequest::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void IsUserInListRequest::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* IsUserInListRequest::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* IsUserInListRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.IsUserInListRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void IsUserInListRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.IsUserInListRequest.user_id)
}

// string requester_id = 3;
inline void IsUserInListRequest::clear_requester_id() {
  _impl_.requester_id_.ClearToEmpty();
}
inline const std::string& IsUserInListRequest::requester_id() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.IsUserInListRequest.requester_id)
  return _internal_requester_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IsUserInListRequest::set_requester_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.requester_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.IsUserInListRequest.requester_id)
}
inline std::string* IsUserInListRequest::mutable_requester_id() {
  std::string* _s = _internal_mutable_requester_id();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.IsUserInListRequest.requester_id)
  return _s;
}
inline const std::string& IsUserInListRequest::_internal_requester_id() const {
  return _impl_.requester_id_.Get();
}
inline void IsUserInListRequest::_internal_set_requester_id(const std::string& value) {
  
  _impl_.requester_id_.Set(value, GetArenaForAllocation());
}
inline std::string* IsUserInListRequest::_internal_mutable_requester_id() {
  
  return _impl_.requester_id_.Mutable(GetArenaForAllocation());
}
inline std::string* IsUserInListRequest::release_requester_id() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.IsUserInListRequest.requester_id)
  return _impl_.requester_id_.Release();
}
inline void IsUserInListRequest::set_allocated_requester_id(std::string* requester_id) {
  if (requester_id != nullptr) {
    
  } else {
    
  }
  _impl_.requester_id_.SetAllocated(requester_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.requester_id_.IsDefault()) {
    _impl_.requester_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.IsUserInListRequest.requester_id)
}

// -------------------------------------------------------------------

// IsUserInListResponse

// bool success = 1;
inline void IsUserInListResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool IsUserInListResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool IsUserInListResponse::success() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.IsUserInListResponse.success)
  return _internal_success();
}
inline void IsUserInListResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void IsUserInListResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:sonet.list.v1.IsUserInListResponse.success)
}

// bool is_member = 2;
inline void IsUserInListResponse::clear_is_member() {
  _impl_.is_member_ = false;
}
inline bool IsUserInListResponse::_internal_is_member() const {
  return _impl_.is_member_;
}
inline bool IsUserInListResponse::is_member() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.IsUserInListResponse.is_member)
  return _internal_is_member();
}
inline void IsUserInListResponse::_internal_set_is_member(bool value) {
  
  _impl_.is_member_ = value;
}
inline void IsUserInListResponse::set_is_member(bool value) {
  _internal_set_is_member(value);
  // @@protoc_insertion_point(field_set:sonet.list.v1.IsUserInListResponse.is_member)
}

// string error_message = 3;
inline void IsUserInListResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& IsUserInListResponse::error_message() const {
  // @@protoc_insertion_point(field_get:sonet.list.v1.IsUserInListResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IsUserInListResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.list.v1.IsUserInListResponse.error_message)
}
inline std::string* IsUserInListResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:sonet.list.v1.IsUserInListResponse.error_message)
  return _s;
}
inline const std::string& IsUserInListResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void IsUserInListResponse::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* IsUserInListResponse::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* IsUserInListResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:sonet.list.v1.IsUserInListResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void IsUserInListResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.list.v1.IsUserInListResponse.error_message)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace list
}  // namespace sonet

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::sonet::list::v1::ListType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sonet::list::v1::ListType>() {
  return ::sonet::list::v1::ListType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_services_2flist_5fservice_2eproto
