// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: services/messaging.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_services_2fmessaging_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_services_2fmessaging_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common/common.pb.h"
#include "common/timestamp.pb.h"
#include "common/pagination.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_services_2fmessaging_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_services_2fmessaging_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_services_2fmessaging_2eproto;
namespace sonet {
namespace messaging {
class Attachment;
struct AttachmentDefaultTypeInternal;
extern AttachmentDefaultTypeInternal _Attachment_default_instance_;
class Attachment_MetadataEntry_DoNotUse;
struct Attachment_MetadataEntry_DoNotUseDefaultTypeInternal;
extern Attachment_MetadataEntry_DoNotUseDefaultTypeInternal _Attachment_MetadataEntry_DoNotUse_default_instance_;
class Chat;
struct ChatDefaultTypeInternal;
extern ChatDefaultTypeInternal _Chat_default_instance_;
class Chat_SettingsEntry_DoNotUse;
struct Chat_SettingsEntry_DoNotUseDefaultTypeInternal;
extern Chat_SettingsEntry_DoNotUseDefaultTypeInternal _Chat_SettingsEntry_DoNotUse_default_instance_;
class CreateChatRequest;
struct CreateChatRequestDefaultTypeInternal;
extern CreateChatRequestDefaultTypeInternal _CreateChatRequest_default_instance_;
class CreateChatResponse;
struct CreateChatResponseDefaultTypeInternal;
extern CreateChatResponseDefaultTypeInternal _CreateChatResponse_default_instance_;
class GetChatsRequest;
struct GetChatsRequestDefaultTypeInternal;
extern GetChatsRequestDefaultTypeInternal _GetChatsRequest_default_instance_;
class GetChatsResponse;
struct GetChatsResponseDefaultTypeInternal;
extern GetChatsResponseDefaultTypeInternal _GetChatsResponse_default_instance_;
class GetMessagesRequest;
struct GetMessagesRequestDefaultTypeInternal;
extern GetMessagesRequestDefaultTypeInternal _GetMessagesRequest_default_instance_;
class GetMessagesResponse;
struct GetMessagesResponseDefaultTypeInternal;
extern GetMessagesResponseDefaultTypeInternal _GetMessagesResponse_default_instance_;
class Message;
struct MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class ReadReceipt;
struct ReadReceiptDefaultTypeInternal;
extern ReadReceiptDefaultTypeInternal _ReadReceipt_default_instance_;
class SearchMessagesRequest;
struct SearchMessagesRequestDefaultTypeInternal;
extern SearchMessagesRequestDefaultTypeInternal _SearchMessagesRequest_default_instance_;
class SearchMessagesResponse;
struct SearchMessagesResponseDefaultTypeInternal;
extern SearchMessagesResponseDefaultTypeInternal _SearchMessagesResponse_default_instance_;
class SendMessageRequest;
struct SendMessageRequestDefaultTypeInternal;
extern SendMessageRequestDefaultTypeInternal _SendMessageRequest_default_instance_;
class SendMessageResponse;
struct SendMessageResponseDefaultTypeInternal;
extern SendMessageResponseDefaultTypeInternal _SendMessageResponse_default_instance_;
class SetTypingRequest;
struct SetTypingRequestDefaultTypeInternal;
extern SetTypingRequestDefaultTypeInternal _SetTypingRequest_default_instance_;
class SetTypingResponse;
struct SetTypingResponseDefaultTypeInternal;
extern SetTypingResponseDefaultTypeInternal _SetTypingResponse_default_instance_;
class TypingIndicator;
struct TypingIndicatorDefaultTypeInternal;
extern TypingIndicatorDefaultTypeInternal _TypingIndicator_default_instance_;
class UpdateMessageStatusRequest;
struct UpdateMessageStatusRequestDefaultTypeInternal;
extern UpdateMessageStatusRequestDefaultTypeInternal _UpdateMessageStatusRequest_default_instance_;
class UpdateMessageStatusResponse;
struct UpdateMessageStatusResponseDefaultTypeInternal;
extern UpdateMessageStatusResponseDefaultTypeInternal _UpdateMessageStatusResponse_default_instance_;
class UploadAttachmentRequest;
struct UploadAttachmentRequestDefaultTypeInternal;
extern UploadAttachmentRequestDefaultTypeInternal _UploadAttachmentRequest_default_instance_;
class UploadAttachmentResponse;
struct UploadAttachmentResponseDefaultTypeInternal;
extern UploadAttachmentResponseDefaultTypeInternal _UploadAttachmentResponse_default_instance_;
class WebSocketMessage;
struct WebSocketMessageDefaultTypeInternal;
extern WebSocketMessageDefaultTypeInternal _WebSocketMessage_default_instance_;
}  // namespace messaging
}  // namespace sonet
PROTOBUF_NAMESPACE_OPEN
template<> ::sonet::messaging::Attachment* Arena::CreateMaybeMessage<::sonet::messaging::Attachment>(Arena*);
template<> ::sonet::messaging::Attachment_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::sonet::messaging::Attachment_MetadataEntry_DoNotUse>(Arena*);
template<> ::sonet::messaging::Chat* Arena::CreateMaybeMessage<::sonet::messaging::Chat>(Arena*);
template<> ::sonet::messaging::Chat_SettingsEntry_DoNotUse* Arena::CreateMaybeMessage<::sonet::messaging::Chat_SettingsEntry_DoNotUse>(Arena*);
template<> ::sonet::messaging::CreateChatRequest* Arena::CreateMaybeMessage<::sonet::messaging::CreateChatRequest>(Arena*);
template<> ::sonet::messaging::CreateChatResponse* Arena::CreateMaybeMessage<::sonet::messaging::CreateChatResponse>(Arena*);
template<> ::sonet::messaging::GetChatsRequest* Arena::CreateMaybeMessage<::sonet::messaging::GetChatsRequest>(Arena*);
template<> ::sonet::messaging::GetChatsResponse* Arena::CreateMaybeMessage<::sonet::messaging::GetChatsResponse>(Arena*);
template<> ::sonet::messaging::GetMessagesRequest* Arena::CreateMaybeMessage<::sonet::messaging::GetMessagesRequest>(Arena*);
template<> ::sonet::messaging::GetMessagesResponse* Arena::CreateMaybeMessage<::sonet::messaging::GetMessagesResponse>(Arena*);
template<> ::sonet::messaging::Message* Arena::CreateMaybeMessage<::sonet::messaging::Message>(Arena*);
template<> ::sonet::messaging::ReadReceipt* Arena::CreateMaybeMessage<::sonet::messaging::ReadReceipt>(Arena*);
template<> ::sonet::messaging::SearchMessagesRequest* Arena::CreateMaybeMessage<::sonet::messaging::SearchMessagesRequest>(Arena*);
template<> ::sonet::messaging::SearchMessagesResponse* Arena::CreateMaybeMessage<::sonet::messaging::SearchMessagesResponse>(Arena*);
template<> ::sonet::messaging::SendMessageRequest* Arena::CreateMaybeMessage<::sonet::messaging::SendMessageRequest>(Arena*);
template<> ::sonet::messaging::SendMessageResponse* Arena::CreateMaybeMessage<::sonet::messaging::SendMessageResponse>(Arena*);
template<> ::sonet::messaging::SetTypingRequest* Arena::CreateMaybeMessage<::sonet::messaging::SetTypingRequest>(Arena*);
template<> ::sonet::messaging::SetTypingResponse* Arena::CreateMaybeMessage<::sonet::messaging::SetTypingResponse>(Arena*);
template<> ::sonet::messaging::TypingIndicator* Arena::CreateMaybeMessage<::sonet::messaging::TypingIndicator>(Arena*);
template<> ::sonet::messaging::UpdateMessageStatusRequest* Arena::CreateMaybeMessage<::sonet::messaging::UpdateMessageStatusRequest>(Arena*);
template<> ::sonet::messaging::UpdateMessageStatusResponse* Arena::CreateMaybeMessage<::sonet::messaging::UpdateMessageStatusResponse>(Arena*);
template<> ::sonet::messaging::UploadAttachmentRequest* Arena::CreateMaybeMessage<::sonet::messaging::UploadAttachmentRequest>(Arena*);
template<> ::sonet::messaging::UploadAttachmentResponse* Arena::CreateMaybeMessage<::sonet::messaging::UploadAttachmentResponse>(Arena*);
template<> ::sonet::messaging::WebSocketMessage* Arena::CreateMaybeMessage<::sonet::messaging::WebSocketMessage>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sonet {
namespace messaging {

enum MessageType : int {
  MESSAGE_TYPE_UNSPECIFIED = 0,
  MESSAGE_TYPE_TEXT = 1,
  MESSAGE_TYPE_IMAGE = 2,
  MESSAGE_TYPE_VIDEO = 3,
  MESSAGE_TYPE_AUDIO = 4,
  MESSAGE_TYPE_FILE = 5,
  MESSAGE_TYPE_LOCATION = 6,
  MESSAGE_TYPE_SYSTEM = 7,
  MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MessageType_IsValid(int value);
constexpr MessageType MessageType_MIN = MESSAGE_TYPE_UNSPECIFIED;
constexpr MessageType MessageType_MAX = MESSAGE_TYPE_SYSTEM;
constexpr int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageType_descriptor();
template<typename T>
inline const std::string& MessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MessageType_descriptor(), enum_t_value);
}
inline bool MessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
enum MessageStatus : int {
  MESSAGE_STATUS_UNSPECIFIED = 0,
  MESSAGE_STATUS_SENT = 1,
  MESSAGE_STATUS_DELIVERED = 2,
  MESSAGE_STATUS_READ = 3,
  MESSAGE_STATUS_FAILED = 4,
  MessageStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MessageStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MessageStatus_IsValid(int value);
constexpr MessageStatus MessageStatus_MIN = MESSAGE_STATUS_UNSPECIFIED;
constexpr MessageStatus MessageStatus_MAX = MESSAGE_STATUS_FAILED;
constexpr int MessageStatus_ARRAYSIZE = MessageStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageStatus_descriptor();
template<typename T>
inline const std::string& MessageStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MessageStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MessageStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MessageStatus_descriptor(), enum_t_value);
}
inline bool MessageStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MessageStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MessageStatus>(
    MessageStatus_descriptor(), name, value);
}
enum ChatType : int {
  CHAT_TYPE_UNSPECIFIED = 0,
  CHAT_TYPE_DIRECT = 1,
  CHAT_TYPE_GROUP = 2,
  CHAT_TYPE_CHANNEL = 3,
  ChatType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ChatType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ChatType_IsValid(int value);
constexpr ChatType ChatType_MIN = CHAT_TYPE_UNSPECIFIED;
constexpr ChatType ChatType_MAX = CHAT_TYPE_CHANNEL;
constexpr int ChatType_ARRAYSIZE = ChatType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChatType_descriptor();
template<typename T>
inline const std::string& ChatType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChatType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChatType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChatType_descriptor(), enum_t_value);
}
inline bool ChatType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChatType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChatType>(
    ChatType_descriptor(), name, value);
}
enum EncryptionType : int {
  ENCRYPTION_TYPE_UNSPECIFIED = 0,
  ENCRYPTION_TYPE_NONE = 1,
  ENCRYPTION_TYPE_AES256 = 2,
  ENCRYPTION_TYPE_E2E = 3,
  EncryptionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EncryptionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EncryptionType_IsValid(int value);
constexpr EncryptionType EncryptionType_MIN = ENCRYPTION_TYPE_UNSPECIFIED;
constexpr EncryptionType EncryptionType_MAX = ENCRYPTION_TYPE_E2E;
constexpr int EncryptionType_ARRAYSIZE = EncryptionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EncryptionType_descriptor();
template<typename T>
inline const std::string& EncryptionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EncryptionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EncryptionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EncryptionType_descriptor(), enum_t_value);
}
inline bool EncryptionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EncryptionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EncryptionType>(
    EncryptionType_descriptor(), name, value);
}
// ===================================================================

class Message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.messaging.Message) */ {
 public:
  inline Message() : Message(nullptr) {}
  ~Message() override;
  explicit PROTOBUF_CONSTEXPR Message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Message(const Message& from);
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  inline Message& operator=(Message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Message& default_instance() {
    return *internal_default_instance();
  }
  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }
  inline void Swap(Message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Message& from) {
    Message::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.messaging.Message";
  }
  protected:
  explicit Message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttachmentsFieldNumber = 9,
    kMessageIdFieldNumber = 1,
    kChatIdFieldNumber = 2,
    kSenderIdFieldNumber = 3,
    kContentFieldNumber = 4,
    kEncryptedContentFieldNumber = 8,
    kReplyToMessageIdFieldNumber = 10,
    kCreatedAtFieldNumber = 12,
    kUpdatedAtFieldNumber = 13,
    kDeliveredAtFieldNumber = 14,
    kReadAtFieldNumber = 15,
    kTypeFieldNumber = 5,
    kStatusFieldNumber = 6,
    kEncryptionFieldNumber = 7,
    kIsEditedFieldNumber = 11,
  };
  // repeated string attachments = 9;
  int attachments_size() const;
  private:
  int _internal_attachments_size() const;
  public:
  void clear_attachments();
  const std::string& attachments(int index) const;
  std::string* mutable_attachments(int index);
  void set_attachments(int index, const std::string& value);
  void set_attachments(int index, std::string&& value);
  void set_attachments(int index, const char* value);
  void set_attachments(int index, const char* value, size_t size);
  std::string* add_attachments();
  void add_attachments(const std::string& value);
  void add_attachments(std::string&& value);
  void add_attachments(const char* value);
  void add_attachments(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& attachments() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_attachments();
  private:
  const std::string& _internal_attachments(int index) const;
  std::string* _internal_add_attachments();
  public:

  // string message_id = 1;
  void clear_message_id();
  const std::string& message_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_id();
  PROTOBUF_NODISCARD std::string* release_message_id();
  void set_allocated_message_id(std::string* message_id);
  private:
  const std::string& _internal_message_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_id(const std::string& value);
  std::string* _internal_mutable_message_id();
  public:

  // string chat_id = 2;
  void clear_chat_id();
  const std::string& chat_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chat_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chat_id();
  PROTOBUF_NODISCARD std::string* release_chat_id();
  void set_allocated_chat_id(std::string* chat_id);
  private:
  const std::string& _internal_chat_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chat_id(const std::string& value);
  std::string* _internal_mutable_chat_id();
  public:

  // string sender_id = 3;
  void clear_sender_id();
  const std::string& sender_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sender_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sender_id();
  PROTOBUF_NODISCARD std::string* release_sender_id();
  void set_allocated_sender_id(std::string* sender_id);
  private:
  const std::string& _internal_sender_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender_id(const std::string& value);
  std::string* _internal_mutable_sender_id();
  public:

  // string content = 4;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // string encrypted_content = 8;
  void clear_encrypted_content();
  const std::string& encrypted_content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encrypted_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encrypted_content();
  PROTOBUF_NODISCARD std::string* release_encrypted_content();
  void set_allocated_encrypted_content(std::string* encrypted_content);
  private:
  const std::string& _internal_encrypted_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encrypted_content(const std::string& value);
  std::string* _internal_mutable_encrypted_content();
  public:

  // string reply_to_message_id = 10;
  void clear_reply_to_message_id();
  const std::string& reply_to_message_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reply_to_message_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reply_to_message_id();
  PROTOBUF_NODISCARD std::string* release_reply_to_message_id();
  void set_allocated_reply_to_message_id(std::string* reply_to_message_id);
  private:
  const std::string& _internal_reply_to_message_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reply_to_message_id(const std::string& value);
  std::string* _internal_mutable_reply_to_message_id();
  public:

  // .sonet.common.Timestamp created_at = 12;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::sonet::common::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::sonet::common::Timestamp* release_created_at();
  ::sonet::common::Timestamp* mutable_created_at();
  void set_allocated_created_at(::sonet::common::Timestamp* created_at);
  private:
  const ::sonet::common::Timestamp& _internal_created_at() const;
  ::sonet::common::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::sonet::common::Timestamp* created_at);
  ::sonet::common::Timestamp* unsafe_arena_release_created_at();

  // .sonet.common.Timestamp updated_at = 13;
  bool has_updated_at() const;
  private:
  bool _internal_has_updated_at() const;
  public:
  void clear_updated_at();
  const ::sonet::common::Timestamp& updated_at() const;
  PROTOBUF_NODISCARD ::sonet::common::Timestamp* release_updated_at();
  ::sonet::common::Timestamp* mutable_updated_at();
  void set_allocated_updated_at(::sonet::common::Timestamp* updated_at);
  private:
  const ::sonet::common::Timestamp& _internal_updated_at() const;
  ::sonet::common::Timestamp* _internal_mutable_updated_at();
  public:
  void unsafe_arena_set_allocated_updated_at(
      ::sonet::common::Timestamp* updated_at);
  ::sonet::common::Timestamp* unsafe_arena_release_updated_at();

  // .sonet.common.Timestamp delivered_at = 14;
  bool has_delivered_at() const;
  private:
  bool _internal_has_delivered_at() const;
  public:
  void clear_delivered_at();
  const ::sonet::common::Timestamp& delivered_at() const;
  PROTOBUF_NODISCARD ::sonet::common::Timestamp* release_delivered_at();
  ::sonet::common::Timestamp* mutable_delivered_at();
  void set_allocated_delivered_at(::sonet::common::Timestamp* delivered_at);
  private:
  const ::sonet::common::Timestamp& _internal_delivered_at() const;
  ::sonet::common::Timestamp* _internal_mutable_delivered_at();
  public:
  void unsafe_arena_set_allocated_delivered_at(
      ::sonet::common::Timestamp* delivered_at);
  ::sonet::common::Timestamp* unsafe_arena_release_delivered_at();

  // .sonet.common.Timestamp read_at = 15;
  bool has_read_at() const;
  private:
  bool _internal_has_read_at() const;
  public:
  void clear_read_at();
  const ::sonet::common::Timestamp& read_at() const;
  PROTOBUF_NODISCARD ::sonet::common::Timestamp* release_read_at();
  ::sonet::common::Timestamp* mutable_read_at();
  void set_allocated_read_at(::sonet::common::Timestamp* read_at);
  private:
  const ::sonet::common::Timestamp& _internal_read_at() const;
  ::sonet::common::Timestamp* _internal_mutable_read_at();
  public:
  void unsafe_arena_set_allocated_read_at(
      ::sonet::common::Timestamp* read_at);
  ::sonet::common::Timestamp* unsafe_arena_release_read_at();

  // .sonet.messaging.MessageType type = 5;
  void clear_type();
  ::sonet::messaging::MessageType type() const;
  void set_type(::sonet::messaging::MessageType value);
  private:
  ::sonet::messaging::MessageType _internal_type() const;
  void _internal_set_type(::sonet::messaging::MessageType value);
  public:

  // .sonet.messaging.MessageStatus status = 6;
  void clear_status();
  ::sonet::messaging::MessageStatus status() const;
  void set_status(::sonet::messaging::MessageStatus value);
  private:
  ::sonet::messaging::MessageStatus _internal_status() const;
  void _internal_set_status(::sonet::messaging::MessageStatus value);
  public:

  // .sonet.messaging.EncryptionType encryption = 7;
  void clear_encryption();
  ::sonet::messaging::EncryptionType encryption() const;
  void set_encryption(::sonet::messaging::EncryptionType value);
  private:
  ::sonet::messaging::EncryptionType _internal_encryption() const;
  void _internal_set_encryption(::sonet::messaging::EncryptionType value);
  public:

  // bool is_edited = 11;
  void clear_is_edited();
  bool is_edited() const;
  void set_is_edited(bool value);
  private:
  bool _internal_is_edited() const;
  void _internal_set_is_edited(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.messaging.Message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> attachments_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chat_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encrypted_content_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reply_to_message_id_;
    ::sonet::common::Timestamp* created_at_;
    ::sonet::common::Timestamp* updated_at_;
    ::sonet::common::Timestamp* delivered_at_;
    ::sonet::common::Timestamp* read_at_;
    int type_;
    int status_;
    int encryption_;
    bool is_edited_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fmessaging_2eproto;
};
// -------------------------------------------------------------------

class Chat_SettingsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Chat_SettingsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Chat_SettingsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Chat_SettingsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Chat_SettingsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Chat_SettingsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Chat_SettingsEntry_DoNotUse& other);
  static const Chat_SettingsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Chat_SettingsEntry_DoNotUse*>(&_Chat_SettingsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "sonet.messaging.Chat.SettingsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "sonet.messaging.Chat.SettingsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_services_2fmessaging_2eproto;
};

// -------------------------------------------------------------------

class Chat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.messaging.Chat) */ {
 public:
  inline Chat() : Chat(nullptr) {}
  ~Chat() override;
  explicit PROTOBUF_CONSTEXPR Chat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Chat(const Chat& from);
  Chat(Chat&& from) noexcept
    : Chat() {
    *this = ::std::move(from);
  }

  inline Chat& operator=(const Chat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Chat& operator=(Chat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Chat& default_instance() {
    return *internal_default_instance();
  }
  static inline const Chat* internal_default_instance() {
    return reinterpret_cast<const Chat*>(
               &_Chat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Chat& a, Chat& b) {
    a.Swap(&b);
  }
  inline void Swap(Chat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Chat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Chat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Chat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Chat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Chat& from) {
    Chat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Chat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.messaging.Chat";
  }
  protected:
  explicit Chat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kParticipantIdsFieldNumber = 6,
    kSettingsFieldNumber = 12,
    kChatIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kCreatorIdFieldNumber = 5,
    kLastMessageIdFieldNumber = 7,
    kAvatarUrlFieldNumber = 11,
    kLastActivityFieldNumber = 8,
    kCreatedAtFieldNumber = 13,
    kUpdatedAtFieldNumber = 14,
    kTypeFieldNumber = 4,
    kIsArchivedFieldNumber = 9,
    kIsMutedFieldNumber = 10,
  };
  // repeated string participant_ids = 6;
  int participant_ids_size() const;
  private:
  int _internal_participant_ids_size() const;
  public:
  void clear_participant_ids();
  const std::string& participant_ids(int index) const;
  std::string* mutable_participant_ids(int index);
  void set_participant_ids(int index, const std::string& value);
  void set_participant_ids(int index, std::string&& value);
  void set_participant_ids(int index, const char* value);
  void set_participant_ids(int index, const char* value, size_t size);
  std::string* add_participant_ids();
  void add_participant_ids(const std::string& value);
  void add_participant_ids(std::string&& value);
  void add_participant_ids(const char* value);
  void add_participant_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& participant_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_participant_ids();
  private:
  const std::string& _internal_participant_ids(int index) const;
  std::string* _internal_add_participant_ids();
  public:

  // map<string, string> settings = 12;
  int settings_size() const;
  private:
  int _internal_settings_size() const;
  public:
  void clear_settings();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_settings() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_settings();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      settings() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_settings();

  // string chat_id = 1;
  void clear_chat_id();
  const std::string& chat_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chat_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chat_id();
  PROTOBUF_NODISCARD std::string* release_chat_id();
  void set_allocated_chat_id(std::string* chat_id);
  private:
  const std::string& _internal_chat_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chat_id(const std::string& value);
  std::string* _internal_mutable_chat_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string creator_id = 5;
  void clear_creator_id();
  const std::string& creator_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_creator_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_creator_id();
  PROTOBUF_NODISCARD std::string* release_creator_id();
  void set_allocated_creator_id(std::string* creator_id);
  private:
  const std::string& _internal_creator_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creator_id(const std::string& value);
  std::string* _internal_mutable_creator_id();
  public:

  // string last_message_id = 7;
  void clear_last_message_id();
  const std::string& last_message_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_last_message_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_last_message_id();
  PROTOBUF_NODISCARD std::string* release_last_message_id();
  void set_allocated_last_message_id(std::string* last_message_id);
  private:
  const std::string& _internal_last_message_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_message_id(const std::string& value);
  std::string* _internal_mutable_last_message_id();
  public:

  // string avatar_url = 11;
  void clear_avatar_url();
  const std::string& avatar_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_avatar_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_avatar_url();
  PROTOBUF_NODISCARD std::string* release_avatar_url();
  void set_allocated_avatar_url(std::string* avatar_url);
  private:
  const std::string& _internal_avatar_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_avatar_url(const std::string& value);
  std::string* _internal_mutable_avatar_url();
  public:

  // .sonet.common.Timestamp last_activity = 8;
  bool has_last_activity() const;
  private:
  bool _internal_has_last_activity() const;
  public:
  void clear_last_activity();
  const ::sonet::common::Timestamp& last_activity() const;
  PROTOBUF_NODISCARD ::sonet::common::Timestamp* release_last_activity();
  ::sonet::common::Timestamp* mutable_last_activity();
  void set_allocated_last_activity(::sonet::common::Timestamp* last_activity);
  private:
  const ::sonet::common::Timestamp& _internal_last_activity() const;
  ::sonet::common::Timestamp* _internal_mutable_last_activity();
  public:
  void unsafe_arena_set_allocated_last_activity(
      ::sonet::common::Timestamp* last_activity);
  ::sonet::common::Timestamp* unsafe_arena_release_last_activity();

  // .sonet.common.Timestamp created_at = 13;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::sonet::common::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::sonet::common::Timestamp* release_created_at();
  ::sonet::common::Timestamp* mutable_created_at();
  void set_allocated_created_at(::sonet::common::Timestamp* created_at);
  private:
  const ::sonet::common::Timestamp& _internal_created_at() const;
  ::sonet::common::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::sonet::common::Timestamp* created_at);
  ::sonet::common::Timestamp* unsafe_arena_release_created_at();

  // .sonet.common.Timestamp updated_at = 14;
  bool has_updated_at() const;
  private:
  bool _internal_has_updated_at() const;
  public:
  void clear_updated_at();
  const ::sonet::common::Timestamp& updated_at() const;
  PROTOBUF_NODISCARD ::sonet::common::Timestamp* release_updated_at();
  ::sonet::common::Timestamp* mutable_updated_at();
  void set_allocated_updated_at(::sonet::common::Timestamp* updated_at);
  private:
  const ::sonet::common::Timestamp& _internal_updated_at() const;
  ::sonet::common::Timestamp* _internal_mutable_updated_at();
  public:
  void unsafe_arena_set_allocated_updated_at(
      ::sonet::common::Timestamp* updated_at);
  ::sonet::common::Timestamp* unsafe_arena_release_updated_at();

  // .sonet.messaging.ChatType type = 4;
  void clear_type();
  ::sonet::messaging::ChatType type() const;
  void set_type(::sonet::messaging::ChatType value);
  private:
  ::sonet::messaging::ChatType _internal_type() const;
  void _internal_set_type(::sonet::messaging::ChatType value);
  public:

  // bool is_archived = 9;
  void clear_is_archived();
  bool is_archived() const;
  void set_is_archived(bool value);
  private:
  bool _internal_is_archived() const;
  void _internal_set_is_archived(bool value);
  public:

  // bool is_muted = 10;
  void clear_is_muted();
  bool is_muted() const;
  void set_is_muted(bool value);
  private:
  bool _internal_is_muted() const;
  void _internal_set_is_muted(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.messaging.Chat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> participant_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Chat_SettingsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> settings_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chat_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr creator_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_message_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr avatar_url_;
    ::sonet::common::Timestamp* last_activity_;
    ::sonet::common::Timestamp* created_at_;
    ::sonet::common::Timestamp* updated_at_;
    int type_;
    bool is_archived_;
    bool is_muted_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fmessaging_2eproto;
};
// -------------------------------------------------------------------

class TypingIndicator final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.messaging.TypingIndicator) */ {
 public:
  inline TypingIndicator() : TypingIndicator(nullptr) {}
  ~TypingIndicator() override;
  explicit PROTOBUF_CONSTEXPR TypingIndicator(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TypingIndicator(const TypingIndicator& from);
  TypingIndicator(TypingIndicator&& from) noexcept
    : TypingIndicator() {
    *this = ::std::move(from);
  }

  inline TypingIndicator& operator=(const TypingIndicator& from) {
    CopyFrom(from);
    return *this;
  }
  inline TypingIndicator& operator=(TypingIndicator&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TypingIndicator& default_instance() {
    return *internal_default_instance();
  }
  static inline const TypingIndicator* internal_default_instance() {
    return reinterpret_cast<const TypingIndicator*>(
               &_TypingIndicator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TypingIndicator& a, TypingIndicator& b) {
    a.Swap(&b);
  }
  inline void Swap(TypingIndicator* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TypingIndicator* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TypingIndicator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TypingIndicator>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TypingIndicator& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TypingIndicator& from) {
    TypingIndicator::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TypingIndicator* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.messaging.TypingIndicator";
  }
  protected:
  explicit TypingIndicator(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChatIdFieldNumber = 1,
    kUserIdFieldNumber = 2,
    kTimestampFieldNumber = 4,
    kIsTypingFieldNumber = 3,
  };
  // string chat_id = 1;
  void clear_chat_id();
  const std::string& chat_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chat_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chat_id();
  PROTOBUF_NODISCARD std::string* release_chat_id();
  void set_allocated_chat_id(std::string* chat_id);
  private:
  const std::string& _internal_chat_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chat_id(const std::string& value);
  std::string* _internal_mutable_chat_id();
  public:

  // string user_id = 2;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // .sonet.common.Timestamp timestamp = 4;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::sonet::common::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::sonet::common::Timestamp* release_timestamp();
  ::sonet::common::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::sonet::common::Timestamp* timestamp);
  private:
  const ::sonet::common::Timestamp& _internal_timestamp() const;
  ::sonet::common::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::sonet::common::Timestamp* timestamp);
  ::sonet::common::Timestamp* unsafe_arena_release_timestamp();

  // bool is_typing = 3;
  void clear_is_typing();
  bool is_typing() const;
  void set_is_typing(bool value);
  private:
  bool _internal_is_typing() const;
  void _internal_set_is_typing(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.messaging.TypingIndicator)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chat_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::sonet::common::Timestamp* timestamp_;
    bool is_typing_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fmessaging_2eproto;
};
// -------------------------------------------------------------------

class ReadReceipt final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.messaging.ReadReceipt) */ {
 public:
  inline ReadReceipt() : ReadReceipt(nullptr) {}
  ~ReadReceipt() override;
  explicit PROTOBUF_CONSTEXPR ReadReceipt(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadReceipt(const ReadReceipt& from);
  ReadReceipt(ReadReceipt&& from) noexcept
    : ReadReceipt() {
    *this = ::std::move(from);
  }

  inline ReadReceipt& operator=(const ReadReceipt& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadReceipt& operator=(ReadReceipt&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadReceipt& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadReceipt* internal_default_instance() {
    return reinterpret_cast<const ReadReceipt*>(
               &_ReadReceipt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ReadReceipt& a, ReadReceipt& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadReceipt* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadReceipt* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadReceipt* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadReceipt>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadReceipt& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadReceipt& from) {
    ReadReceipt::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadReceipt* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.messaging.ReadReceipt";
  }
  protected:
  explicit ReadReceipt(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageIdFieldNumber = 1,
    kUserIdFieldNumber = 2,
    kReadAtFieldNumber = 3,
  };
  // string message_id = 1;
  void clear_message_id();
  const std::string& message_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_id();
  PROTOBUF_NODISCARD std::string* release_message_id();
  void set_allocated_message_id(std::string* message_id);
  private:
  const std::string& _internal_message_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_id(const std::string& value);
  std::string* _internal_mutable_message_id();
  public:

  // string user_id = 2;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // .sonet.common.Timestamp read_at = 3;
  bool has_read_at() const;
  private:
  bool _internal_has_read_at() const;
  public:
  void clear_read_at();
  const ::sonet::common::Timestamp& read_at() const;
  PROTOBUF_NODISCARD ::sonet::common::Timestamp* release_read_at();
  ::sonet::common::Timestamp* mutable_read_at();
  void set_allocated_read_at(::sonet::common::Timestamp* read_at);
  private:
  const ::sonet::common::Timestamp& _internal_read_at() const;
  ::sonet::common::Timestamp* _internal_mutable_read_at();
  public:
  void unsafe_arena_set_allocated_read_at(
      ::sonet::common::Timestamp* read_at);
  ::sonet::common::Timestamp* unsafe_arena_release_read_at();

  // @@protoc_insertion_point(class_scope:sonet.messaging.ReadReceipt)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::sonet::common::Timestamp* read_at_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fmessaging_2eproto;
};
// -------------------------------------------------------------------

class Attachment_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Attachment_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Attachment_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Attachment_MetadataEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Attachment_MetadataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Attachment_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Attachment_MetadataEntry_DoNotUse& other);
  static const Attachment_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Attachment_MetadataEntry_DoNotUse*>(&_Attachment_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "sonet.messaging.Attachment.MetadataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "sonet.messaging.Attachment.MetadataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_services_2fmessaging_2eproto;
};

// -------------------------------------------------------------------

class Attachment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.messaging.Attachment) */ {
 public:
  inline Attachment() : Attachment(nullptr) {}
  ~Attachment() override;
  explicit PROTOBUF_CONSTEXPR Attachment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Attachment(const Attachment& from);
  Attachment(Attachment&& from) noexcept
    : Attachment() {
    *this = ::std::move(from);
  }

  inline Attachment& operator=(const Attachment& from) {
    CopyFrom(from);
    return *this;
  }
  inline Attachment& operator=(Attachment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Attachment& default_instance() {
    return *internal_default_instance();
  }
  static inline const Attachment* internal_default_instance() {
    return reinterpret_cast<const Attachment*>(
               &_Attachment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Attachment& a, Attachment& b) {
    a.Swap(&b);
  }
  inline void Swap(Attachment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Attachment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Attachment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Attachment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Attachment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Attachment& from) {
    Attachment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Attachment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.messaging.Attachment";
  }
  protected:
  explicit Attachment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 7,
    kAttachmentIdFieldNumber = 1,
    kFilenameFieldNumber = 2,
    kContentTypeFieldNumber = 3,
    kUrlFieldNumber = 5,
    kThumbnailUrlFieldNumber = 6,
    kSizeFieldNumber = 4,
  };
  // map<string, string> metadata = 7;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_metadata();

  // string attachment_id = 1;
  void clear_attachment_id();
  const std::string& attachment_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attachment_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attachment_id();
  PROTOBUF_NODISCARD std::string* release_attachment_id();
  void set_allocated_attachment_id(std::string* attachment_id);
  private:
  const std::string& _internal_attachment_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attachment_id(const std::string& value);
  std::string* _internal_mutable_attachment_id();
  public:

  // string filename = 2;
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // string content_type = 3;
  void clear_content_type();
  const std::string& content_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content_type();
  PROTOBUF_NODISCARD std::string* release_content_type();
  void set_allocated_content_type(std::string* content_type);
  private:
  const std::string& _internal_content_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content_type(const std::string& value);
  std::string* _internal_mutable_content_type();
  public:

  // string url = 5;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // string thumbnail_url = 6;
  void clear_thumbnail_url();
  const std::string& thumbnail_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thumbnail_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thumbnail_url();
  PROTOBUF_NODISCARD std::string* release_thumbnail_url();
  void set_allocated_thumbnail_url(std::string* thumbnail_url);
  private:
  const std::string& _internal_thumbnail_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thumbnail_url(const std::string& value);
  std::string* _internal_mutable_thumbnail_url();
  public:

  // int64 size = 4;
  void clear_size();
  int64_t size() const;
  void set_size(int64_t value);
  private:
  int64_t _internal_size() const;
  void _internal_set_size(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.messaging.Attachment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Attachment_MetadataEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> metadata_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attachment_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thumbnail_url_;
    int64_t size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fmessaging_2eproto;
};
// -------------------------------------------------------------------

class SendMessageRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.messaging.SendMessageRequest) */ {
 public:
  inline SendMessageRequest() : SendMessageRequest(nullptr) {}
  ~SendMessageRequest() override;
  explicit PROTOBUF_CONSTEXPR SendMessageRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendMessageRequest(const SendMessageRequest& from);
  SendMessageRequest(SendMessageRequest&& from) noexcept
    : SendMessageRequest() {
    *this = ::std::move(from);
  }

  inline SendMessageRequest& operator=(const SendMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendMessageRequest& operator=(SendMessageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendMessageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendMessageRequest* internal_default_instance() {
    return reinterpret_cast<const SendMessageRequest*>(
               &_SendMessageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SendMessageRequest& a, SendMessageRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SendMessageRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendMessageRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendMessageRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendMessageRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendMessageRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendMessageRequest& from) {
    SendMessageRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendMessageRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.messaging.SendMessageRequest";
  }
  protected:
  explicit SendMessageRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttachmentIdsFieldNumber = 4,
    kChatIdFieldNumber = 1,
    kContentFieldNumber = 2,
    kReplyToMessageIdFieldNumber = 5,
    kTypeFieldNumber = 3,
    kEncryptionFieldNumber = 6,
  };
  // repeated string attachment_ids = 4;
  int attachment_ids_size() const;
  private:
  int _internal_attachment_ids_size() const;
  public:
  void clear_attachment_ids();
  const std::string& attachment_ids(int index) const;
  std::string* mutable_attachment_ids(int index);
  void set_attachment_ids(int index, const std::string& value);
  void set_attachment_ids(int index, std::string&& value);
  void set_attachment_ids(int index, const char* value);
  void set_attachment_ids(int index, const char* value, size_t size);
  std::string* add_attachment_ids();
  void add_attachment_ids(const std::string& value);
  void add_attachment_ids(std::string&& value);
  void add_attachment_ids(const char* value);
  void add_attachment_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& attachment_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_attachment_ids();
  private:
  const std::string& _internal_attachment_ids(int index) const;
  std::string* _internal_add_attachment_ids();
  public:

  // string chat_id = 1;
  void clear_chat_id();
  const std::string& chat_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chat_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chat_id();
  PROTOBUF_NODISCARD std::string* release_chat_id();
  void set_allocated_chat_id(std::string* chat_id);
  private:
  const std::string& _internal_chat_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chat_id(const std::string& value);
  std::string* _internal_mutable_chat_id();
  public:

  // string content = 2;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // string reply_to_message_id = 5;
  void clear_reply_to_message_id();
  const std::string& reply_to_message_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reply_to_message_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reply_to_message_id();
  PROTOBUF_NODISCARD std::string* release_reply_to_message_id();
  void set_allocated_reply_to_message_id(std::string* reply_to_message_id);
  private:
  const std::string& _internal_reply_to_message_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reply_to_message_id(const std::string& value);
  std::string* _internal_mutable_reply_to_message_id();
  public:

  // .sonet.messaging.MessageType type = 3;
  void clear_type();
  ::sonet::messaging::MessageType type() const;
  void set_type(::sonet::messaging::MessageType value);
  private:
  ::sonet::messaging::MessageType _internal_type() const;
  void _internal_set_type(::sonet::messaging::MessageType value);
  public:

  // .sonet.messaging.EncryptionType encryption = 6;
  void clear_encryption();
  ::sonet::messaging::EncryptionType encryption() const;
  void set_encryption(::sonet::messaging::EncryptionType value);
  private:
  ::sonet::messaging::EncryptionType _internal_encryption() const;
  void _internal_set_encryption(::sonet::messaging::EncryptionType value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.messaging.SendMessageRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> attachment_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chat_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reply_to_message_id_;
    int type_;
    int encryption_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fmessaging_2eproto;
};
// -------------------------------------------------------------------

class SendMessageResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.messaging.SendMessageResponse) */ {
 public:
  inline SendMessageResponse() : SendMessageResponse(nullptr) {}
  ~SendMessageResponse() override;
  explicit PROTOBUF_CONSTEXPR SendMessageResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendMessageResponse(const SendMessageResponse& from);
  SendMessageResponse(SendMessageResponse&& from) noexcept
    : SendMessageResponse() {
    *this = ::std::move(from);
  }

  inline SendMessageResponse& operator=(const SendMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendMessageResponse& operator=(SendMessageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendMessageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendMessageResponse* internal_default_instance() {
    return reinterpret_cast<const SendMessageResponse*>(
               &_SendMessageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SendMessageResponse& a, SendMessageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SendMessageResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendMessageResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendMessageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendMessageResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendMessageResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendMessageResponse& from) {
    SendMessageResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendMessageResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.messaging.SendMessageResponse";
  }
  protected:
  explicit SendMessageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // .sonet.common.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::sonet::common::Status& status() const;
  PROTOBUF_NODISCARD ::sonet::common::Status* release_status();
  ::sonet::common::Status* mutable_status();
  void set_allocated_status(::sonet::common::Status* status);
  private:
  const ::sonet::common::Status& _internal_status() const;
  ::sonet::common::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::sonet::common::Status* status);
  ::sonet::common::Status* unsafe_arena_release_status();

  // .sonet.messaging.Message message = 2;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const ::sonet::messaging::Message& message() const;
  PROTOBUF_NODISCARD ::sonet::messaging::Message* release_message();
  ::sonet::messaging::Message* mutable_message();
  void set_allocated_message(::sonet::messaging::Message* message);
  private:
  const ::sonet::messaging::Message& _internal_message() const;
  ::sonet::messaging::Message* _internal_mutable_message();
  public:
  void unsafe_arena_set_allocated_message(
      ::sonet::messaging::Message* message);
  ::sonet::messaging::Message* unsafe_arena_release_message();

  // @@protoc_insertion_point(class_scope:sonet.messaging.SendMessageResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sonet::common::Status* status_;
    ::sonet::messaging::Message* message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fmessaging_2eproto;
};
// -------------------------------------------------------------------

class GetMessagesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.messaging.GetMessagesRequest) */ {
 public:
  inline GetMessagesRequest() : GetMessagesRequest(nullptr) {}
  ~GetMessagesRequest() override;
  explicit PROTOBUF_CONSTEXPR GetMessagesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetMessagesRequest(const GetMessagesRequest& from);
  GetMessagesRequest(GetMessagesRequest&& from) noexcept
    : GetMessagesRequest() {
    *this = ::std::move(from);
  }

  inline GetMessagesRequest& operator=(const GetMessagesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMessagesRequest& operator=(GetMessagesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetMessagesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetMessagesRequest* internal_default_instance() {
    return reinterpret_cast<const GetMessagesRequest*>(
               &_GetMessagesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GetMessagesRequest& a, GetMessagesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetMessagesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetMessagesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetMessagesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetMessagesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetMessagesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetMessagesRequest& from) {
    GetMessagesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetMessagesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.messaging.GetMessagesRequest";
  }
  protected:
  explicit GetMessagesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChatIdFieldNumber = 1,
    kPaginationFieldNumber = 2,
    kBeforeFieldNumber = 3,
    kAfterFieldNumber = 4,
  };
  // string chat_id = 1;
  void clear_chat_id();
  const std::string& chat_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chat_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chat_id();
  PROTOBUF_NODISCARD std::string* release_chat_id();
  void set_allocated_chat_id(std::string* chat_id);
  private:
  const std::string& _internal_chat_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chat_id(const std::string& value);
  std::string* _internal_mutable_chat_id();
  public:

  // .sonet.common.PaginationRequest pagination = 2;
  bool has_pagination() const;
  private:
  bool _internal_has_pagination() const;
  public:
  void clear_pagination();
  const ::sonet::common::PaginationRequest& pagination() const;
  PROTOBUF_NODISCARD ::sonet::common::PaginationRequest* release_pagination();
  ::sonet::common::PaginationRequest* mutable_pagination();
  void set_allocated_pagination(::sonet::common::PaginationRequest* pagination);
  private:
  const ::sonet::common::PaginationRequest& _internal_pagination() const;
  ::sonet::common::PaginationRequest* _internal_mutable_pagination();
  public:
  void unsafe_arena_set_allocated_pagination(
      ::sonet::common::PaginationRequest* pagination);
  ::sonet::common::PaginationRequest* unsafe_arena_release_pagination();

  // .sonet.common.Timestamp before = 3;
  bool has_before() const;
  private:
  bool _internal_has_before() const;
  public:
  void clear_before();
  const ::sonet::common::Timestamp& before() const;
  PROTOBUF_NODISCARD ::sonet::common::Timestamp* release_before();
  ::sonet::common::Timestamp* mutable_before();
  void set_allocated_before(::sonet::common::Timestamp* before);
  private:
  const ::sonet::common::Timestamp& _internal_before() const;
  ::sonet::common::Timestamp* _internal_mutable_before();
  public:
  void unsafe_arena_set_allocated_before(
      ::sonet::common::Timestamp* before);
  ::sonet::common::Timestamp* unsafe_arena_release_before();

  // .sonet.common.Timestamp after = 4;
  bool has_after() const;
  private:
  bool _internal_has_after() const;
  public:
  void clear_after();
  const ::sonet::common::Timestamp& after() const;
  PROTOBUF_NODISCARD ::sonet::common::Timestamp* release_after();
  ::sonet::common::Timestamp* mutable_after();
  void set_allocated_after(::sonet::common::Timestamp* after);
  private:
  const ::sonet::common::Timestamp& _internal_after() const;
  ::sonet::common::Timestamp* _internal_mutable_after();
  public:
  void unsafe_arena_set_allocated_after(
      ::sonet::common::Timestamp* after);
  ::sonet::common::Timestamp* unsafe_arena_release_after();

  // @@protoc_insertion_point(class_scope:sonet.messaging.GetMessagesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chat_id_;
    ::sonet::common::PaginationRequest* pagination_;
    ::sonet::common::Timestamp* before_;
    ::sonet::common::Timestamp* after_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fmessaging_2eproto;
};
// -------------------------------------------------------------------

class GetMessagesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.messaging.GetMessagesResponse) */ {
 public:
  inline GetMessagesResponse() : GetMessagesResponse(nullptr) {}
  ~GetMessagesResponse() override;
  explicit PROTOBUF_CONSTEXPR GetMessagesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetMessagesResponse(const GetMessagesResponse& from);
  GetMessagesResponse(GetMessagesResponse&& from) noexcept
    : GetMessagesResponse() {
    *this = ::std::move(from);
  }

  inline GetMessagesResponse& operator=(const GetMessagesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMessagesResponse& operator=(GetMessagesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetMessagesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetMessagesResponse* internal_default_instance() {
    return reinterpret_cast<const GetMessagesResponse*>(
               &_GetMessagesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetMessagesResponse& a, GetMessagesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetMessagesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetMessagesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetMessagesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetMessagesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetMessagesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetMessagesResponse& from) {
    GetMessagesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetMessagesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.messaging.GetMessagesResponse";
  }
  protected:
  explicit GetMessagesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessagesFieldNumber = 2,
    kStatusFieldNumber = 1,
    kPaginationFieldNumber = 3,
  };
  // repeated .sonet.messaging.Message messages = 2;
  int messages_size() const;
  private:
  int _internal_messages_size() const;
  public:
  void clear_messages();
  ::sonet::messaging::Message* mutable_messages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::messaging::Message >*
      mutable_messages();
  private:
  const ::sonet::messaging::Message& _internal_messages(int index) const;
  ::sonet::messaging::Message* _internal_add_messages();
  public:
  const ::sonet::messaging::Message& messages(int index) const;
  ::sonet::messaging::Message* add_messages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::messaging::Message >&
      messages() const;

  // .sonet.common.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::sonet::common::Status& status() const;
  PROTOBUF_NODISCARD ::sonet::common::Status* release_status();
  ::sonet::common::Status* mutable_status();
  void set_allocated_status(::sonet::common::Status* status);
  private:
  const ::sonet::common::Status& _internal_status() const;
  ::sonet::common::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::sonet::common::Status* status);
  ::sonet::common::Status* unsafe_arena_release_status();

  // .sonet.common.PaginationResponse pagination = 3;
  bool has_pagination() const;
  private:
  bool _internal_has_pagination() const;
  public:
  void clear_pagination();
  const ::sonet::common::PaginationResponse& pagination() const;
  PROTOBUF_NODISCARD ::sonet::common::PaginationResponse* release_pagination();
  ::sonet::common::PaginationResponse* mutable_pagination();
  void set_allocated_pagination(::sonet::common::PaginationResponse* pagination);
  private:
  const ::sonet::common::PaginationResponse& _internal_pagination() const;
  ::sonet::common::PaginationResponse* _internal_mutable_pagination();
  public:
  void unsafe_arena_set_allocated_pagination(
      ::sonet::common::PaginationResponse* pagination);
  ::sonet::common::PaginationResponse* unsafe_arena_release_pagination();

  // @@protoc_insertion_point(class_scope:sonet.messaging.GetMessagesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::messaging::Message > messages_;
    ::sonet::common::Status* status_;
    ::sonet::common::PaginationResponse* pagination_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fmessaging_2eproto;
};
// -------------------------------------------------------------------

class CreateChatRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.messaging.CreateChatRequest) */ {
 public:
  inline CreateChatRequest() : CreateChatRequest(nullptr) {}
  ~CreateChatRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateChatRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateChatRequest(const CreateChatRequest& from);
  CreateChatRequest(CreateChatRequest&& from) noexcept
    : CreateChatRequest() {
    *this = ::std::move(from);
  }

  inline CreateChatRequest& operator=(const CreateChatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateChatRequest& operator=(CreateChatRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateChatRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateChatRequest* internal_default_instance() {
    return reinterpret_cast<const CreateChatRequest*>(
               &_CreateChatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CreateChatRequest& a, CreateChatRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateChatRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateChatRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateChatRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateChatRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateChatRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateChatRequest& from) {
    CreateChatRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateChatRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.messaging.CreateChatRequest";
  }
  protected:
  explicit CreateChatRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantIdsFieldNumber = 4,
    kNameFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kAvatarUrlFieldNumber = 5,
    kTypeFieldNumber = 3,
  };
  // repeated string participant_ids = 4;
  int participant_ids_size() const;
  private:
  int _internal_participant_ids_size() const;
  public:
  void clear_participant_ids();
  const std::string& participant_ids(int index) const;
  std::string* mutable_participant_ids(int index);
  void set_participant_ids(int index, const std::string& value);
  void set_participant_ids(int index, std::string&& value);
  void set_participant_ids(int index, const char* value);
  void set_participant_ids(int index, const char* value, size_t size);
  std::string* add_participant_ids();
  void add_participant_ids(const std::string& value);
  void add_participant_ids(std::string&& value);
  void add_participant_ids(const char* value);
  void add_participant_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& participant_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_participant_ids();
  private:
  const std::string& _internal_participant_ids(int index) const;
  std::string* _internal_add_participant_ids();
  public:

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string avatar_url = 5;
  void clear_avatar_url();
  const std::string& avatar_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_avatar_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_avatar_url();
  PROTOBUF_NODISCARD std::string* release_avatar_url();
  void set_allocated_avatar_url(std::string* avatar_url);
  private:
  const std::string& _internal_avatar_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_avatar_url(const std::string& value);
  std::string* _internal_mutable_avatar_url();
  public:

  // .sonet.messaging.ChatType type = 3;
  void clear_type();
  ::sonet::messaging::ChatType type() const;
  void set_type(::sonet::messaging::ChatType value);
  private:
  ::sonet::messaging::ChatType _internal_type() const;
  void _internal_set_type(::sonet::messaging::ChatType value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.messaging.CreateChatRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> participant_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr avatar_url_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fmessaging_2eproto;
};
// -------------------------------------------------------------------

class CreateChatResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.messaging.CreateChatResponse) */ {
 public:
  inline CreateChatResponse() : CreateChatResponse(nullptr) {}
  ~CreateChatResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateChatResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateChatResponse(const CreateChatResponse& from);
  CreateChatResponse(CreateChatResponse&& from) noexcept
    : CreateChatResponse() {
    *this = ::std::move(from);
  }

  inline CreateChatResponse& operator=(const CreateChatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateChatResponse& operator=(CreateChatResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateChatResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateChatResponse* internal_default_instance() {
    return reinterpret_cast<const CreateChatResponse*>(
               &_CreateChatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CreateChatResponse& a, CreateChatResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateChatResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateChatResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateChatResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateChatResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateChatResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateChatResponse& from) {
    CreateChatResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateChatResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.messaging.CreateChatResponse";
  }
  protected:
  explicit CreateChatResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kChatFieldNumber = 2,
  };
  // .sonet.common.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::sonet::common::Status& status() const;
  PROTOBUF_NODISCARD ::sonet::common::Status* release_status();
  ::sonet::common::Status* mutable_status();
  void set_allocated_status(::sonet::common::Status* status);
  private:
  const ::sonet::common::Status& _internal_status() const;
  ::sonet::common::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::sonet::common::Status* status);
  ::sonet::common::Status* unsafe_arena_release_status();

  // .sonet.messaging.Chat chat = 2;
  bool has_chat() const;
  private:
  bool _internal_has_chat() const;
  public:
  void clear_chat();
  const ::sonet::messaging::Chat& chat() const;
  PROTOBUF_NODISCARD ::sonet::messaging::Chat* release_chat();
  ::sonet::messaging::Chat* mutable_chat();
  void set_allocated_chat(::sonet::messaging::Chat* chat);
  private:
  const ::sonet::messaging::Chat& _internal_chat() const;
  ::sonet::messaging::Chat* _internal_mutable_chat();
  public:
  void unsafe_arena_set_allocated_chat(
      ::sonet::messaging::Chat* chat);
  ::sonet::messaging::Chat* unsafe_arena_release_chat();

  // @@protoc_insertion_point(class_scope:sonet.messaging.CreateChatResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sonet::common::Status* status_;
    ::sonet::messaging::Chat* chat_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fmessaging_2eproto;
};
// -------------------------------------------------------------------

class GetChatsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.messaging.GetChatsRequest) */ {
 public:
  inline GetChatsRequest() : GetChatsRequest(nullptr) {}
  ~GetChatsRequest() override;
  explicit PROTOBUF_CONSTEXPR GetChatsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetChatsRequest(const GetChatsRequest& from);
  GetChatsRequest(GetChatsRequest&& from) noexcept
    : GetChatsRequest() {
    *this = ::std::move(from);
  }

  inline GetChatsRequest& operator=(const GetChatsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetChatsRequest& operator=(GetChatsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetChatsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetChatsRequest* internal_default_instance() {
    return reinterpret_cast<const GetChatsRequest*>(
               &_GetChatsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetChatsRequest& a, GetChatsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetChatsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetChatsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetChatsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetChatsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetChatsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetChatsRequest& from) {
    GetChatsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetChatsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.messaging.GetChatsRequest";
  }
  protected:
  explicit GetChatsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kPaginationFieldNumber = 3,
    kTypeFieldNumber = 2,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // .sonet.common.PaginationRequest pagination = 3;
  bool has_pagination() const;
  private:
  bool _internal_has_pagination() const;
  public:
  void clear_pagination();
  const ::sonet::common::PaginationRequest& pagination() const;
  PROTOBUF_NODISCARD ::sonet::common::PaginationRequest* release_pagination();
  ::sonet::common::PaginationRequest* mutable_pagination();
  void set_allocated_pagination(::sonet::common::PaginationRequest* pagination);
  private:
  const ::sonet::common::PaginationRequest& _internal_pagination() const;
  ::sonet::common::PaginationRequest* _internal_mutable_pagination();
  public:
  void unsafe_arena_set_allocated_pagination(
      ::sonet::common::PaginationRequest* pagination);
  ::sonet::common::PaginationRequest* unsafe_arena_release_pagination();

  // .sonet.messaging.ChatType type = 2;
  void clear_type();
  ::sonet::messaging::ChatType type() const;
  void set_type(::sonet::messaging::ChatType value);
  private:
  ::sonet::messaging::ChatType _internal_type() const;
  void _internal_set_type(::sonet::messaging::ChatType value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.messaging.GetChatsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::sonet::common::PaginationRequest* pagination_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fmessaging_2eproto;
};
// -------------------------------------------------------------------

class GetChatsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.messaging.GetChatsResponse) */ {
 public:
  inline GetChatsResponse() : GetChatsResponse(nullptr) {}
  ~GetChatsResponse() override;
  explicit PROTOBUF_CONSTEXPR GetChatsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetChatsResponse(const GetChatsResponse& from);
  GetChatsResponse(GetChatsResponse&& from) noexcept
    : GetChatsResponse() {
    *this = ::std::move(from);
  }

  inline GetChatsResponse& operator=(const GetChatsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetChatsResponse& operator=(GetChatsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetChatsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetChatsResponse* internal_default_instance() {
    return reinterpret_cast<const GetChatsResponse*>(
               &_GetChatsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetChatsResponse& a, GetChatsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetChatsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetChatsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetChatsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetChatsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetChatsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetChatsResponse& from) {
    GetChatsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetChatsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.messaging.GetChatsResponse";
  }
  protected:
  explicit GetChatsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChatsFieldNumber = 2,
    kStatusFieldNumber = 1,
    kPaginationFieldNumber = 3,
  };
  // repeated .sonet.messaging.Chat chats = 2;
  int chats_size() const;
  private:
  int _internal_chats_size() const;
  public:
  void clear_chats();
  ::sonet::messaging::Chat* mutable_chats(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::messaging::Chat >*
      mutable_chats();
  private:
  const ::sonet::messaging::Chat& _internal_chats(int index) const;
  ::sonet::messaging::Chat* _internal_add_chats();
  public:
  const ::sonet::messaging::Chat& chats(int index) const;
  ::sonet::messaging::Chat* add_chats();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::messaging::Chat >&
      chats() const;

  // .sonet.common.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::sonet::common::Status& status() const;
  PROTOBUF_NODISCARD ::sonet::common::Status* release_status();
  ::sonet::common::Status* mutable_status();
  void set_allocated_status(::sonet::common::Status* status);
  private:
  const ::sonet::common::Status& _internal_status() const;
  ::sonet::common::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::sonet::common::Status* status);
  ::sonet::common::Status* unsafe_arena_release_status();

  // .sonet.common.PaginationResponse pagination = 3;
  bool has_pagination() const;
  private:
  bool _internal_has_pagination() const;
  public:
  void clear_pagination();
  const ::sonet::common::PaginationResponse& pagination() const;
  PROTOBUF_NODISCARD ::sonet::common::PaginationResponse* release_pagination();
  ::sonet::common::PaginationResponse* mutable_pagination();
  void set_allocated_pagination(::sonet::common::PaginationResponse* pagination);
  private:
  const ::sonet::common::PaginationResponse& _internal_pagination() const;
  ::sonet::common::PaginationResponse* _internal_mutable_pagination();
  public:
  void unsafe_arena_set_allocated_pagination(
      ::sonet::common::PaginationResponse* pagination);
  ::sonet::common::PaginationResponse* unsafe_arena_release_pagination();

  // @@protoc_insertion_point(class_scope:sonet.messaging.GetChatsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::messaging::Chat > chats_;
    ::sonet::common::Status* status_;
    ::sonet::common::PaginationResponse* pagination_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fmessaging_2eproto;
};
// -------------------------------------------------------------------

class UpdateMessageStatusRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.messaging.UpdateMessageStatusRequest) */ {
 public:
  inline UpdateMessageStatusRequest() : UpdateMessageStatusRequest(nullptr) {}
  ~UpdateMessageStatusRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateMessageStatusRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateMessageStatusRequest(const UpdateMessageStatusRequest& from);
  UpdateMessageStatusRequest(UpdateMessageStatusRequest&& from) noexcept
    : UpdateMessageStatusRequest() {
    *this = ::std::move(from);
  }

  inline UpdateMessageStatusRequest& operator=(const UpdateMessageStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateMessageStatusRequest& operator=(UpdateMessageStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateMessageStatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateMessageStatusRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateMessageStatusRequest*>(
               &_UpdateMessageStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(UpdateMessageStatusRequest& a, UpdateMessageStatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateMessageStatusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateMessageStatusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateMessageStatusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateMessageStatusRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateMessageStatusRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateMessageStatusRequest& from) {
    UpdateMessageStatusRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateMessageStatusRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.messaging.UpdateMessageStatusRequest";
  }
  protected:
  explicit UpdateMessageStatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageIdFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // string message_id = 1;
  void clear_message_id();
  const std::string& message_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_id();
  PROTOBUF_NODISCARD std::string* release_message_id();
  void set_allocated_message_id(std::string* message_id);
  private:
  const std::string& _internal_message_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_id(const std::string& value);
  std::string* _internal_mutable_message_id();
  public:

  // .sonet.messaging.MessageStatus status = 2;
  void clear_status();
  ::sonet::messaging::MessageStatus status() const;
  void set_status(::sonet::messaging::MessageStatus value);
  private:
  ::sonet::messaging::MessageStatus _internal_status() const;
  void _internal_set_status(::sonet::messaging::MessageStatus value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.messaging.UpdateMessageStatusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_id_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fmessaging_2eproto;
};
// -------------------------------------------------------------------

class UpdateMessageStatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.messaging.UpdateMessageStatusResponse) */ {
 public:
  inline UpdateMessageStatusResponse() : UpdateMessageStatusResponse(nullptr) {}
  ~UpdateMessageStatusResponse() override;
  explicit PROTOBUF_CONSTEXPR UpdateMessageStatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateMessageStatusResponse(const UpdateMessageStatusResponse& from);
  UpdateMessageStatusResponse(UpdateMessageStatusResponse&& from) noexcept
    : UpdateMessageStatusResponse() {
    *this = ::std::move(from);
  }

  inline UpdateMessageStatusResponse& operator=(const UpdateMessageStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateMessageStatusResponse& operator=(UpdateMessageStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateMessageStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateMessageStatusResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateMessageStatusResponse*>(
               &_UpdateMessageStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(UpdateMessageStatusResponse& a, UpdateMessageStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateMessageStatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateMessageStatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateMessageStatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateMessageStatusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateMessageStatusResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateMessageStatusResponse& from) {
    UpdateMessageStatusResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateMessageStatusResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.messaging.UpdateMessageStatusResponse";
  }
  protected:
  explicit UpdateMessageStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .sonet.common.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::sonet::common::Status& status() const;
  PROTOBUF_NODISCARD ::sonet::common::Status* release_status();
  ::sonet::common::Status* mutable_status();
  void set_allocated_status(::sonet::common::Status* status);
  private:
  const ::sonet::common::Status& _internal_status() const;
  ::sonet::common::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::sonet::common::Status* status);
  ::sonet::common::Status* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:sonet.messaging.UpdateMessageStatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sonet::common::Status* status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fmessaging_2eproto;
};
// -------------------------------------------------------------------

class SearchMessagesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.messaging.SearchMessagesRequest) */ {
 public:
  inline SearchMessagesRequest() : SearchMessagesRequest(nullptr) {}
  ~SearchMessagesRequest() override;
  explicit PROTOBUF_CONSTEXPR SearchMessagesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SearchMessagesRequest(const SearchMessagesRequest& from);
  SearchMessagesRequest(SearchMessagesRequest&& from) noexcept
    : SearchMessagesRequest() {
    *this = ::std::move(from);
  }

  inline SearchMessagesRequest& operator=(const SearchMessagesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchMessagesRequest& operator=(SearchMessagesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchMessagesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchMessagesRequest* internal_default_instance() {
    return reinterpret_cast<const SearchMessagesRequest*>(
               &_SearchMessagesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SearchMessagesRequest& a, SearchMessagesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchMessagesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchMessagesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchMessagesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SearchMessagesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SearchMessagesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SearchMessagesRequest& from) {
    SearchMessagesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchMessagesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.messaging.SearchMessagesRequest";
  }
  protected:
  explicit SearchMessagesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQueryFieldNumber = 1,
    kChatIdFieldNumber = 2,
    kUserIdFieldNumber = 3,
    kPaginationFieldNumber = 5,
    kTypeFieldNumber = 4,
  };
  // string query = 1;
  void clear_query();
  const std::string& query() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_query(ArgT0&& arg0, ArgT... args);
  std::string* mutable_query();
  PROTOBUF_NODISCARD std::string* release_query();
  void set_allocated_query(std::string* query);
  private:
  const std::string& _internal_query() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_query(const std::string& value);
  std::string* _internal_mutable_query();
  public:

  // string chat_id = 2;
  void clear_chat_id();
  const std::string& chat_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chat_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chat_id();
  PROTOBUF_NODISCARD std::string* release_chat_id();
  void set_allocated_chat_id(std::string* chat_id);
  private:
  const std::string& _internal_chat_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chat_id(const std::string& value);
  std::string* _internal_mutable_chat_id();
  public:

  // string user_id = 3;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // .sonet.common.PaginationRequest pagination = 5;
  bool has_pagination() const;
  private:
  bool _internal_has_pagination() const;
  public:
  void clear_pagination();
  const ::sonet::common::PaginationRequest& pagination() const;
  PROTOBUF_NODISCARD ::sonet::common::PaginationRequest* release_pagination();
  ::sonet::common::PaginationRequest* mutable_pagination();
  void set_allocated_pagination(::sonet::common::PaginationRequest* pagination);
  private:
  const ::sonet::common::PaginationRequest& _internal_pagination() const;
  ::sonet::common::PaginationRequest* _internal_mutable_pagination();
  public:
  void unsafe_arena_set_allocated_pagination(
      ::sonet::common::PaginationRequest* pagination);
  ::sonet::common::PaginationRequest* unsafe_arena_release_pagination();

  // .sonet.messaging.MessageType type = 4;
  void clear_type();
  ::sonet::messaging::MessageType type() const;
  void set_type(::sonet::messaging::MessageType value);
  private:
  ::sonet::messaging::MessageType _internal_type() const;
  void _internal_set_type(::sonet::messaging::MessageType value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.messaging.SearchMessagesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr query_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chat_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::sonet::common::PaginationRequest* pagination_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fmessaging_2eproto;
};
// -------------------------------------------------------------------

class SearchMessagesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.messaging.SearchMessagesResponse) */ {
 public:
  inline SearchMessagesResponse() : SearchMessagesResponse(nullptr) {}
  ~SearchMessagesResponse() override;
  explicit PROTOBUF_CONSTEXPR SearchMessagesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SearchMessagesResponse(const SearchMessagesResponse& from);
  SearchMessagesResponse(SearchMessagesResponse&& from) noexcept
    : SearchMessagesResponse() {
    *this = ::std::move(from);
  }

  inline SearchMessagesResponse& operator=(const SearchMessagesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchMessagesResponse& operator=(SearchMessagesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchMessagesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchMessagesResponse* internal_default_instance() {
    return reinterpret_cast<const SearchMessagesResponse*>(
               &_SearchMessagesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SearchMessagesResponse& a, SearchMessagesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchMessagesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchMessagesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchMessagesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SearchMessagesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SearchMessagesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SearchMessagesResponse& from) {
    SearchMessagesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchMessagesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.messaging.SearchMessagesResponse";
  }
  protected:
  explicit SearchMessagesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessagesFieldNumber = 2,
    kStatusFieldNumber = 1,
    kPaginationFieldNumber = 3,
  };
  // repeated .sonet.messaging.Message messages = 2;
  int messages_size() const;
  private:
  int _internal_messages_size() const;
  public:
  void clear_messages();
  ::sonet::messaging::Message* mutable_messages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::messaging::Message >*
      mutable_messages();
  private:
  const ::sonet::messaging::Message& _internal_messages(int index) const;
  ::sonet::messaging::Message* _internal_add_messages();
  public:
  const ::sonet::messaging::Message& messages(int index) const;
  ::sonet::messaging::Message* add_messages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::messaging::Message >&
      messages() const;

  // .sonet.common.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::sonet::common::Status& status() const;
  PROTOBUF_NODISCARD ::sonet::common::Status* release_status();
  ::sonet::common::Status* mutable_status();
  void set_allocated_status(::sonet::common::Status* status);
  private:
  const ::sonet::common::Status& _internal_status() const;
  ::sonet::common::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::sonet::common::Status* status);
  ::sonet::common::Status* unsafe_arena_release_status();

  // .sonet.common.PaginationResponse pagination = 3;
  bool has_pagination() const;
  private:
  bool _internal_has_pagination() const;
  public:
  void clear_pagination();
  const ::sonet::common::PaginationResponse& pagination() const;
  PROTOBUF_NODISCARD ::sonet::common::PaginationResponse* release_pagination();
  ::sonet::common::PaginationResponse* mutable_pagination();
  void set_allocated_pagination(::sonet::common::PaginationResponse* pagination);
  private:
  const ::sonet::common::PaginationResponse& _internal_pagination() const;
  ::sonet::common::PaginationResponse* _internal_mutable_pagination();
  public:
  void unsafe_arena_set_allocated_pagination(
      ::sonet::common::PaginationResponse* pagination);
  ::sonet::common::PaginationResponse* unsafe_arena_release_pagination();

  // @@protoc_insertion_point(class_scope:sonet.messaging.SearchMessagesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::messaging::Message > messages_;
    ::sonet::common::Status* status_;
    ::sonet::common::PaginationResponse* pagination_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fmessaging_2eproto;
};
// -------------------------------------------------------------------

class UploadAttachmentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.messaging.UploadAttachmentRequest) */ {
 public:
  inline UploadAttachmentRequest() : UploadAttachmentRequest(nullptr) {}
  ~UploadAttachmentRequest() override;
  explicit PROTOBUF_CONSTEXPR UploadAttachmentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadAttachmentRequest(const UploadAttachmentRequest& from);
  UploadAttachmentRequest(UploadAttachmentRequest&& from) noexcept
    : UploadAttachmentRequest() {
    *this = ::std::move(from);
  }

  inline UploadAttachmentRequest& operator=(const UploadAttachmentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadAttachmentRequest& operator=(UploadAttachmentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UploadAttachmentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadAttachmentRequest* internal_default_instance() {
    return reinterpret_cast<const UploadAttachmentRequest*>(
               &_UploadAttachmentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(UploadAttachmentRequest& a, UploadAttachmentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadAttachmentRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadAttachmentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadAttachmentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadAttachmentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UploadAttachmentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UploadAttachmentRequest& from) {
    UploadAttachmentRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadAttachmentRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.messaging.UploadAttachmentRequest";
  }
  protected:
  explicit UploadAttachmentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilenameFieldNumber = 1,
    kContentTypeFieldNumber = 2,
    kDataFieldNumber = 3,
  };
  // string filename = 1;
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // string content_type = 2;
  void clear_content_type();
  const std::string& content_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content_type();
  PROTOBUF_NODISCARD std::string* release_content_type();
  void set_allocated_content_type(std::string* content_type);
  private:
  const std::string& _internal_content_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content_type(const std::string& value);
  std::string* _internal_mutable_content_type();
  public:

  // bytes data = 3;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:sonet.messaging.UploadAttachmentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fmessaging_2eproto;
};
// -------------------------------------------------------------------

class UploadAttachmentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.messaging.UploadAttachmentResponse) */ {
 public:
  inline UploadAttachmentResponse() : UploadAttachmentResponse(nullptr) {}
  ~UploadAttachmentResponse() override;
  explicit PROTOBUF_CONSTEXPR UploadAttachmentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadAttachmentResponse(const UploadAttachmentResponse& from);
  UploadAttachmentResponse(UploadAttachmentResponse&& from) noexcept
    : UploadAttachmentResponse() {
    *this = ::std::move(from);
  }

  inline UploadAttachmentResponse& operator=(const UploadAttachmentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadAttachmentResponse& operator=(UploadAttachmentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UploadAttachmentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadAttachmentResponse* internal_default_instance() {
    return reinterpret_cast<const UploadAttachmentResponse*>(
               &_UploadAttachmentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(UploadAttachmentResponse& a, UploadAttachmentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadAttachmentResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadAttachmentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadAttachmentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadAttachmentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UploadAttachmentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UploadAttachmentResponse& from) {
    UploadAttachmentResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadAttachmentResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.messaging.UploadAttachmentResponse";
  }
  protected:
  explicit UploadAttachmentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kAttachmentFieldNumber = 2,
  };
  // .sonet.common.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::sonet::common::Status& status() const;
  PROTOBUF_NODISCARD ::sonet::common::Status* release_status();
  ::sonet::common::Status* mutable_status();
  void set_allocated_status(::sonet::common::Status* status);
  private:
  const ::sonet::common::Status& _internal_status() const;
  ::sonet::common::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::sonet::common::Status* status);
  ::sonet::common::Status* unsafe_arena_release_status();

  // .sonet.messaging.Attachment attachment = 2;
  bool has_attachment() const;
  private:
  bool _internal_has_attachment() const;
  public:
  void clear_attachment();
  const ::sonet::messaging::Attachment& attachment() const;
  PROTOBUF_NODISCARD ::sonet::messaging::Attachment* release_attachment();
  ::sonet::messaging::Attachment* mutable_attachment();
  void set_allocated_attachment(::sonet::messaging::Attachment* attachment);
  private:
  const ::sonet::messaging::Attachment& _internal_attachment() const;
  ::sonet::messaging::Attachment* _internal_mutable_attachment();
  public:
  void unsafe_arena_set_allocated_attachment(
      ::sonet::messaging::Attachment* attachment);
  ::sonet::messaging::Attachment* unsafe_arena_release_attachment();

  // @@protoc_insertion_point(class_scope:sonet.messaging.UploadAttachmentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sonet::common::Status* status_;
    ::sonet::messaging::Attachment* attachment_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fmessaging_2eproto;
};
// -------------------------------------------------------------------

class SetTypingRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.messaging.SetTypingRequest) */ {
 public:
  inline SetTypingRequest() : SetTypingRequest(nullptr) {}
  ~SetTypingRequest() override;
  explicit PROTOBUF_CONSTEXPR SetTypingRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetTypingRequest(const SetTypingRequest& from);
  SetTypingRequest(SetTypingRequest&& from) noexcept
    : SetTypingRequest() {
    *this = ::std::move(from);
  }

  inline SetTypingRequest& operator=(const SetTypingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetTypingRequest& operator=(SetTypingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetTypingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetTypingRequest* internal_default_instance() {
    return reinterpret_cast<const SetTypingRequest*>(
               &_SetTypingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SetTypingRequest& a, SetTypingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetTypingRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetTypingRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetTypingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetTypingRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetTypingRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetTypingRequest& from) {
    SetTypingRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetTypingRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.messaging.SetTypingRequest";
  }
  protected:
  explicit SetTypingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChatIdFieldNumber = 1,
    kIsTypingFieldNumber = 2,
  };
  // string chat_id = 1;
  void clear_chat_id();
  const std::string& chat_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chat_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chat_id();
  PROTOBUF_NODISCARD std::string* release_chat_id();
  void set_allocated_chat_id(std::string* chat_id);
  private:
  const std::string& _internal_chat_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chat_id(const std::string& value);
  std::string* _internal_mutable_chat_id();
  public:

  // bool is_typing = 2;
  void clear_is_typing();
  bool is_typing() const;
  void set_is_typing(bool value);
  private:
  bool _internal_is_typing() const;
  void _internal_set_is_typing(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sonet.messaging.SetTypingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chat_id_;
    bool is_typing_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fmessaging_2eproto;
};
// -------------------------------------------------------------------

class SetTypingResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.messaging.SetTypingResponse) */ {
 public:
  inline SetTypingResponse() : SetTypingResponse(nullptr) {}
  ~SetTypingResponse() override;
  explicit PROTOBUF_CONSTEXPR SetTypingResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetTypingResponse(const SetTypingResponse& from);
  SetTypingResponse(SetTypingResponse&& from) noexcept
    : SetTypingResponse() {
    *this = ::std::move(from);
  }

  inline SetTypingResponse& operator=(const SetTypingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetTypingResponse& operator=(SetTypingResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetTypingResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetTypingResponse* internal_default_instance() {
    return reinterpret_cast<const SetTypingResponse*>(
               &_SetTypingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SetTypingResponse& a, SetTypingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetTypingResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetTypingResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetTypingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetTypingResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetTypingResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetTypingResponse& from) {
    SetTypingResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetTypingResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.messaging.SetTypingResponse";
  }
  protected:
  explicit SetTypingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .sonet.common.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::sonet::common::Status& status() const;
  PROTOBUF_NODISCARD ::sonet::common::Status* release_status();
  ::sonet::common::Status* mutable_status();
  void set_allocated_status(::sonet::common::Status* status);
  private:
  const ::sonet::common::Status& _internal_status() const;
  ::sonet::common::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::sonet::common::Status* status);
  ::sonet::common::Status* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:sonet.messaging.SetTypingResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sonet::common::Status* status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fmessaging_2eproto;
};
// -------------------------------------------------------------------

class WebSocketMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sonet.messaging.WebSocketMessage) */ {
 public:
  inline WebSocketMessage() : WebSocketMessage(nullptr) {}
  ~WebSocketMessage() override;
  explicit PROTOBUF_CONSTEXPR WebSocketMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WebSocketMessage(const WebSocketMessage& from);
  WebSocketMessage(WebSocketMessage&& from) noexcept
    : WebSocketMessage() {
    *this = ::std::move(from);
  }

  inline WebSocketMessage& operator=(const WebSocketMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline WebSocketMessage& operator=(WebSocketMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WebSocketMessage& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kNewMessage = 1,
    kTyping = 2,
    kReadReceipt = 3,
    kMessageStatusUpdate = 4,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const WebSocketMessage* internal_default_instance() {
    return reinterpret_cast<const WebSocketMessage*>(
               &_WebSocketMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(WebSocketMessage& a, WebSocketMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(WebSocketMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WebSocketMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WebSocketMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WebSocketMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WebSocketMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WebSocketMessage& from) {
    WebSocketMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WebSocketMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sonet.messaging.WebSocketMessage";
  }
  protected:
  explicit WebSocketMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewMessageFieldNumber = 1,
    kTypingFieldNumber = 2,
    kReadReceiptFieldNumber = 3,
    kMessageStatusUpdateFieldNumber = 4,
  };
  // .sonet.messaging.Message new_message = 1;
  bool has_new_message() const;
  private:
  bool _internal_has_new_message() const;
  public:
  void clear_new_message();
  const ::sonet::messaging::Message& new_message() const;
  PROTOBUF_NODISCARD ::sonet::messaging::Message* release_new_message();
  ::sonet::messaging::Message* mutable_new_message();
  void set_allocated_new_message(::sonet::messaging::Message* new_message);
  private:
  const ::sonet::messaging::Message& _internal_new_message() const;
  ::sonet::messaging::Message* _internal_mutable_new_message();
  public:
  void unsafe_arena_set_allocated_new_message(
      ::sonet::messaging::Message* new_message);
  ::sonet::messaging::Message* unsafe_arena_release_new_message();

  // .sonet.messaging.TypingIndicator typing = 2;
  bool has_typing() const;
  private:
  bool _internal_has_typing() const;
  public:
  void clear_typing();
  const ::sonet::messaging::TypingIndicator& typing() const;
  PROTOBUF_NODISCARD ::sonet::messaging::TypingIndicator* release_typing();
  ::sonet::messaging::TypingIndicator* mutable_typing();
  void set_allocated_typing(::sonet::messaging::TypingIndicator* typing);
  private:
  const ::sonet::messaging::TypingIndicator& _internal_typing() const;
  ::sonet::messaging::TypingIndicator* _internal_mutable_typing();
  public:
  void unsafe_arena_set_allocated_typing(
      ::sonet::messaging::TypingIndicator* typing);
  ::sonet::messaging::TypingIndicator* unsafe_arena_release_typing();

  // .sonet.messaging.ReadReceipt read_receipt = 3;
  bool has_read_receipt() const;
  private:
  bool _internal_has_read_receipt() const;
  public:
  void clear_read_receipt();
  const ::sonet::messaging::ReadReceipt& read_receipt() const;
  PROTOBUF_NODISCARD ::sonet::messaging::ReadReceipt* release_read_receipt();
  ::sonet::messaging::ReadReceipt* mutable_read_receipt();
  void set_allocated_read_receipt(::sonet::messaging::ReadReceipt* read_receipt);
  private:
  const ::sonet::messaging::ReadReceipt& _internal_read_receipt() const;
  ::sonet::messaging::ReadReceipt* _internal_mutable_read_receipt();
  public:
  void unsafe_arena_set_allocated_read_receipt(
      ::sonet::messaging::ReadReceipt* read_receipt);
  ::sonet::messaging::ReadReceipt* unsafe_arena_release_read_receipt();

  // .sonet.messaging.MessageStatus message_status_update = 4;
  bool has_message_status_update() const;
  private:
  bool _internal_has_message_status_update() const;
  public:
  void clear_message_status_update();
  ::sonet::messaging::MessageStatus message_status_update() const;
  void set_message_status_update(::sonet::messaging::MessageStatus value);
  private:
  ::sonet::messaging::MessageStatus _internal_message_status_update() const;
  void _internal_set_message_status_update(::sonet::messaging::MessageStatus value);
  public:

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:sonet.messaging.WebSocketMessage)
 private:
  class _Internal;
  void set_has_new_message();
  void set_has_typing();
  void set_has_read_receipt();
  void set_has_message_status_update();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::sonet::messaging::Message* new_message_;
      ::sonet::messaging::TypingIndicator* typing_;
      ::sonet::messaging::ReadReceipt* read_receipt_;
      int message_status_update_;
    } payload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_services_2fmessaging_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Message

// string message_id = 1;
inline void Message::clear_message_id() {
  _impl_.message_id_.ClearToEmpty();
}
inline const std::string& Message::message_id() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.Message.message_id)
  return _internal_message_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Message::set_message_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.messaging.Message.message_id)
}
inline std::string* Message::mutable_message_id() {
  std::string* _s = _internal_mutable_message_id();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.Message.message_id)
  return _s;
}
inline const std::string& Message::_internal_message_id() const {
  return _impl_.message_id_.Get();
}
inline void Message::_internal_set_message_id(const std::string& value) {
  
  _impl_.message_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Message::_internal_mutable_message_id() {
  
  return _impl_.message_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Message::release_message_id() {
  // @@protoc_insertion_point(field_release:sonet.messaging.Message.message_id)
  return _impl_.message_id_.Release();
}
inline void Message::set_allocated_message_id(std::string* message_id) {
  if (message_id != nullptr) {
    
  } else {
    
  }
  _impl_.message_id_.SetAllocated(message_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_id_.IsDefault()) {
    _impl_.message_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.Message.message_id)
}

// string chat_id = 2;
inline void Message::clear_chat_id() {
  _impl_.chat_id_.ClearToEmpty();
}
inline const std::string& Message::chat_id() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.Message.chat_id)
  return _internal_chat_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Message::set_chat_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.chat_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.messaging.Message.chat_id)
}
inline std::string* Message::mutable_chat_id() {
  std::string* _s = _internal_mutable_chat_id();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.Message.chat_id)
  return _s;
}
inline const std::string& Message::_internal_chat_id() const {
  return _impl_.chat_id_.Get();
}
inline void Message::_internal_set_chat_id(const std::string& value) {
  
  _impl_.chat_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Message::_internal_mutable_chat_id() {
  
  return _impl_.chat_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Message::release_chat_id() {
  // @@protoc_insertion_point(field_release:sonet.messaging.Message.chat_id)
  return _impl_.chat_id_.Release();
}
inline void Message::set_allocated_chat_id(std::string* chat_id) {
  if (chat_id != nullptr) {
    
  } else {
    
  }
  _impl_.chat_id_.SetAllocated(chat_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chat_id_.IsDefault()) {
    _impl_.chat_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.Message.chat_id)
}

// string sender_id = 3;
inline void Message::clear_sender_id() {
  _impl_.sender_id_.ClearToEmpty();
}
inline const std::string& Message::sender_id() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.Message.sender_id)
  return _internal_sender_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Message::set_sender_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sender_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.messaging.Message.sender_id)
}
inline std::string* Message::mutable_sender_id() {
  std::string* _s = _internal_mutable_sender_id();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.Message.sender_id)
  return _s;
}
inline const std::string& Message::_internal_sender_id() const {
  return _impl_.sender_id_.Get();
}
inline void Message::_internal_set_sender_id(const std::string& value) {
  
  _impl_.sender_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Message::_internal_mutable_sender_id() {
  
  return _impl_.sender_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Message::release_sender_id() {
  // @@protoc_insertion_point(field_release:sonet.messaging.Message.sender_id)
  return _impl_.sender_id_.Release();
}
inline void Message::set_allocated_sender_id(std::string* sender_id) {
  if (sender_id != nullptr) {
    
  } else {
    
  }
  _impl_.sender_id_.SetAllocated(sender_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sender_id_.IsDefault()) {
    _impl_.sender_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.Message.sender_id)
}

// string content = 4;
inline void Message::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& Message::content() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.Message.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Message::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.messaging.Message.content)
}
inline std::string* Message::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.Message.content)
  return _s;
}
inline const std::string& Message::_internal_content() const {
  return _impl_.content_.Get();
}
inline void Message::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* Message::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* Message::release_content() {
  // @@protoc_insertion_point(field_release:sonet.messaging.Message.content)
  return _impl_.content_.Release();
}
inline void Message::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.Message.content)
}

// .sonet.messaging.MessageType type = 5;
inline void Message::clear_type() {
  _impl_.type_ = 0;
}
inline ::sonet::messaging::MessageType Message::_internal_type() const {
  return static_cast< ::sonet::messaging::MessageType >(_impl_.type_);
}
inline ::sonet::messaging::MessageType Message::type() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.Message.type)
  return _internal_type();
}
inline void Message::_internal_set_type(::sonet::messaging::MessageType value) {
  
  _impl_.type_ = value;
}
inline void Message::set_type(::sonet::messaging::MessageType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sonet.messaging.Message.type)
}

// .sonet.messaging.MessageStatus status = 6;
inline void Message::clear_status() {
  _impl_.status_ = 0;
}
inline ::sonet::messaging::MessageStatus Message::_internal_status() const {
  return static_cast< ::sonet::messaging::MessageStatus >(_impl_.status_);
}
inline ::sonet::messaging::MessageStatus Message::status() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.Message.status)
  return _internal_status();
}
inline void Message::_internal_set_status(::sonet::messaging::MessageStatus value) {
  
  _impl_.status_ = value;
}
inline void Message::set_status(::sonet::messaging::MessageStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:sonet.messaging.Message.status)
}

// .sonet.messaging.EncryptionType encryption = 7;
inline void Message::clear_encryption() {
  _impl_.encryption_ = 0;
}
inline ::sonet::messaging::EncryptionType Message::_internal_encryption() const {
  return static_cast< ::sonet::messaging::EncryptionType >(_impl_.encryption_);
}
inline ::sonet::messaging::EncryptionType Message::encryption() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.Message.encryption)
  return _internal_encryption();
}
inline void Message::_internal_set_encryption(::sonet::messaging::EncryptionType value) {
  
  _impl_.encryption_ = value;
}
inline void Message::set_encryption(::sonet::messaging::EncryptionType value) {
  _internal_set_encryption(value);
  // @@protoc_insertion_point(field_set:sonet.messaging.Message.encryption)
}

// string encrypted_content = 8;
inline void Message::clear_encrypted_content() {
  _impl_.encrypted_content_.ClearToEmpty();
}
inline const std::string& Message::encrypted_content() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.Message.encrypted_content)
  return _internal_encrypted_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Message::set_encrypted_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.encrypted_content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.messaging.Message.encrypted_content)
}
inline std::string* Message::mutable_encrypted_content() {
  std::string* _s = _internal_mutable_encrypted_content();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.Message.encrypted_content)
  return _s;
}
inline const std::string& Message::_internal_encrypted_content() const {
  return _impl_.encrypted_content_.Get();
}
inline void Message::_internal_set_encrypted_content(const std::string& value) {
  
  _impl_.encrypted_content_.Set(value, GetArenaForAllocation());
}
inline std::string* Message::_internal_mutable_encrypted_content() {
  
  return _impl_.encrypted_content_.Mutable(GetArenaForAllocation());
}
inline std::string* Message::release_encrypted_content() {
  // @@protoc_insertion_point(field_release:sonet.messaging.Message.encrypted_content)
  return _impl_.encrypted_content_.Release();
}
inline void Message::set_allocated_encrypted_content(std::string* encrypted_content) {
  if (encrypted_content != nullptr) {
    
  } else {
    
  }
  _impl_.encrypted_content_.SetAllocated(encrypted_content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.encrypted_content_.IsDefault()) {
    _impl_.encrypted_content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.Message.encrypted_content)
}

// repeated string attachments = 9;
inline int Message::_internal_attachments_size() const {
  return _impl_.attachments_.size();
}
inline int Message::attachments_size() const {
  return _internal_attachments_size();
}
inline void Message::clear_attachments() {
  _impl_.attachments_.Clear();
}
inline std::string* Message::add_attachments() {
  std::string* _s = _internal_add_attachments();
  // @@protoc_insertion_point(field_add_mutable:sonet.messaging.Message.attachments)
  return _s;
}
inline const std::string& Message::_internal_attachments(int index) const {
  return _impl_.attachments_.Get(index);
}
inline const std::string& Message::attachments(int index) const {
  // @@protoc_insertion_point(field_get:sonet.messaging.Message.attachments)
  return _internal_attachments(index);
}
inline std::string* Message::mutable_attachments(int index) {
  // @@protoc_insertion_point(field_mutable:sonet.messaging.Message.attachments)
  return _impl_.attachments_.Mutable(index);
}
inline void Message::set_attachments(int index, const std::string& value) {
  _impl_.attachments_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sonet.messaging.Message.attachments)
}
inline void Message::set_attachments(int index, std::string&& value) {
  _impl_.attachments_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sonet.messaging.Message.attachments)
}
inline void Message::set_attachments(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.attachments_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sonet.messaging.Message.attachments)
}
inline void Message::set_attachments(int index, const char* value, size_t size) {
  _impl_.attachments_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sonet.messaging.Message.attachments)
}
inline std::string* Message::_internal_add_attachments() {
  return _impl_.attachments_.Add();
}
inline void Message::add_attachments(const std::string& value) {
  _impl_.attachments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sonet.messaging.Message.attachments)
}
inline void Message::add_attachments(std::string&& value) {
  _impl_.attachments_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sonet.messaging.Message.attachments)
}
inline void Message::add_attachments(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.attachments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sonet.messaging.Message.attachments)
}
inline void Message::add_attachments(const char* value, size_t size) {
  _impl_.attachments_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sonet.messaging.Message.attachments)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Message::attachments() const {
  // @@protoc_insertion_point(field_list:sonet.messaging.Message.attachments)
  return _impl_.attachments_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Message::mutable_attachments() {
  // @@protoc_insertion_point(field_mutable_list:sonet.messaging.Message.attachments)
  return &_impl_.attachments_;
}

// string reply_to_message_id = 10;
inline void Message::clear_reply_to_message_id() {
  _impl_.reply_to_message_id_.ClearToEmpty();
}
inline const std::string& Message::reply_to_message_id() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.Message.reply_to_message_id)
  return _internal_reply_to_message_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Message::set_reply_to_message_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.reply_to_message_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.messaging.Message.reply_to_message_id)
}
inline std::string* Message::mutable_reply_to_message_id() {
  std::string* _s = _internal_mutable_reply_to_message_id();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.Message.reply_to_message_id)
  return _s;
}
inline const std::string& Message::_internal_reply_to_message_id() const {
  return _impl_.reply_to_message_id_.Get();
}
inline void Message::_internal_set_reply_to_message_id(const std::string& value) {
  
  _impl_.reply_to_message_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Message::_internal_mutable_reply_to_message_id() {
  
  return _impl_.reply_to_message_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Message::release_reply_to_message_id() {
  // @@protoc_insertion_point(field_release:sonet.messaging.Message.reply_to_message_id)
  return _impl_.reply_to_message_id_.Release();
}
inline void Message::set_allocated_reply_to_message_id(std::string* reply_to_message_id) {
  if (reply_to_message_id != nullptr) {
    
  } else {
    
  }
  _impl_.reply_to_message_id_.SetAllocated(reply_to_message_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reply_to_message_id_.IsDefault()) {
    _impl_.reply_to_message_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.Message.reply_to_message_id)
}

// bool is_edited = 11;
inline void Message::clear_is_edited() {
  _impl_.is_edited_ = false;
}
inline bool Message::_internal_is_edited() const {
  return _impl_.is_edited_;
}
inline bool Message::is_edited() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.Message.is_edited)
  return _internal_is_edited();
}
inline void Message::_internal_set_is_edited(bool value) {
  
  _impl_.is_edited_ = value;
}
inline void Message::set_is_edited(bool value) {
  _internal_set_is_edited(value);
  // @@protoc_insertion_point(field_set:sonet.messaging.Message.is_edited)
}

// .sonet.common.Timestamp created_at = 12;
inline bool Message::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool Message::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::sonet::common::Timestamp& Message::_internal_created_at() const {
  const ::sonet::common::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Timestamp&>(
      ::sonet::common::_Timestamp_default_instance_);
}
inline const ::sonet::common::Timestamp& Message::created_at() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.Message.created_at)
  return _internal_created_at();
}
inline void Message::unsafe_arena_set_allocated_created_at(
    ::sonet::common::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.messaging.Message.created_at)
}
inline ::sonet::common::Timestamp* Message::release_created_at() {
  
  ::sonet::common::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Timestamp* Message::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:sonet.messaging.Message.created_at)
  
  ::sonet::common::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::sonet::common::Timestamp* Message::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::sonet::common::Timestamp* Message::mutable_created_at() {
  ::sonet::common::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.Message.created_at)
  return _msg;
}
inline void Message::set_allocated_created_at(::sonet::common::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.Message.created_at)
}

// .sonet.common.Timestamp updated_at = 13;
inline bool Message::_internal_has_updated_at() const {
  return this != internal_default_instance() && _impl_.updated_at_ != nullptr;
}
inline bool Message::has_updated_at() const {
  return _internal_has_updated_at();
}
inline const ::sonet::common::Timestamp& Message::_internal_updated_at() const {
  const ::sonet::common::Timestamp* p = _impl_.updated_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Timestamp&>(
      ::sonet::common::_Timestamp_default_instance_);
}
inline const ::sonet::common::Timestamp& Message::updated_at() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.Message.updated_at)
  return _internal_updated_at();
}
inline void Message::unsafe_arena_set_allocated_updated_at(
    ::sonet::common::Timestamp* updated_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.updated_at_);
  }
  _impl_.updated_at_ = updated_at;
  if (updated_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.messaging.Message.updated_at)
}
inline ::sonet::common::Timestamp* Message::release_updated_at() {
  
  ::sonet::common::Timestamp* temp = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Timestamp* Message::unsafe_arena_release_updated_at() {
  // @@protoc_insertion_point(field_release:sonet.messaging.Message.updated_at)
  
  ::sonet::common::Timestamp* temp = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
  return temp;
}
inline ::sonet::common::Timestamp* Message::_internal_mutable_updated_at() {
  
  if (_impl_.updated_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Timestamp>(GetArenaForAllocation());
    _impl_.updated_at_ = p;
  }
  return _impl_.updated_at_;
}
inline ::sonet::common::Timestamp* Message::mutable_updated_at() {
  ::sonet::common::Timestamp* _msg = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.Message.updated_at)
  return _msg;
}
inline void Message::set_allocated_updated_at(::sonet::common::Timestamp* updated_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.updated_at_);
  }
  if (updated_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at));
    if (message_arena != submessage_arena) {
      updated_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, updated_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.updated_at_ = updated_at;
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.Message.updated_at)
}

// .sonet.common.Timestamp delivered_at = 14;
inline bool Message::_internal_has_delivered_at() const {
  return this != internal_default_instance() && _impl_.delivered_at_ != nullptr;
}
inline bool Message::has_delivered_at() const {
  return _internal_has_delivered_at();
}
inline const ::sonet::common::Timestamp& Message::_internal_delivered_at() const {
  const ::sonet::common::Timestamp* p = _impl_.delivered_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Timestamp&>(
      ::sonet::common::_Timestamp_default_instance_);
}
inline const ::sonet::common::Timestamp& Message::delivered_at() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.Message.delivered_at)
  return _internal_delivered_at();
}
inline void Message::unsafe_arena_set_allocated_delivered_at(
    ::sonet::common::Timestamp* delivered_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.delivered_at_);
  }
  _impl_.delivered_at_ = delivered_at;
  if (delivered_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.messaging.Message.delivered_at)
}
inline ::sonet::common::Timestamp* Message::release_delivered_at() {
  
  ::sonet::common::Timestamp* temp = _impl_.delivered_at_;
  _impl_.delivered_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Timestamp* Message::unsafe_arena_release_delivered_at() {
  // @@protoc_insertion_point(field_release:sonet.messaging.Message.delivered_at)
  
  ::sonet::common::Timestamp* temp = _impl_.delivered_at_;
  _impl_.delivered_at_ = nullptr;
  return temp;
}
inline ::sonet::common::Timestamp* Message::_internal_mutable_delivered_at() {
  
  if (_impl_.delivered_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Timestamp>(GetArenaForAllocation());
    _impl_.delivered_at_ = p;
  }
  return _impl_.delivered_at_;
}
inline ::sonet::common::Timestamp* Message::mutable_delivered_at() {
  ::sonet::common::Timestamp* _msg = _internal_mutable_delivered_at();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.Message.delivered_at)
  return _msg;
}
inline void Message::set_allocated_delivered_at(::sonet::common::Timestamp* delivered_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.delivered_at_);
  }
  if (delivered_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(delivered_at));
    if (message_arena != submessage_arena) {
      delivered_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, delivered_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.delivered_at_ = delivered_at;
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.Message.delivered_at)
}

// .sonet.common.Timestamp read_at = 15;
inline bool Message::_internal_has_read_at() const {
  return this != internal_default_instance() && _impl_.read_at_ != nullptr;
}
inline bool Message::has_read_at() const {
  return _internal_has_read_at();
}
inline const ::sonet::common::Timestamp& Message::_internal_read_at() const {
  const ::sonet::common::Timestamp* p = _impl_.read_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Timestamp&>(
      ::sonet::common::_Timestamp_default_instance_);
}
inline const ::sonet::common::Timestamp& Message::read_at() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.Message.read_at)
  return _internal_read_at();
}
inline void Message::unsafe_arena_set_allocated_read_at(
    ::sonet::common::Timestamp* read_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.read_at_);
  }
  _impl_.read_at_ = read_at;
  if (read_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.messaging.Message.read_at)
}
inline ::sonet::common::Timestamp* Message::release_read_at() {
  
  ::sonet::common::Timestamp* temp = _impl_.read_at_;
  _impl_.read_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Timestamp* Message::unsafe_arena_release_read_at() {
  // @@protoc_insertion_point(field_release:sonet.messaging.Message.read_at)
  
  ::sonet::common::Timestamp* temp = _impl_.read_at_;
  _impl_.read_at_ = nullptr;
  return temp;
}
inline ::sonet::common::Timestamp* Message::_internal_mutable_read_at() {
  
  if (_impl_.read_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Timestamp>(GetArenaForAllocation());
    _impl_.read_at_ = p;
  }
  return _impl_.read_at_;
}
inline ::sonet::common::Timestamp* Message::mutable_read_at() {
  ::sonet::common::Timestamp* _msg = _internal_mutable_read_at();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.Message.read_at)
  return _msg;
}
inline void Message::set_allocated_read_at(::sonet::common::Timestamp* read_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.read_at_);
  }
  if (read_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(read_at));
    if (message_arena != submessage_arena) {
      read_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, read_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.read_at_ = read_at;
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.Message.read_at)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Chat

// string chat_id = 1;
inline void Chat::clear_chat_id() {
  _impl_.chat_id_.ClearToEmpty();
}
inline const std::string& Chat::chat_id() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.Chat.chat_id)
  return _internal_chat_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Chat::set_chat_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.chat_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.messaging.Chat.chat_id)
}
inline std::string* Chat::mutable_chat_id() {
  std::string* _s = _internal_mutable_chat_id();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.Chat.chat_id)
  return _s;
}
inline const std::string& Chat::_internal_chat_id() const {
  return _impl_.chat_id_.Get();
}
inline void Chat::_internal_set_chat_id(const std::string& value) {
  
  _impl_.chat_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Chat::_internal_mutable_chat_id() {
  
  return _impl_.chat_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Chat::release_chat_id() {
  // @@protoc_insertion_point(field_release:sonet.messaging.Chat.chat_id)
  return _impl_.chat_id_.Release();
}
inline void Chat::set_allocated_chat_id(std::string* chat_id) {
  if (chat_id != nullptr) {
    
  } else {
    
  }
  _impl_.chat_id_.SetAllocated(chat_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chat_id_.IsDefault()) {
    _impl_.chat_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.Chat.chat_id)
}

// string name = 2;
inline void Chat::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Chat::name() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.Chat.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Chat::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.messaging.Chat.name)
}
inline std::string* Chat::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.Chat.name)
  return _s;
}
inline const std::string& Chat::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Chat::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Chat::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Chat::release_name() {
  // @@protoc_insertion_point(field_release:sonet.messaging.Chat.name)
  return _impl_.name_.Release();
}
inline void Chat::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.Chat.name)
}

// string description = 3;
inline void Chat::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Chat::description() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.Chat.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Chat::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.messaging.Chat.description)
}
inline std::string* Chat::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.Chat.description)
  return _s;
}
inline const std::string& Chat::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Chat::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Chat::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Chat::release_description() {
  // @@protoc_insertion_point(field_release:sonet.messaging.Chat.description)
  return _impl_.description_.Release();
}
inline void Chat::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.Chat.description)
}

// .sonet.messaging.ChatType type = 4;
inline void Chat::clear_type() {
  _impl_.type_ = 0;
}
inline ::sonet::messaging::ChatType Chat::_internal_type() const {
  return static_cast< ::sonet::messaging::ChatType >(_impl_.type_);
}
inline ::sonet::messaging::ChatType Chat::type() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.Chat.type)
  return _internal_type();
}
inline void Chat::_internal_set_type(::sonet::messaging::ChatType value) {
  
  _impl_.type_ = value;
}
inline void Chat::set_type(::sonet::messaging::ChatType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sonet.messaging.Chat.type)
}

// string creator_id = 5;
inline void Chat::clear_creator_id() {
  _impl_.creator_id_.ClearToEmpty();
}
inline const std::string& Chat::creator_id() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.Chat.creator_id)
  return _internal_creator_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Chat::set_creator_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.creator_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.messaging.Chat.creator_id)
}
inline std::string* Chat::mutable_creator_id() {
  std::string* _s = _internal_mutable_creator_id();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.Chat.creator_id)
  return _s;
}
inline const std::string& Chat::_internal_creator_id() const {
  return _impl_.creator_id_.Get();
}
inline void Chat::_internal_set_creator_id(const std::string& value) {
  
  _impl_.creator_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Chat::_internal_mutable_creator_id() {
  
  return _impl_.creator_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Chat::release_creator_id() {
  // @@protoc_insertion_point(field_release:sonet.messaging.Chat.creator_id)
  return _impl_.creator_id_.Release();
}
inline void Chat::set_allocated_creator_id(std::string* creator_id) {
  if (creator_id != nullptr) {
    
  } else {
    
  }
  _impl_.creator_id_.SetAllocated(creator_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.creator_id_.IsDefault()) {
    _impl_.creator_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.Chat.creator_id)
}

// repeated string participant_ids = 6;
inline int Chat::_internal_participant_ids_size() const {
  return _impl_.participant_ids_.size();
}
inline int Chat::participant_ids_size() const {
  return _internal_participant_ids_size();
}
inline void Chat::clear_participant_ids() {
  _impl_.participant_ids_.Clear();
}
inline std::string* Chat::add_participant_ids() {
  std::string* _s = _internal_add_participant_ids();
  // @@protoc_insertion_point(field_add_mutable:sonet.messaging.Chat.participant_ids)
  return _s;
}
inline const std::string& Chat::_internal_participant_ids(int index) const {
  return _impl_.participant_ids_.Get(index);
}
inline const std::string& Chat::participant_ids(int index) const {
  // @@protoc_insertion_point(field_get:sonet.messaging.Chat.participant_ids)
  return _internal_participant_ids(index);
}
inline std::string* Chat::mutable_participant_ids(int index) {
  // @@protoc_insertion_point(field_mutable:sonet.messaging.Chat.participant_ids)
  return _impl_.participant_ids_.Mutable(index);
}
inline void Chat::set_participant_ids(int index, const std::string& value) {
  _impl_.participant_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sonet.messaging.Chat.participant_ids)
}
inline void Chat::set_participant_ids(int index, std::string&& value) {
  _impl_.participant_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sonet.messaging.Chat.participant_ids)
}
inline void Chat::set_participant_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.participant_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sonet.messaging.Chat.participant_ids)
}
inline void Chat::set_participant_ids(int index, const char* value, size_t size) {
  _impl_.participant_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sonet.messaging.Chat.participant_ids)
}
inline std::string* Chat::_internal_add_participant_ids() {
  return _impl_.participant_ids_.Add();
}
inline void Chat::add_participant_ids(const std::string& value) {
  _impl_.participant_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sonet.messaging.Chat.participant_ids)
}
inline void Chat::add_participant_ids(std::string&& value) {
  _impl_.participant_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sonet.messaging.Chat.participant_ids)
}
inline void Chat::add_participant_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.participant_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sonet.messaging.Chat.participant_ids)
}
inline void Chat::add_participant_ids(const char* value, size_t size) {
  _impl_.participant_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sonet.messaging.Chat.participant_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Chat::participant_ids() const {
  // @@protoc_insertion_point(field_list:sonet.messaging.Chat.participant_ids)
  return _impl_.participant_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Chat::mutable_participant_ids() {
  // @@protoc_insertion_point(field_mutable_list:sonet.messaging.Chat.participant_ids)
  return &_impl_.participant_ids_;
}

// string last_message_id = 7;
inline void Chat::clear_last_message_id() {
  _impl_.last_message_id_.ClearToEmpty();
}
inline const std::string& Chat::last_message_id() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.Chat.last_message_id)
  return _internal_last_message_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Chat::set_last_message_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.last_message_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.messaging.Chat.last_message_id)
}
inline std::string* Chat::mutable_last_message_id() {
  std::string* _s = _internal_mutable_last_message_id();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.Chat.last_message_id)
  return _s;
}
inline const std::string& Chat::_internal_last_message_id() const {
  return _impl_.last_message_id_.Get();
}
inline void Chat::_internal_set_last_message_id(const std::string& value) {
  
  _impl_.last_message_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Chat::_internal_mutable_last_message_id() {
  
  return _impl_.last_message_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Chat::release_last_message_id() {
  // @@protoc_insertion_point(field_release:sonet.messaging.Chat.last_message_id)
  return _impl_.last_message_id_.Release();
}
inline void Chat::set_allocated_last_message_id(std::string* last_message_id) {
  if (last_message_id != nullptr) {
    
  } else {
    
  }
  _impl_.last_message_id_.SetAllocated(last_message_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.last_message_id_.IsDefault()) {
    _impl_.last_message_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.Chat.last_message_id)
}

// .sonet.common.Timestamp last_activity = 8;
inline bool Chat::_internal_has_last_activity() const {
  return this != internal_default_instance() && _impl_.last_activity_ != nullptr;
}
inline bool Chat::has_last_activity() const {
  return _internal_has_last_activity();
}
inline const ::sonet::common::Timestamp& Chat::_internal_last_activity() const {
  const ::sonet::common::Timestamp* p = _impl_.last_activity_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Timestamp&>(
      ::sonet::common::_Timestamp_default_instance_);
}
inline const ::sonet::common::Timestamp& Chat::last_activity() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.Chat.last_activity)
  return _internal_last_activity();
}
inline void Chat::unsafe_arena_set_allocated_last_activity(
    ::sonet::common::Timestamp* last_activity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_activity_);
  }
  _impl_.last_activity_ = last_activity;
  if (last_activity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.messaging.Chat.last_activity)
}
inline ::sonet::common::Timestamp* Chat::release_last_activity() {
  
  ::sonet::common::Timestamp* temp = _impl_.last_activity_;
  _impl_.last_activity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Timestamp* Chat::unsafe_arena_release_last_activity() {
  // @@protoc_insertion_point(field_release:sonet.messaging.Chat.last_activity)
  
  ::sonet::common::Timestamp* temp = _impl_.last_activity_;
  _impl_.last_activity_ = nullptr;
  return temp;
}
inline ::sonet::common::Timestamp* Chat::_internal_mutable_last_activity() {
  
  if (_impl_.last_activity_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Timestamp>(GetArenaForAllocation());
    _impl_.last_activity_ = p;
  }
  return _impl_.last_activity_;
}
inline ::sonet::common::Timestamp* Chat::mutable_last_activity() {
  ::sonet::common::Timestamp* _msg = _internal_mutable_last_activity();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.Chat.last_activity)
  return _msg;
}
inline void Chat::set_allocated_last_activity(::sonet::common::Timestamp* last_activity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_activity_);
  }
  if (last_activity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_activity));
    if (message_arena != submessage_arena) {
      last_activity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_activity, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.last_activity_ = last_activity;
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.Chat.last_activity)
}

// bool is_archived = 9;
inline void Chat::clear_is_archived() {
  _impl_.is_archived_ = false;
}
inline bool Chat::_internal_is_archived() const {
  return _impl_.is_archived_;
}
inline bool Chat::is_archived() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.Chat.is_archived)
  return _internal_is_archived();
}
inline void Chat::_internal_set_is_archived(bool value) {
  
  _impl_.is_archived_ = value;
}
inline void Chat::set_is_archived(bool value) {
  _internal_set_is_archived(value);
  // @@protoc_insertion_point(field_set:sonet.messaging.Chat.is_archived)
}

// bool is_muted = 10;
inline void Chat::clear_is_muted() {
  _impl_.is_muted_ = false;
}
inline bool Chat::_internal_is_muted() const {
  return _impl_.is_muted_;
}
inline bool Chat::is_muted() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.Chat.is_muted)
  return _internal_is_muted();
}
inline void Chat::_internal_set_is_muted(bool value) {
  
  _impl_.is_muted_ = value;
}
inline void Chat::set_is_muted(bool value) {
  _internal_set_is_muted(value);
  // @@protoc_insertion_point(field_set:sonet.messaging.Chat.is_muted)
}

// string avatar_url = 11;
inline void Chat::clear_avatar_url() {
  _impl_.avatar_url_.ClearToEmpty();
}
inline const std::string& Chat::avatar_url() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.Chat.avatar_url)
  return _internal_avatar_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Chat::set_avatar_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.avatar_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.messaging.Chat.avatar_url)
}
inline std::string* Chat::mutable_avatar_url() {
  std::string* _s = _internal_mutable_avatar_url();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.Chat.avatar_url)
  return _s;
}
inline const std::string& Chat::_internal_avatar_url() const {
  return _impl_.avatar_url_.Get();
}
inline void Chat::_internal_set_avatar_url(const std::string& value) {
  
  _impl_.avatar_url_.Set(value, GetArenaForAllocation());
}
inline std::string* Chat::_internal_mutable_avatar_url() {
  
  return _impl_.avatar_url_.Mutable(GetArenaForAllocation());
}
inline std::string* Chat::release_avatar_url() {
  // @@protoc_insertion_point(field_release:sonet.messaging.Chat.avatar_url)
  return _impl_.avatar_url_.Release();
}
inline void Chat::set_allocated_avatar_url(std::string* avatar_url) {
  if (avatar_url != nullptr) {
    
  } else {
    
  }
  _impl_.avatar_url_.SetAllocated(avatar_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.avatar_url_.IsDefault()) {
    _impl_.avatar_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.Chat.avatar_url)
}

// map<string, string> settings = 12;
inline int Chat::_internal_settings_size() const {
  return _impl_.settings_.size();
}
inline int Chat::settings_size() const {
  return _internal_settings_size();
}
inline void Chat::clear_settings() {
  _impl_.settings_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Chat::_internal_settings() const {
  return _impl_.settings_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Chat::settings() const {
  // @@protoc_insertion_point(field_map:sonet.messaging.Chat.settings)
  return _internal_settings();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Chat::_internal_mutable_settings() {
  return _impl_.settings_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Chat::mutable_settings() {
  // @@protoc_insertion_point(field_mutable_map:sonet.messaging.Chat.settings)
  return _internal_mutable_settings();
}

// .sonet.common.Timestamp created_at = 13;
inline bool Chat::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool Chat::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::sonet::common::Timestamp& Chat::_internal_created_at() const {
  const ::sonet::common::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Timestamp&>(
      ::sonet::common::_Timestamp_default_instance_);
}
inline const ::sonet::common::Timestamp& Chat::created_at() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.Chat.created_at)
  return _internal_created_at();
}
inline void Chat::unsafe_arena_set_allocated_created_at(
    ::sonet::common::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.messaging.Chat.created_at)
}
inline ::sonet::common::Timestamp* Chat::release_created_at() {
  
  ::sonet::common::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Timestamp* Chat::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:sonet.messaging.Chat.created_at)
  
  ::sonet::common::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::sonet::common::Timestamp* Chat::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::sonet::common::Timestamp* Chat::mutable_created_at() {
  ::sonet::common::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.Chat.created_at)
  return _msg;
}
inline void Chat::set_allocated_created_at(::sonet::common::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.Chat.created_at)
}

// .sonet.common.Timestamp updated_at = 14;
inline bool Chat::_internal_has_updated_at() const {
  return this != internal_default_instance() && _impl_.updated_at_ != nullptr;
}
inline bool Chat::has_updated_at() const {
  return _internal_has_updated_at();
}
inline const ::sonet::common::Timestamp& Chat::_internal_updated_at() const {
  const ::sonet::common::Timestamp* p = _impl_.updated_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Timestamp&>(
      ::sonet::common::_Timestamp_default_instance_);
}
inline const ::sonet::common::Timestamp& Chat::updated_at() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.Chat.updated_at)
  return _internal_updated_at();
}
inline void Chat::unsafe_arena_set_allocated_updated_at(
    ::sonet::common::Timestamp* updated_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.updated_at_);
  }
  _impl_.updated_at_ = updated_at;
  if (updated_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.messaging.Chat.updated_at)
}
inline ::sonet::common::Timestamp* Chat::release_updated_at() {
  
  ::sonet::common::Timestamp* temp = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Timestamp* Chat::unsafe_arena_release_updated_at() {
  // @@protoc_insertion_point(field_release:sonet.messaging.Chat.updated_at)
  
  ::sonet::common::Timestamp* temp = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
  return temp;
}
inline ::sonet::common::Timestamp* Chat::_internal_mutable_updated_at() {
  
  if (_impl_.updated_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Timestamp>(GetArenaForAllocation());
    _impl_.updated_at_ = p;
  }
  return _impl_.updated_at_;
}
inline ::sonet::common::Timestamp* Chat::mutable_updated_at() {
  ::sonet::common::Timestamp* _msg = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.Chat.updated_at)
  return _msg;
}
inline void Chat::set_allocated_updated_at(::sonet::common::Timestamp* updated_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.updated_at_);
  }
  if (updated_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at));
    if (message_arena != submessage_arena) {
      updated_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, updated_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.updated_at_ = updated_at;
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.Chat.updated_at)
}

// -------------------------------------------------------------------

// TypingIndicator

// string chat_id = 1;
inline void TypingIndicator::clear_chat_id() {
  _impl_.chat_id_.ClearToEmpty();
}
inline const std::string& TypingIndicator::chat_id() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.TypingIndicator.chat_id)
  return _internal_chat_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TypingIndicator::set_chat_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.chat_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.messaging.TypingIndicator.chat_id)
}
inline std::string* TypingIndicator::mutable_chat_id() {
  std::string* _s = _internal_mutable_chat_id();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.TypingIndicator.chat_id)
  return _s;
}
inline const std::string& TypingIndicator::_internal_chat_id() const {
  return _impl_.chat_id_.Get();
}
inline void TypingIndicator::_internal_set_chat_id(const std::string& value) {
  
  _impl_.chat_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TypingIndicator::_internal_mutable_chat_id() {
  
  return _impl_.chat_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TypingIndicator::release_chat_id() {
  // @@protoc_insertion_point(field_release:sonet.messaging.TypingIndicator.chat_id)
  return _impl_.chat_id_.Release();
}
inline void TypingIndicator::set_allocated_chat_id(std::string* chat_id) {
  if (chat_id != nullptr) {
    
  } else {
    
  }
  _impl_.chat_id_.SetAllocated(chat_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chat_id_.IsDefault()) {
    _impl_.chat_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.TypingIndicator.chat_id)
}

// string user_id = 2;
inline void TypingIndicator::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& TypingIndicator::user_id() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.TypingIndicator.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TypingIndicator::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.messaging.TypingIndicator.user_id)
}
inline std::string* TypingIndicator::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.TypingIndicator.user_id)
  return _s;
}
inline const std::string& TypingIndicator::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void TypingIndicator::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TypingIndicator::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TypingIndicator::release_user_id() {
  // @@protoc_insertion_point(field_release:sonet.messaging.TypingIndicator.user_id)
  return _impl_.user_id_.Release();
}
inline void TypingIndicator::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.TypingIndicator.user_id)
}

// bool is_typing = 3;
inline void TypingIndicator::clear_is_typing() {
  _impl_.is_typing_ = false;
}
inline bool TypingIndicator::_internal_is_typing() const {
  return _impl_.is_typing_;
}
inline bool TypingIndicator::is_typing() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.TypingIndicator.is_typing)
  return _internal_is_typing();
}
inline void TypingIndicator::_internal_set_is_typing(bool value) {
  
  _impl_.is_typing_ = value;
}
inline void TypingIndicator::set_is_typing(bool value) {
  _internal_set_is_typing(value);
  // @@protoc_insertion_point(field_set:sonet.messaging.TypingIndicator.is_typing)
}

// .sonet.common.Timestamp timestamp = 4;
inline bool TypingIndicator::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool TypingIndicator::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::sonet::common::Timestamp& TypingIndicator::_internal_timestamp() const {
  const ::sonet::common::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Timestamp&>(
      ::sonet::common::_Timestamp_default_instance_);
}
inline const ::sonet::common::Timestamp& TypingIndicator::timestamp() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.TypingIndicator.timestamp)
  return _internal_timestamp();
}
inline void TypingIndicator::unsafe_arena_set_allocated_timestamp(
    ::sonet::common::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.messaging.TypingIndicator.timestamp)
}
inline ::sonet::common::Timestamp* TypingIndicator::release_timestamp() {
  
  ::sonet::common::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Timestamp* TypingIndicator::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:sonet.messaging.TypingIndicator.timestamp)
  
  ::sonet::common::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::sonet::common::Timestamp* TypingIndicator::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::sonet::common::Timestamp* TypingIndicator::mutable_timestamp() {
  ::sonet::common::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.TypingIndicator.timestamp)
  return _msg;
}
inline void TypingIndicator::set_allocated_timestamp(::sonet::common::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.TypingIndicator.timestamp)
}

// -------------------------------------------------------------------

// ReadReceipt

// string message_id = 1;
inline void ReadReceipt::clear_message_id() {
  _impl_.message_id_.ClearToEmpty();
}
inline const std::string& ReadReceipt::message_id() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.ReadReceipt.message_id)
  return _internal_message_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadReceipt::set_message_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.messaging.ReadReceipt.message_id)
}
inline std::string* ReadReceipt::mutable_message_id() {
  std::string* _s = _internal_mutable_message_id();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.ReadReceipt.message_id)
  return _s;
}
inline const std::string& ReadReceipt::_internal_message_id() const {
  return _impl_.message_id_.Get();
}
inline void ReadReceipt::_internal_set_message_id(const std::string& value) {
  
  _impl_.message_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadReceipt::_internal_mutable_message_id() {
  
  return _impl_.message_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadReceipt::release_message_id() {
  // @@protoc_insertion_point(field_release:sonet.messaging.ReadReceipt.message_id)
  return _impl_.message_id_.Release();
}
inline void ReadReceipt::set_allocated_message_id(std::string* message_id) {
  if (message_id != nullptr) {
    
  } else {
    
  }
  _impl_.message_id_.SetAllocated(message_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_id_.IsDefault()) {
    _impl_.message_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.ReadReceipt.message_id)
}

// string user_id = 2;
inline void ReadReceipt::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& ReadReceipt::user_id() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.ReadReceipt.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadReceipt::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.messaging.ReadReceipt.user_id)
}
inline std::string* ReadReceipt::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.ReadReceipt.user_id)
  return _s;
}
inline const std::string& ReadReceipt::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void ReadReceipt::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadReceipt::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadReceipt::release_user_id() {
  // @@protoc_insertion_point(field_release:sonet.messaging.ReadReceipt.user_id)
  return _impl_.user_id_.Release();
}
inline void ReadReceipt::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.ReadReceipt.user_id)
}

// .sonet.common.Timestamp read_at = 3;
inline bool ReadReceipt::_internal_has_read_at() const {
  return this != internal_default_instance() && _impl_.read_at_ != nullptr;
}
inline bool ReadReceipt::has_read_at() const {
  return _internal_has_read_at();
}
inline const ::sonet::common::Timestamp& ReadReceipt::_internal_read_at() const {
  const ::sonet::common::Timestamp* p = _impl_.read_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Timestamp&>(
      ::sonet::common::_Timestamp_default_instance_);
}
inline const ::sonet::common::Timestamp& ReadReceipt::read_at() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.ReadReceipt.read_at)
  return _internal_read_at();
}
inline void ReadReceipt::unsafe_arena_set_allocated_read_at(
    ::sonet::common::Timestamp* read_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.read_at_);
  }
  _impl_.read_at_ = read_at;
  if (read_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.messaging.ReadReceipt.read_at)
}
inline ::sonet::common::Timestamp* ReadReceipt::release_read_at() {
  
  ::sonet::common::Timestamp* temp = _impl_.read_at_;
  _impl_.read_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Timestamp* ReadReceipt::unsafe_arena_release_read_at() {
  // @@protoc_insertion_point(field_release:sonet.messaging.ReadReceipt.read_at)
  
  ::sonet::common::Timestamp* temp = _impl_.read_at_;
  _impl_.read_at_ = nullptr;
  return temp;
}
inline ::sonet::common::Timestamp* ReadReceipt::_internal_mutable_read_at() {
  
  if (_impl_.read_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Timestamp>(GetArenaForAllocation());
    _impl_.read_at_ = p;
  }
  return _impl_.read_at_;
}
inline ::sonet::common::Timestamp* ReadReceipt::mutable_read_at() {
  ::sonet::common::Timestamp* _msg = _internal_mutable_read_at();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.ReadReceipt.read_at)
  return _msg;
}
inline void ReadReceipt::set_allocated_read_at(::sonet::common::Timestamp* read_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.read_at_);
  }
  if (read_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(read_at));
    if (message_arena != submessage_arena) {
      read_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, read_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.read_at_ = read_at;
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.ReadReceipt.read_at)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Attachment

// string attachment_id = 1;
inline void Attachment::clear_attachment_id() {
  _impl_.attachment_id_.ClearToEmpty();
}
inline const std::string& Attachment::attachment_id() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.Attachment.attachment_id)
  return _internal_attachment_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Attachment::set_attachment_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.attachment_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.messaging.Attachment.attachment_id)
}
inline std::string* Attachment::mutable_attachment_id() {
  std::string* _s = _internal_mutable_attachment_id();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.Attachment.attachment_id)
  return _s;
}
inline const std::string& Attachment::_internal_attachment_id() const {
  return _impl_.attachment_id_.Get();
}
inline void Attachment::_internal_set_attachment_id(const std::string& value) {
  
  _impl_.attachment_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Attachment::_internal_mutable_attachment_id() {
  
  return _impl_.attachment_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Attachment::release_attachment_id() {
  // @@protoc_insertion_point(field_release:sonet.messaging.Attachment.attachment_id)
  return _impl_.attachment_id_.Release();
}
inline void Attachment::set_allocated_attachment_id(std::string* attachment_id) {
  if (attachment_id != nullptr) {
    
  } else {
    
  }
  _impl_.attachment_id_.SetAllocated(attachment_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attachment_id_.IsDefault()) {
    _impl_.attachment_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.Attachment.attachment_id)
}

// string filename = 2;
inline void Attachment::clear_filename() {
  _impl_.filename_.ClearToEmpty();
}
inline const std::string& Attachment::filename() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.Attachment.filename)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Attachment::set_filename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.messaging.Attachment.filename)
}
inline std::string* Attachment::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.Attachment.filename)
  return _s;
}
inline const std::string& Attachment::_internal_filename() const {
  return _impl_.filename_.Get();
}
inline void Attachment::_internal_set_filename(const std::string& value) {
  
  _impl_.filename_.Set(value, GetArenaForAllocation());
}
inline std::string* Attachment::_internal_mutable_filename() {
  
  return _impl_.filename_.Mutable(GetArenaForAllocation());
}
inline std::string* Attachment::release_filename() {
  // @@protoc_insertion_point(field_release:sonet.messaging.Attachment.filename)
  return _impl_.filename_.Release();
}
inline void Attachment::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    
  } else {
    
  }
  _impl_.filename_.SetAllocated(filename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.Attachment.filename)
}

// string content_type = 3;
inline void Attachment::clear_content_type() {
  _impl_.content_type_.ClearToEmpty();
}
inline const std::string& Attachment::content_type() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.Attachment.content_type)
  return _internal_content_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Attachment::set_content_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.messaging.Attachment.content_type)
}
inline std::string* Attachment::mutable_content_type() {
  std::string* _s = _internal_mutable_content_type();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.Attachment.content_type)
  return _s;
}
inline const std::string& Attachment::_internal_content_type() const {
  return _impl_.content_type_.Get();
}
inline void Attachment::_internal_set_content_type(const std::string& value) {
  
  _impl_.content_type_.Set(value, GetArenaForAllocation());
}
inline std::string* Attachment::_internal_mutable_content_type() {
  
  return _impl_.content_type_.Mutable(GetArenaForAllocation());
}
inline std::string* Attachment::release_content_type() {
  // @@protoc_insertion_point(field_release:sonet.messaging.Attachment.content_type)
  return _impl_.content_type_.Release();
}
inline void Attachment::set_allocated_content_type(std::string* content_type) {
  if (content_type != nullptr) {
    
  } else {
    
  }
  _impl_.content_type_.SetAllocated(content_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_type_.IsDefault()) {
    _impl_.content_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.Attachment.content_type)
}

// int64 size = 4;
inline void Attachment::clear_size() {
  _impl_.size_ = int64_t{0};
}
inline int64_t Attachment::_internal_size() const {
  return _impl_.size_;
}
inline int64_t Attachment::size() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.Attachment.size)
  return _internal_size();
}
inline void Attachment::_internal_set_size(int64_t value) {
  
  _impl_.size_ = value;
}
inline void Attachment::set_size(int64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:sonet.messaging.Attachment.size)
}

// string url = 5;
inline void Attachment::clear_url() {
  _impl_.url_.ClearToEmpty();
}
inline const std::string& Attachment::url() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.Attachment.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Attachment::set_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.messaging.Attachment.url)
}
inline std::string* Attachment::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.Attachment.url)
  return _s;
}
inline const std::string& Attachment::_internal_url() const {
  return _impl_.url_.Get();
}
inline void Attachment::_internal_set_url(const std::string& value) {
  
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* Attachment::_internal_mutable_url() {
  
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* Attachment::release_url() {
  // @@protoc_insertion_point(field_release:sonet.messaging.Attachment.url)
  return _impl_.url_.Release();
}
inline void Attachment::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.Attachment.url)
}

// string thumbnail_url = 6;
inline void Attachment::clear_thumbnail_url() {
  _impl_.thumbnail_url_.ClearToEmpty();
}
inline const std::string& Attachment::thumbnail_url() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.Attachment.thumbnail_url)
  return _internal_thumbnail_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Attachment::set_thumbnail_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.thumbnail_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.messaging.Attachment.thumbnail_url)
}
inline std::string* Attachment::mutable_thumbnail_url() {
  std::string* _s = _internal_mutable_thumbnail_url();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.Attachment.thumbnail_url)
  return _s;
}
inline const std::string& Attachment::_internal_thumbnail_url() const {
  return _impl_.thumbnail_url_.Get();
}
inline void Attachment::_internal_set_thumbnail_url(const std::string& value) {
  
  _impl_.thumbnail_url_.Set(value, GetArenaForAllocation());
}
inline std::string* Attachment::_internal_mutable_thumbnail_url() {
  
  return _impl_.thumbnail_url_.Mutable(GetArenaForAllocation());
}
inline std::string* Attachment::release_thumbnail_url() {
  // @@protoc_insertion_point(field_release:sonet.messaging.Attachment.thumbnail_url)
  return _impl_.thumbnail_url_.Release();
}
inline void Attachment::set_allocated_thumbnail_url(std::string* thumbnail_url) {
  if (thumbnail_url != nullptr) {
    
  } else {
    
  }
  _impl_.thumbnail_url_.SetAllocated(thumbnail_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thumbnail_url_.IsDefault()) {
    _impl_.thumbnail_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.Attachment.thumbnail_url)
}

// map<string, string> metadata = 7;
inline int Attachment::_internal_metadata_size() const {
  return _impl_.metadata_.size();
}
inline int Attachment::metadata_size() const {
  return _internal_metadata_size();
}
inline void Attachment::clear_metadata() {
  _impl_.metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Attachment::_internal_metadata() const {
  return _impl_.metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Attachment::metadata() const {
  // @@protoc_insertion_point(field_map:sonet.messaging.Attachment.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Attachment::_internal_mutable_metadata() {
  return _impl_.metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Attachment::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:sonet.messaging.Attachment.metadata)
  return _internal_mutable_metadata();
}

// -------------------------------------------------------------------

// SendMessageRequest

// string chat_id = 1;
inline void SendMessageRequest::clear_chat_id() {
  _impl_.chat_id_.ClearToEmpty();
}
inline const std::string& SendMessageRequest::chat_id() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.SendMessageRequest.chat_id)
  return _internal_chat_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendMessageRequest::set_chat_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.chat_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.messaging.SendMessageRequest.chat_id)
}
inline std::string* SendMessageRequest::mutable_chat_id() {
  std::string* _s = _internal_mutable_chat_id();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.SendMessageRequest.chat_id)
  return _s;
}
inline const std::string& SendMessageRequest::_internal_chat_id() const {
  return _impl_.chat_id_.Get();
}
inline void SendMessageRequest::_internal_set_chat_id(const std::string& value) {
  
  _impl_.chat_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SendMessageRequest::_internal_mutable_chat_id() {
  
  return _impl_.chat_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SendMessageRequest::release_chat_id() {
  // @@protoc_insertion_point(field_release:sonet.messaging.SendMessageRequest.chat_id)
  return _impl_.chat_id_.Release();
}
inline void SendMessageRequest::set_allocated_chat_id(std::string* chat_id) {
  if (chat_id != nullptr) {
    
  } else {
    
  }
  _impl_.chat_id_.SetAllocated(chat_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chat_id_.IsDefault()) {
    _impl_.chat_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.SendMessageRequest.chat_id)
}

// string content = 2;
inline void SendMessageRequest::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& SendMessageRequest::content() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.SendMessageRequest.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendMessageRequest::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.messaging.SendMessageRequest.content)
}
inline std::string* SendMessageRequest::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.SendMessageRequest.content)
  return _s;
}
inline const std::string& SendMessageRequest::_internal_content() const {
  return _impl_.content_.Get();
}
inline void SendMessageRequest::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* SendMessageRequest::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* SendMessageRequest::release_content() {
  // @@protoc_insertion_point(field_release:sonet.messaging.SendMessageRequest.content)
  return _impl_.content_.Release();
}
inline void SendMessageRequest::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.SendMessageRequest.content)
}

// .sonet.messaging.MessageType type = 3;
inline void SendMessageRequest::clear_type() {
  _impl_.type_ = 0;
}
inline ::sonet::messaging::MessageType SendMessageRequest::_internal_type() const {
  return static_cast< ::sonet::messaging::MessageType >(_impl_.type_);
}
inline ::sonet::messaging::MessageType SendMessageRequest::type() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.SendMessageRequest.type)
  return _internal_type();
}
inline void SendMessageRequest::_internal_set_type(::sonet::messaging::MessageType value) {
  
  _impl_.type_ = value;
}
inline void SendMessageRequest::set_type(::sonet::messaging::MessageType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sonet.messaging.SendMessageRequest.type)
}

// repeated string attachment_ids = 4;
inline int SendMessageRequest::_internal_attachment_ids_size() const {
  return _impl_.attachment_ids_.size();
}
inline int SendMessageRequest::attachment_ids_size() const {
  return _internal_attachment_ids_size();
}
inline void SendMessageRequest::clear_attachment_ids() {
  _impl_.attachment_ids_.Clear();
}
inline std::string* SendMessageRequest::add_attachment_ids() {
  std::string* _s = _internal_add_attachment_ids();
  // @@protoc_insertion_point(field_add_mutable:sonet.messaging.SendMessageRequest.attachment_ids)
  return _s;
}
inline const std::string& SendMessageRequest::_internal_attachment_ids(int index) const {
  return _impl_.attachment_ids_.Get(index);
}
inline const std::string& SendMessageRequest::attachment_ids(int index) const {
  // @@protoc_insertion_point(field_get:sonet.messaging.SendMessageRequest.attachment_ids)
  return _internal_attachment_ids(index);
}
inline std::string* SendMessageRequest::mutable_attachment_ids(int index) {
  // @@protoc_insertion_point(field_mutable:sonet.messaging.SendMessageRequest.attachment_ids)
  return _impl_.attachment_ids_.Mutable(index);
}
inline void SendMessageRequest::set_attachment_ids(int index, const std::string& value) {
  _impl_.attachment_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sonet.messaging.SendMessageRequest.attachment_ids)
}
inline void SendMessageRequest::set_attachment_ids(int index, std::string&& value) {
  _impl_.attachment_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sonet.messaging.SendMessageRequest.attachment_ids)
}
inline void SendMessageRequest::set_attachment_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.attachment_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sonet.messaging.SendMessageRequest.attachment_ids)
}
inline void SendMessageRequest::set_attachment_ids(int index, const char* value, size_t size) {
  _impl_.attachment_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sonet.messaging.SendMessageRequest.attachment_ids)
}
inline std::string* SendMessageRequest::_internal_add_attachment_ids() {
  return _impl_.attachment_ids_.Add();
}
inline void SendMessageRequest::add_attachment_ids(const std::string& value) {
  _impl_.attachment_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sonet.messaging.SendMessageRequest.attachment_ids)
}
inline void SendMessageRequest::add_attachment_ids(std::string&& value) {
  _impl_.attachment_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sonet.messaging.SendMessageRequest.attachment_ids)
}
inline void SendMessageRequest::add_attachment_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.attachment_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sonet.messaging.SendMessageRequest.attachment_ids)
}
inline void SendMessageRequest::add_attachment_ids(const char* value, size_t size) {
  _impl_.attachment_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sonet.messaging.SendMessageRequest.attachment_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SendMessageRequest::attachment_ids() const {
  // @@protoc_insertion_point(field_list:sonet.messaging.SendMessageRequest.attachment_ids)
  return _impl_.attachment_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SendMessageRequest::mutable_attachment_ids() {
  // @@protoc_insertion_point(field_mutable_list:sonet.messaging.SendMessageRequest.attachment_ids)
  return &_impl_.attachment_ids_;
}

// string reply_to_message_id = 5;
inline void SendMessageRequest::clear_reply_to_message_id() {
  _impl_.reply_to_message_id_.ClearToEmpty();
}
inline const std::string& SendMessageRequest::reply_to_message_id() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.SendMessageRequest.reply_to_message_id)
  return _internal_reply_to_message_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendMessageRequest::set_reply_to_message_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.reply_to_message_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.messaging.SendMessageRequest.reply_to_message_id)
}
inline std::string* SendMessageRequest::mutable_reply_to_message_id() {
  std::string* _s = _internal_mutable_reply_to_message_id();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.SendMessageRequest.reply_to_message_id)
  return _s;
}
inline const std::string& SendMessageRequest::_internal_reply_to_message_id() const {
  return _impl_.reply_to_message_id_.Get();
}
inline void SendMessageRequest::_internal_set_reply_to_message_id(const std::string& value) {
  
  _impl_.reply_to_message_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SendMessageRequest::_internal_mutable_reply_to_message_id() {
  
  return _impl_.reply_to_message_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SendMessageRequest::release_reply_to_message_id() {
  // @@protoc_insertion_point(field_release:sonet.messaging.SendMessageRequest.reply_to_message_id)
  return _impl_.reply_to_message_id_.Release();
}
inline void SendMessageRequest::set_allocated_reply_to_message_id(std::string* reply_to_message_id) {
  if (reply_to_message_id != nullptr) {
    
  } else {
    
  }
  _impl_.reply_to_message_id_.SetAllocated(reply_to_message_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reply_to_message_id_.IsDefault()) {
    _impl_.reply_to_message_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.SendMessageRequest.reply_to_message_id)
}

// .sonet.messaging.EncryptionType encryption = 6;
inline void SendMessageRequest::clear_encryption() {
  _impl_.encryption_ = 0;
}
inline ::sonet::messaging::EncryptionType SendMessageRequest::_internal_encryption() const {
  return static_cast< ::sonet::messaging::EncryptionType >(_impl_.encryption_);
}
inline ::sonet::messaging::EncryptionType SendMessageRequest::encryption() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.SendMessageRequest.encryption)
  return _internal_encryption();
}
inline void SendMessageRequest::_internal_set_encryption(::sonet::messaging::EncryptionType value) {
  
  _impl_.encryption_ = value;
}
inline void SendMessageRequest::set_encryption(::sonet::messaging::EncryptionType value) {
  _internal_set_encryption(value);
  // @@protoc_insertion_point(field_set:sonet.messaging.SendMessageRequest.encryption)
}

// -------------------------------------------------------------------

// SendMessageResponse

// .sonet.common.Status status = 1;
inline bool SendMessageResponse::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool SendMessageResponse::has_status() const {
  return _internal_has_status();
}
inline const ::sonet::common::Status& SendMessageResponse::_internal_status() const {
  const ::sonet::common::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Status&>(
      ::sonet::common::_Status_default_instance_);
}
inline const ::sonet::common::Status& SendMessageResponse::status() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.SendMessageResponse.status)
  return _internal_status();
}
inline void SendMessageResponse::unsafe_arena_set_allocated_status(
    ::sonet::common::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.messaging.SendMessageResponse.status)
}
inline ::sonet::common::Status* SendMessageResponse::release_status() {
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Status* SendMessageResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:sonet.messaging.SendMessageResponse.status)
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::sonet::common::Status* SendMessageResponse::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::sonet::common::Status* SendMessageResponse::mutable_status() {
  ::sonet::common::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.SendMessageResponse.status)
  return _msg;
}
inline void SendMessageResponse::set_allocated_status(::sonet::common::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.SendMessageResponse.status)
}

// .sonet.messaging.Message message = 2;
inline bool SendMessageResponse::_internal_has_message() const {
  return this != internal_default_instance() && _impl_.message_ != nullptr;
}
inline bool SendMessageResponse::has_message() const {
  return _internal_has_message();
}
inline void SendMessageResponse::clear_message() {
  if (GetArenaForAllocation() == nullptr && _impl_.message_ != nullptr) {
    delete _impl_.message_;
  }
  _impl_.message_ = nullptr;
}
inline const ::sonet::messaging::Message& SendMessageResponse::_internal_message() const {
  const ::sonet::messaging::Message* p = _impl_.message_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::messaging::Message&>(
      ::sonet::messaging::_Message_default_instance_);
}
inline const ::sonet::messaging::Message& SendMessageResponse::message() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.SendMessageResponse.message)
  return _internal_message();
}
inline void SendMessageResponse::unsafe_arena_set_allocated_message(
    ::sonet::messaging::Message* message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.message_);
  }
  _impl_.message_ = message;
  if (message) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.messaging.SendMessageResponse.message)
}
inline ::sonet::messaging::Message* SendMessageResponse::release_message() {
  
  ::sonet::messaging::Message* temp = _impl_.message_;
  _impl_.message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::messaging::Message* SendMessageResponse::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_release:sonet.messaging.SendMessageResponse.message)
  
  ::sonet::messaging::Message* temp = _impl_.message_;
  _impl_.message_ = nullptr;
  return temp;
}
inline ::sonet::messaging::Message* SendMessageResponse::_internal_mutable_message() {
  
  if (_impl_.message_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::messaging::Message>(GetArenaForAllocation());
    _impl_.message_ = p;
  }
  return _impl_.message_;
}
inline ::sonet::messaging::Message* SendMessageResponse::mutable_message() {
  ::sonet::messaging::Message* _msg = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.SendMessageResponse.message)
  return _msg;
}
inline void SendMessageResponse::set_allocated_message(::sonet::messaging::Message* message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.message_;
  }
  if (message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(message);
    if (message_arena != submessage_arena) {
      message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, message, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.message_ = message;
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.SendMessageResponse.message)
}

// -------------------------------------------------------------------

// GetMessagesRequest

// string chat_id = 1;
inline void GetMessagesRequest::clear_chat_id() {
  _impl_.chat_id_.ClearToEmpty();
}
inline const std::string& GetMessagesRequest::chat_id() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.GetMessagesRequest.chat_id)
  return _internal_chat_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetMessagesRequest::set_chat_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.chat_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.messaging.GetMessagesRequest.chat_id)
}
inline std::string* GetMessagesRequest::mutable_chat_id() {
  std::string* _s = _internal_mutable_chat_id();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.GetMessagesRequest.chat_id)
  return _s;
}
inline const std::string& GetMessagesRequest::_internal_chat_id() const {
  return _impl_.chat_id_.Get();
}
inline void GetMessagesRequest::_internal_set_chat_id(const std::string& value) {
  
  _impl_.chat_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetMessagesRequest::_internal_mutable_chat_id() {
  
  return _impl_.chat_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetMessagesRequest::release_chat_id() {
  // @@protoc_insertion_point(field_release:sonet.messaging.GetMessagesRequest.chat_id)
  return _impl_.chat_id_.Release();
}
inline void GetMessagesRequest::set_allocated_chat_id(std::string* chat_id) {
  if (chat_id != nullptr) {
    
  } else {
    
  }
  _impl_.chat_id_.SetAllocated(chat_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chat_id_.IsDefault()) {
    _impl_.chat_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.GetMessagesRequest.chat_id)
}

// .sonet.common.PaginationRequest pagination = 2;
inline bool GetMessagesRequest::_internal_has_pagination() const {
  return this != internal_default_instance() && _impl_.pagination_ != nullptr;
}
inline bool GetMessagesRequest::has_pagination() const {
  return _internal_has_pagination();
}
inline const ::sonet::common::PaginationRequest& GetMessagesRequest::_internal_pagination() const {
  const ::sonet::common::PaginationRequest* p = _impl_.pagination_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::PaginationRequest&>(
      ::sonet::common::_PaginationRequest_default_instance_);
}
inline const ::sonet::common::PaginationRequest& GetMessagesRequest::pagination() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.GetMessagesRequest.pagination)
  return _internal_pagination();
}
inline void GetMessagesRequest::unsafe_arena_set_allocated_pagination(
    ::sonet::common::PaginationRequest* pagination) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  _impl_.pagination_ = pagination;
  if (pagination) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.messaging.GetMessagesRequest.pagination)
}
inline ::sonet::common::PaginationRequest* GetMessagesRequest::release_pagination() {
  
  ::sonet::common::PaginationRequest* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::PaginationRequest* GetMessagesRequest::unsafe_arena_release_pagination() {
  // @@protoc_insertion_point(field_release:sonet.messaging.GetMessagesRequest.pagination)
  
  ::sonet::common::PaginationRequest* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
  return temp;
}
inline ::sonet::common::PaginationRequest* GetMessagesRequest::_internal_mutable_pagination() {
  
  if (_impl_.pagination_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::PaginationRequest>(GetArenaForAllocation());
    _impl_.pagination_ = p;
  }
  return _impl_.pagination_;
}
inline ::sonet::common::PaginationRequest* GetMessagesRequest::mutable_pagination() {
  ::sonet::common::PaginationRequest* _msg = _internal_mutable_pagination();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.GetMessagesRequest.pagination)
  return _msg;
}
inline void GetMessagesRequest::set_allocated_pagination(::sonet::common::PaginationRequest* pagination) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  if (pagination) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pagination));
    if (message_arena != submessage_arena) {
      pagination = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pagination, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pagination_ = pagination;
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.GetMessagesRequest.pagination)
}

// .sonet.common.Timestamp before = 3;
inline bool GetMessagesRequest::_internal_has_before() const {
  return this != internal_default_instance() && _impl_.before_ != nullptr;
}
inline bool GetMessagesRequest::has_before() const {
  return _internal_has_before();
}
inline const ::sonet::common::Timestamp& GetMessagesRequest::_internal_before() const {
  const ::sonet::common::Timestamp* p = _impl_.before_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Timestamp&>(
      ::sonet::common::_Timestamp_default_instance_);
}
inline const ::sonet::common::Timestamp& GetMessagesRequest::before() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.GetMessagesRequest.before)
  return _internal_before();
}
inline void GetMessagesRequest::unsafe_arena_set_allocated_before(
    ::sonet::common::Timestamp* before) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.before_);
  }
  _impl_.before_ = before;
  if (before) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.messaging.GetMessagesRequest.before)
}
inline ::sonet::common::Timestamp* GetMessagesRequest::release_before() {
  
  ::sonet::common::Timestamp* temp = _impl_.before_;
  _impl_.before_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Timestamp* GetMessagesRequest::unsafe_arena_release_before() {
  // @@protoc_insertion_point(field_release:sonet.messaging.GetMessagesRequest.before)
  
  ::sonet::common::Timestamp* temp = _impl_.before_;
  _impl_.before_ = nullptr;
  return temp;
}
inline ::sonet::common::Timestamp* GetMessagesRequest::_internal_mutable_before() {
  
  if (_impl_.before_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Timestamp>(GetArenaForAllocation());
    _impl_.before_ = p;
  }
  return _impl_.before_;
}
inline ::sonet::common::Timestamp* GetMessagesRequest::mutable_before() {
  ::sonet::common::Timestamp* _msg = _internal_mutable_before();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.GetMessagesRequest.before)
  return _msg;
}
inline void GetMessagesRequest::set_allocated_before(::sonet::common::Timestamp* before) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.before_);
  }
  if (before) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(before));
    if (message_arena != submessage_arena) {
      before = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, before, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.before_ = before;
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.GetMessagesRequest.before)
}

// .sonet.common.Timestamp after = 4;
inline bool GetMessagesRequest::_internal_has_after() const {
  return this != internal_default_instance() && _impl_.after_ != nullptr;
}
inline bool GetMessagesRequest::has_after() const {
  return _internal_has_after();
}
inline const ::sonet::common::Timestamp& GetMessagesRequest::_internal_after() const {
  const ::sonet::common::Timestamp* p = _impl_.after_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Timestamp&>(
      ::sonet::common::_Timestamp_default_instance_);
}
inline const ::sonet::common::Timestamp& GetMessagesRequest::after() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.GetMessagesRequest.after)
  return _internal_after();
}
inline void GetMessagesRequest::unsafe_arena_set_allocated_after(
    ::sonet::common::Timestamp* after) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.after_);
  }
  _impl_.after_ = after;
  if (after) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.messaging.GetMessagesRequest.after)
}
inline ::sonet::common::Timestamp* GetMessagesRequest::release_after() {
  
  ::sonet::common::Timestamp* temp = _impl_.after_;
  _impl_.after_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Timestamp* GetMessagesRequest::unsafe_arena_release_after() {
  // @@protoc_insertion_point(field_release:sonet.messaging.GetMessagesRequest.after)
  
  ::sonet::common::Timestamp* temp = _impl_.after_;
  _impl_.after_ = nullptr;
  return temp;
}
inline ::sonet::common::Timestamp* GetMessagesRequest::_internal_mutable_after() {
  
  if (_impl_.after_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Timestamp>(GetArenaForAllocation());
    _impl_.after_ = p;
  }
  return _impl_.after_;
}
inline ::sonet::common::Timestamp* GetMessagesRequest::mutable_after() {
  ::sonet::common::Timestamp* _msg = _internal_mutable_after();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.GetMessagesRequest.after)
  return _msg;
}
inline void GetMessagesRequest::set_allocated_after(::sonet::common::Timestamp* after) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.after_);
  }
  if (after) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(after));
    if (message_arena != submessage_arena) {
      after = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, after, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.after_ = after;
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.GetMessagesRequest.after)
}

// -------------------------------------------------------------------

// GetMessagesResponse

// .sonet.common.Status status = 1;
inline bool GetMessagesResponse::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool GetMessagesResponse::has_status() const {
  return _internal_has_status();
}
inline const ::sonet::common::Status& GetMessagesResponse::_internal_status() const {
  const ::sonet::common::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Status&>(
      ::sonet::common::_Status_default_instance_);
}
inline const ::sonet::common::Status& GetMessagesResponse::status() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.GetMessagesResponse.status)
  return _internal_status();
}
inline void GetMessagesResponse::unsafe_arena_set_allocated_status(
    ::sonet::common::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.messaging.GetMessagesResponse.status)
}
inline ::sonet::common::Status* GetMessagesResponse::release_status() {
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Status* GetMessagesResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:sonet.messaging.GetMessagesResponse.status)
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::sonet::common::Status* GetMessagesResponse::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::sonet::common::Status* GetMessagesResponse::mutable_status() {
  ::sonet::common::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.GetMessagesResponse.status)
  return _msg;
}
inline void GetMessagesResponse::set_allocated_status(::sonet::common::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.GetMessagesResponse.status)
}

// repeated .sonet.messaging.Message messages = 2;
inline int GetMessagesResponse::_internal_messages_size() const {
  return _impl_.messages_.size();
}
inline int GetMessagesResponse::messages_size() const {
  return _internal_messages_size();
}
inline void GetMessagesResponse::clear_messages() {
  _impl_.messages_.Clear();
}
inline ::sonet::messaging::Message* GetMessagesResponse::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:sonet.messaging.GetMessagesResponse.messages)
  return _impl_.messages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::messaging::Message >*
GetMessagesResponse::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:sonet.messaging.GetMessagesResponse.messages)
  return &_impl_.messages_;
}
inline const ::sonet::messaging::Message& GetMessagesResponse::_internal_messages(int index) const {
  return _impl_.messages_.Get(index);
}
inline const ::sonet::messaging::Message& GetMessagesResponse::messages(int index) const {
  // @@protoc_insertion_point(field_get:sonet.messaging.GetMessagesResponse.messages)
  return _internal_messages(index);
}
inline ::sonet::messaging::Message* GetMessagesResponse::_internal_add_messages() {
  return _impl_.messages_.Add();
}
inline ::sonet::messaging::Message* GetMessagesResponse::add_messages() {
  ::sonet::messaging::Message* _add = _internal_add_messages();
  // @@protoc_insertion_point(field_add:sonet.messaging.GetMessagesResponse.messages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::messaging::Message >&
GetMessagesResponse::messages() const {
  // @@protoc_insertion_point(field_list:sonet.messaging.GetMessagesResponse.messages)
  return _impl_.messages_;
}

// .sonet.common.PaginationResponse pagination = 3;
inline bool GetMessagesResponse::_internal_has_pagination() const {
  return this != internal_default_instance() && _impl_.pagination_ != nullptr;
}
inline bool GetMessagesResponse::has_pagination() const {
  return _internal_has_pagination();
}
inline const ::sonet::common::PaginationResponse& GetMessagesResponse::_internal_pagination() const {
  const ::sonet::common::PaginationResponse* p = _impl_.pagination_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::PaginationResponse&>(
      ::sonet::common::_PaginationResponse_default_instance_);
}
inline const ::sonet::common::PaginationResponse& GetMessagesResponse::pagination() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.GetMessagesResponse.pagination)
  return _internal_pagination();
}
inline void GetMessagesResponse::unsafe_arena_set_allocated_pagination(
    ::sonet::common::PaginationResponse* pagination) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  _impl_.pagination_ = pagination;
  if (pagination) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.messaging.GetMessagesResponse.pagination)
}
inline ::sonet::common::PaginationResponse* GetMessagesResponse::release_pagination() {
  
  ::sonet::common::PaginationResponse* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::PaginationResponse* GetMessagesResponse::unsafe_arena_release_pagination() {
  // @@protoc_insertion_point(field_release:sonet.messaging.GetMessagesResponse.pagination)
  
  ::sonet::common::PaginationResponse* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
  return temp;
}
inline ::sonet::common::PaginationResponse* GetMessagesResponse::_internal_mutable_pagination() {
  
  if (_impl_.pagination_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::PaginationResponse>(GetArenaForAllocation());
    _impl_.pagination_ = p;
  }
  return _impl_.pagination_;
}
inline ::sonet::common::PaginationResponse* GetMessagesResponse::mutable_pagination() {
  ::sonet::common::PaginationResponse* _msg = _internal_mutable_pagination();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.GetMessagesResponse.pagination)
  return _msg;
}
inline void GetMessagesResponse::set_allocated_pagination(::sonet::common::PaginationResponse* pagination) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  if (pagination) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pagination));
    if (message_arena != submessage_arena) {
      pagination = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pagination, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pagination_ = pagination;
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.GetMessagesResponse.pagination)
}

// -------------------------------------------------------------------

// CreateChatRequest

// string name = 1;
inline void CreateChatRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CreateChatRequest::name() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.CreateChatRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateChatRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.messaging.CreateChatRequest.name)
}
inline std::string* CreateChatRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.CreateChatRequest.name)
  return _s;
}
inline const std::string& CreateChatRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CreateChatRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateChatRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateChatRequest::release_name() {
  // @@protoc_insertion_point(field_release:sonet.messaging.CreateChatRequest.name)
  return _impl_.name_.Release();
}
inline void CreateChatRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.CreateChatRequest.name)
}

// string description = 2;
inline void CreateChatRequest::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& CreateChatRequest::description() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.CreateChatRequest.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateChatRequest::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.messaging.CreateChatRequest.description)
}
inline std::string* CreateChatRequest::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.CreateChatRequest.description)
  return _s;
}
inline const std::string& CreateChatRequest::_internal_description() const {
  return _impl_.description_.Get();
}
inline void CreateChatRequest::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateChatRequest::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateChatRequest::release_description() {
  // @@protoc_insertion_point(field_release:sonet.messaging.CreateChatRequest.description)
  return _impl_.description_.Release();
}
inline void CreateChatRequest::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.CreateChatRequest.description)
}

// .sonet.messaging.ChatType type = 3;
inline void CreateChatRequest::clear_type() {
  _impl_.type_ = 0;
}
inline ::sonet::messaging::ChatType CreateChatRequest::_internal_type() const {
  return static_cast< ::sonet::messaging::ChatType >(_impl_.type_);
}
inline ::sonet::messaging::ChatType CreateChatRequest::type() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.CreateChatRequest.type)
  return _internal_type();
}
inline void CreateChatRequest::_internal_set_type(::sonet::messaging::ChatType value) {
  
  _impl_.type_ = value;
}
inline void CreateChatRequest::set_type(::sonet::messaging::ChatType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sonet.messaging.CreateChatRequest.type)
}

// repeated string participant_ids = 4;
inline int CreateChatRequest::_internal_participant_ids_size() const {
  return _impl_.participant_ids_.size();
}
inline int CreateChatRequest::participant_ids_size() const {
  return _internal_participant_ids_size();
}
inline void CreateChatRequest::clear_participant_ids() {
  _impl_.participant_ids_.Clear();
}
inline std::string* CreateChatRequest::add_participant_ids() {
  std::string* _s = _internal_add_participant_ids();
  // @@protoc_insertion_point(field_add_mutable:sonet.messaging.CreateChatRequest.participant_ids)
  return _s;
}
inline const std::string& CreateChatRequest::_internal_participant_ids(int index) const {
  return _impl_.participant_ids_.Get(index);
}
inline const std::string& CreateChatRequest::participant_ids(int index) const {
  // @@protoc_insertion_point(field_get:sonet.messaging.CreateChatRequest.participant_ids)
  return _internal_participant_ids(index);
}
inline std::string* CreateChatRequest::mutable_participant_ids(int index) {
  // @@protoc_insertion_point(field_mutable:sonet.messaging.CreateChatRequest.participant_ids)
  return _impl_.participant_ids_.Mutable(index);
}
inline void CreateChatRequest::set_participant_ids(int index, const std::string& value) {
  _impl_.participant_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sonet.messaging.CreateChatRequest.participant_ids)
}
inline void CreateChatRequest::set_participant_ids(int index, std::string&& value) {
  _impl_.participant_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sonet.messaging.CreateChatRequest.participant_ids)
}
inline void CreateChatRequest::set_participant_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.participant_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sonet.messaging.CreateChatRequest.participant_ids)
}
inline void CreateChatRequest::set_participant_ids(int index, const char* value, size_t size) {
  _impl_.participant_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sonet.messaging.CreateChatRequest.participant_ids)
}
inline std::string* CreateChatRequest::_internal_add_participant_ids() {
  return _impl_.participant_ids_.Add();
}
inline void CreateChatRequest::add_participant_ids(const std::string& value) {
  _impl_.participant_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sonet.messaging.CreateChatRequest.participant_ids)
}
inline void CreateChatRequest::add_participant_ids(std::string&& value) {
  _impl_.participant_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sonet.messaging.CreateChatRequest.participant_ids)
}
inline void CreateChatRequest::add_participant_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.participant_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sonet.messaging.CreateChatRequest.participant_ids)
}
inline void CreateChatRequest::add_participant_ids(const char* value, size_t size) {
  _impl_.participant_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sonet.messaging.CreateChatRequest.participant_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CreateChatRequest::participant_ids() const {
  // @@protoc_insertion_point(field_list:sonet.messaging.CreateChatRequest.participant_ids)
  return _impl_.participant_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CreateChatRequest::mutable_participant_ids() {
  // @@protoc_insertion_point(field_mutable_list:sonet.messaging.CreateChatRequest.participant_ids)
  return &_impl_.participant_ids_;
}

// string avatar_url = 5;
inline void CreateChatRequest::clear_avatar_url() {
  _impl_.avatar_url_.ClearToEmpty();
}
inline const std::string& CreateChatRequest::avatar_url() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.CreateChatRequest.avatar_url)
  return _internal_avatar_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateChatRequest::set_avatar_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.avatar_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.messaging.CreateChatRequest.avatar_url)
}
inline std::string* CreateChatRequest::mutable_avatar_url() {
  std::string* _s = _internal_mutable_avatar_url();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.CreateChatRequest.avatar_url)
  return _s;
}
inline const std::string& CreateChatRequest::_internal_avatar_url() const {
  return _impl_.avatar_url_.Get();
}
inline void CreateChatRequest::_internal_set_avatar_url(const std::string& value) {
  
  _impl_.avatar_url_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateChatRequest::_internal_mutable_avatar_url() {
  
  return _impl_.avatar_url_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateChatRequest::release_avatar_url() {
  // @@protoc_insertion_point(field_release:sonet.messaging.CreateChatRequest.avatar_url)
  return _impl_.avatar_url_.Release();
}
inline void CreateChatRequest::set_allocated_avatar_url(std::string* avatar_url) {
  if (avatar_url != nullptr) {
    
  } else {
    
  }
  _impl_.avatar_url_.SetAllocated(avatar_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.avatar_url_.IsDefault()) {
    _impl_.avatar_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.CreateChatRequest.avatar_url)
}

// -------------------------------------------------------------------

// CreateChatResponse

// .sonet.common.Status status = 1;
inline bool CreateChatResponse::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool CreateChatResponse::has_status() const {
  return _internal_has_status();
}
inline const ::sonet::common::Status& CreateChatResponse::_internal_status() const {
  const ::sonet::common::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Status&>(
      ::sonet::common::_Status_default_instance_);
}
inline const ::sonet::common::Status& CreateChatResponse::status() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.CreateChatResponse.status)
  return _internal_status();
}
inline void CreateChatResponse::unsafe_arena_set_allocated_status(
    ::sonet::common::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.messaging.CreateChatResponse.status)
}
inline ::sonet::common::Status* CreateChatResponse::release_status() {
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Status* CreateChatResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:sonet.messaging.CreateChatResponse.status)
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::sonet::common::Status* CreateChatResponse::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::sonet::common::Status* CreateChatResponse::mutable_status() {
  ::sonet::common::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.CreateChatResponse.status)
  return _msg;
}
inline void CreateChatResponse::set_allocated_status(::sonet::common::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.CreateChatResponse.status)
}

// .sonet.messaging.Chat chat = 2;
inline bool CreateChatResponse::_internal_has_chat() const {
  return this != internal_default_instance() && _impl_.chat_ != nullptr;
}
inline bool CreateChatResponse::has_chat() const {
  return _internal_has_chat();
}
inline void CreateChatResponse::clear_chat() {
  if (GetArenaForAllocation() == nullptr && _impl_.chat_ != nullptr) {
    delete _impl_.chat_;
  }
  _impl_.chat_ = nullptr;
}
inline const ::sonet::messaging::Chat& CreateChatResponse::_internal_chat() const {
  const ::sonet::messaging::Chat* p = _impl_.chat_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::messaging::Chat&>(
      ::sonet::messaging::_Chat_default_instance_);
}
inline const ::sonet::messaging::Chat& CreateChatResponse::chat() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.CreateChatResponse.chat)
  return _internal_chat();
}
inline void CreateChatResponse::unsafe_arena_set_allocated_chat(
    ::sonet::messaging::Chat* chat) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chat_);
  }
  _impl_.chat_ = chat;
  if (chat) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.messaging.CreateChatResponse.chat)
}
inline ::sonet::messaging::Chat* CreateChatResponse::release_chat() {
  
  ::sonet::messaging::Chat* temp = _impl_.chat_;
  _impl_.chat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::messaging::Chat* CreateChatResponse::unsafe_arena_release_chat() {
  // @@protoc_insertion_point(field_release:sonet.messaging.CreateChatResponse.chat)
  
  ::sonet::messaging::Chat* temp = _impl_.chat_;
  _impl_.chat_ = nullptr;
  return temp;
}
inline ::sonet::messaging::Chat* CreateChatResponse::_internal_mutable_chat() {
  
  if (_impl_.chat_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::messaging::Chat>(GetArenaForAllocation());
    _impl_.chat_ = p;
  }
  return _impl_.chat_;
}
inline ::sonet::messaging::Chat* CreateChatResponse::mutable_chat() {
  ::sonet::messaging::Chat* _msg = _internal_mutable_chat();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.CreateChatResponse.chat)
  return _msg;
}
inline void CreateChatResponse::set_allocated_chat(::sonet::messaging::Chat* chat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.chat_;
  }
  if (chat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(chat);
    if (message_arena != submessage_arena) {
      chat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chat, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.chat_ = chat;
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.CreateChatResponse.chat)
}

// -------------------------------------------------------------------

// GetChatsRequest

// string user_id = 1;
inline void GetChatsRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& GetChatsRequest::user_id() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.GetChatsRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetChatsRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.messaging.GetChatsRequest.user_id)
}
inline std::string* GetChatsRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.GetChatsRequest.user_id)
  return _s;
}
inline const std::string& GetChatsRequest::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void GetChatsRequest::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetChatsRequest::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetChatsRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:sonet.messaging.GetChatsRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void GetChatsRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.GetChatsRequest.user_id)
}

// .sonet.messaging.ChatType type = 2;
inline void GetChatsRequest::clear_type() {
  _impl_.type_ = 0;
}
inline ::sonet::messaging::ChatType GetChatsRequest::_internal_type() const {
  return static_cast< ::sonet::messaging::ChatType >(_impl_.type_);
}
inline ::sonet::messaging::ChatType GetChatsRequest::type() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.GetChatsRequest.type)
  return _internal_type();
}
inline void GetChatsRequest::_internal_set_type(::sonet::messaging::ChatType value) {
  
  _impl_.type_ = value;
}
inline void GetChatsRequest::set_type(::sonet::messaging::ChatType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sonet.messaging.GetChatsRequest.type)
}

// .sonet.common.PaginationRequest pagination = 3;
inline bool GetChatsRequest::_internal_has_pagination() const {
  return this != internal_default_instance() && _impl_.pagination_ != nullptr;
}
inline bool GetChatsRequest::has_pagination() const {
  return _internal_has_pagination();
}
inline const ::sonet::common::PaginationRequest& GetChatsRequest::_internal_pagination() const {
  const ::sonet::common::PaginationRequest* p = _impl_.pagination_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::PaginationRequest&>(
      ::sonet::common::_PaginationRequest_default_instance_);
}
inline const ::sonet::common::PaginationRequest& GetChatsRequest::pagination() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.GetChatsRequest.pagination)
  return _internal_pagination();
}
inline void GetChatsRequest::unsafe_arena_set_allocated_pagination(
    ::sonet::common::PaginationRequest* pagination) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  _impl_.pagination_ = pagination;
  if (pagination) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.messaging.GetChatsRequest.pagination)
}
inline ::sonet::common::PaginationRequest* GetChatsRequest::release_pagination() {
  
  ::sonet::common::PaginationRequest* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::PaginationRequest* GetChatsRequest::unsafe_arena_release_pagination() {
  // @@protoc_insertion_point(field_release:sonet.messaging.GetChatsRequest.pagination)
  
  ::sonet::common::PaginationRequest* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
  return temp;
}
inline ::sonet::common::PaginationRequest* GetChatsRequest::_internal_mutable_pagination() {
  
  if (_impl_.pagination_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::PaginationRequest>(GetArenaForAllocation());
    _impl_.pagination_ = p;
  }
  return _impl_.pagination_;
}
inline ::sonet::common::PaginationRequest* GetChatsRequest::mutable_pagination() {
  ::sonet::common::PaginationRequest* _msg = _internal_mutable_pagination();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.GetChatsRequest.pagination)
  return _msg;
}
inline void GetChatsRequest::set_allocated_pagination(::sonet::common::PaginationRequest* pagination) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  if (pagination) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pagination));
    if (message_arena != submessage_arena) {
      pagination = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pagination, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pagination_ = pagination;
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.GetChatsRequest.pagination)
}

// -------------------------------------------------------------------

// GetChatsResponse

// .sonet.common.Status status = 1;
inline bool GetChatsResponse::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool GetChatsResponse::has_status() const {
  return _internal_has_status();
}
inline const ::sonet::common::Status& GetChatsResponse::_internal_status() const {
  const ::sonet::common::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Status&>(
      ::sonet::common::_Status_default_instance_);
}
inline const ::sonet::common::Status& GetChatsResponse::status() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.GetChatsResponse.status)
  return _internal_status();
}
inline void GetChatsResponse::unsafe_arena_set_allocated_status(
    ::sonet::common::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.messaging.GetChatsResponse.status)
}
inline ::sonet::common::Status* GetChatsResponse::release_status() {
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Status* GetChatsResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:sonet.messaging.GetChatsResponse.status)
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::sonet::common::Status* GetChatsResponse::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::sonet::common::Status* GetChatsResponse::mutable_status() {
  ::sonet::common::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.GetChatsResponse.status)
  return _msg;
}
inline void GetChatsResponse::set_allocated_status(::sonet::common::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.GetChatsResponse.status)
}

// repeated .sonet.messaging.Chat chats = 2;
inline int GetChatsResponse::_internal_chats_size() const {
  return _impl_.chats_.size();
}
inline int GetChatsResponse::chats_size() const {
  return _internal_chats_size();
}
inline void GetChatsResponse::clear_chats() {
  _impl_.chats_.Clear();
}
inline ::sonet::messaging::Chat* GetChatsResponse::mutable_chats(int index) {
  // @@protoc_insertion_point(field_mutable:sonet.messaging.GetChatsResponse.chats)
  return _impl_.chats_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::messaging::Chat >*
GetChatsResponse::mutable_chats() {
  // @@protoc_insertion_point(field_mutable_list:sonet.messaging.GetChatsResponse.chats)
  return &_impl_.chats_;
}
inline const ::sonet::messaging::Chat& GetChatsResponse::_internal_chats(int index) const {
  return _impl_.chats_.Get(index);
}
inline const ::sonet::messaging::Chat& GetChatsResponse::chats(int index) const {
  // @@protoc_insertion_point(field_get:sonet.messaging.GetChatsResponse.chats)
  return _internal_chats(index);
}
inline ::sonet::messaging::Chat* GetChatsResponse::_internal_add_chats() {
  return _impl_.chats_.Add();
}
inline ::sonet::messaging::Chat* GetChatsResponse::add_chats() {
  ::sonet::messaging::Chat* _add = _internal_add_chats();
  // @@protoc_insertion_point(field_add:sonet.messaging.GetChatsResponse.chats)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::messaging::Chat >&
GetChatsResponse::chats() const {
  // @@protoc_insertion_point(field_list:sonet.messaging.GetChatsResponse.chats)
  return _impl_.chats_;
}

// .sonet.common.PaginationResponse pagination = 3;
inline bool GetChatsResponse::_internal_has_pagination() const {
  return this != internal_default_instance() && _impl_.pagination_ != nullptr;
}
inline bool GetChatsResponse::has_pagination() const {
  return _internal_has_pagination();
}
inline const ::sonet::common::PaginationResponse& GetChatsResponse::_internal_pagination() const {
  const ::sonet::common::PaginationResponse* p = _impl_.pagination_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::PaginationResponse&>(
      ::sonet::common::_PaginationResponse_default_instance_);
}
inline const ::sonet::common::PaginationResponse& GetChatsResponse::pagination() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.GetChatsResponse.pagination)
  return _internal_pagination();
}
inline void GetChatsResponse::unsafe_arena_set_allocated_pagination(
    ::sonet::common::PaginationResponse* pagination) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  _impl_.pagination_ = pagination;
  if (pagination) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.messaging.GetChatsResponse.pagination)
}
inline ::sonet::common::PaginationResponse* GetChatsResponse::release_pagination() {
  
  ::sonet::common::PaginationResponse* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::PaginationResponse* GetChatsResponse::unsafe_arena_release_pagination() {
  // @@protoc_insertion_point(field_release:sonet.messaging.GetChatsResponse.pagination)
  
  ::sonet::common::PaginationResponse* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
  return temp;
}
inline ::sonet::common::PaginationResponse* GetChatsResponse::_internal_mutable_pagination() {
  
  if (_impl_.pagination_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::PaginationResponse>(GetArenaForAllocation());
    _impl_.pagination_ = p;
  }
  return _impl_.pagination_;
}
inline ::sonet::common::PaginationResponse* GetChatsResponse::mutable_pagination() {
  ::sonet::common::PaginationResponse* _msg = _internal_mutable_pagination();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.GetChatsResponse.pagination)
  return _msg;
}
inline void GetChatsResponse::set_allocated_pagination(::sonet::common::PaginationResponse* pagination) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  if (pagination) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pagination));
    if (message_arena != submessage_arena) {
      pagination = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pagination, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pagination_ = pagination;
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.GetChatsResponse.pagination)
}

// -------------------------------------------------------------------

// UpdateMessageStatusRequest

// string message_id = 1;
inline void UpdateMessageStatusRequest::clear_message_id() {
  _impl_.message_id_.ClearToEmpty();
}
inline const std::string& UpdateMessageStatusRequest::message_id() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.UpdateMessageStatusRequest.message_id)
  return _internal_message_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateMessageStatusRequest::set_message_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.messaging.UpdateMessageStatusRequest.message_id)
}
inline std::string* UpdateMessageStatusRequest::mutable_message_id() {
  std::string* _s = _internal_mutable_message_id();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.UpdateMessageStatusRequest.message_id)
  return _s;
}
inline const std::string& UpdateMessageStatusRequest::_internal_message_id() const {
  return _impl_.message_id_.Get();
}
inline void UpdateMessageStatusRequest::_internal_set_message_id(const std::string& value) {
  
  _impl_.message_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateMessageStatusRequest::_internal_mutable_message_id() {
  
  return _impl_.message_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateMessageStatusRequest::release_message_id() {
  // @@protoc_insertion_point(field_release:sonet.messaging.UpdateMessageStatusRequest.message_id)
  return _impl_.message_id_.Release();
}
inline void UpdateMessageStatusRequest::set_allocated_message_id(std::string* message_id) {
  if (message_id != nullptr) {
    
  } else {
    
  }
  _impl_.message_id_.SetAllocated(message_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_id_.IsDefault()) {
    _impl_.message_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.UpdateMessageStatusRequest.message_id)
}

// .sonet.messaging.MessageStatus status = 2;
inline void UpdateMessageStatusRequest::clear_status() {
  _impl_.status_ = 0;
}
inline ::sonet::messaging::MessageStatus UpdateMessageStatusRequest::_internal_status() const {
  return static_cast< ::sonet::messaging::MessageStatus >(_impl_.status_);
}
inline ::sonet::messaging::MessageStatus UpdateMessageStatusRequest::status() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.UpdateMessageStatusRequest.status)
  return _internal_status();
}
inline void UpdateMessageStatusRequest::_internal_set_status(::sonet::messaging::MessageStatus value) {
  
  _impl_.status_ = value;
}
inline void UpdateMessageStatusRequest::set_status(::sonet::messaging::MessageStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:sonet.messaging.UpdateMessageStatusRequest.status)
}

// -------------------------------------------------------------------

// UpdateMessageStatusResponse

// .sonet.common.Status status = 1;
inline bool UpdateMessageStatusResponse::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool UpdateMessageStatusResponse::has_status() const {
  return _internal_has_status();
}
inline const ::sonet::common::Status& UpdateMessageStatusResponse::_internal_status() const {
  const ::sonet::common::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Status&>(
      ::sonet::common::_Status_default_instance_);
}
inline const ::sonet::common::Status& UpdateMessageStatusResponse::status() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.UpdateMessageStatusResponse.status)
  return _internal_status();
}
inline void UpdateMessageStatusResponse::unsafe_arena_set_allocated_status(
    ::sonet::common::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.messaging.UpdateMessageStatusResponse.status)
}
inline ::sonet::common::Status* UpdateMessageStatusResponse::release_status() {
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Status* UpdateMessageStatusResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:sonet.messaging.UpdateMessageStatusResponse.status)
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::sonet::common::Status* UpdateMessageStatusResponse::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::sonet::common::Status* UpdateMessageStatusResponse::mutable_status() {
  ::sonet::common::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.UpdateMessageStatusResponse.status)
  return _msg;
}
inline void UpdateMessageStatusResponse::set_allocated_status(::sonet::common::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.UpdateMessageStatusResponse.status)
}

// -------------------------------------------------------------------

// SearchMessagesRequest

// string query = 1;
inline void SearchMessagesRequest::clear_query() {
  _impl_.query_.ClearToEmpty();
}
inline const std::string& SearchMessagesRequest::query() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.SearchMessagesRequest.query)
  return _internal_query();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SearchMessagesRequest::set_query(ArgT0&& arg0, ArgT... args) {
 
 _impl_.query_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.messaging.SearchMessagesRequest.query)
}
inline std::string* SearchMessagesRequest::mutable_query() {
  std::string* _s = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.SearchMessagesRequest.query)
  return _s;
}
inline const std::string& SearchMessagesRequest::_internal_query() const {
  return _impl_.query_.Get();
}
inline void SearchMessagesRequest::_internal_set_query(const std::string& value) {
  
  _impl_.query_.Set(value, GetArenaForAllocation());
}
inline std::string* SearchMessagesRequest::_internal_mutable_query() {
  
  return _impl_.query_.Mutable(GetArenaForAllocation());
}
inline std::string* SearchMessagesRequest::release_query() {
  // @@protoc_insertion_point(field_release:sonet.messaging.SearchMessagesRequest.query)
  return _impl_.query_.Release();
}
inline void SearchMessagesRequest::set_allocated_query(std::string* query) {
  if (query != nullptr) {
    
  } else {
    
  }
  _impl_.query_.SetAllocated(query, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.query_.IsDefault()) {
    _impl_.query_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.SearchMessagesRequest.query)
}

// string chat_id = 2;
inline void SearchMessagesRequest::clear_chat_id() {
  _impl_.chat_id_.ClearToEmpty();
}
inline const std::string& SearchMessagesRequest::chat_id() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.SearchMessagesRequest.chat_id)
  return _internal_chat_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SearchMessagesRequest::set_chat_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.chat_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.messaging.SearchMessagesRequest.chat_id)
}
inline std::string* SearchMessagesRequest::mutable_chat_id() {
  std::string* _s = _internal_mutable_chat_id();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.SearchMessagesRequest.chat_id)
  return _s;
}
inline const std::string& SearchMessagesRequest::_internal_chat_id() const {
  return _impl_.chat_id_.Get();
}
inline void SearchMessagesRequest::_internal_set_chat_id(const std::string& value) {
  
  _impl_.chat_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SearchMessagesRequest::_internal_mutable_chat_id() {
  
  return _impl_.chat_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SearchMessagesRequest::release_chat_id() {
  // @@protoc_insertion_point(field_release:sonet.messaging.SearchMessagesRequest.chat_id)
  return _impl_.chat_id_.Release();
}
inline void SearchMessagesRequest::set_allocated_chat_id(std::string* chat_id) {
  if (chat_id != nullptr) {
    
  } else {
    
  }
  _impl_.chat_id_.SetAllocated(chat_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chat_id_.IsDefault()) {
    _impl_.chat_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.SearchMessagesRequest.chat_id)
}

// string user_id = 3;
inline void SearchMessagesRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& SearchMessagesRequest::user_id() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.SearchMessagesRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SearchMessagesRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.messaging.SearchMessagesRequest.user_id)
}
inline std::string* SearchMessagesRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.SearchMessagesRequest.user_id)
  return _s;
}
inline const std::string& SearchMessagesRequest::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void SearchMessagesRequest::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SearchMessagesRequest::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SearchMessagesRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:sonet.messaging.SearchMessagesRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void SearchMessagesRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.SearchMessagesRequest.user_id)
}

// .sonet.messaging.MessageType type = 4;
inline void SearchMessagesRequest::clear_type() {
  _impl_.type_ = 0;
}
inline ::sonet::messaging::MessageType SearchMessagesRequest::_internal_type() const {
  return static_cast< ::sonet::messaging::MessageType >(_impl_.type_);
}
inline ::sonet::messaging::MessageType SearchMessagesRequest::type() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.SearchMessagesRequest.type)
  return _internal_type();
}
inline void SearchMessagesRequest::_internal_set_type(::sonet::messaging::MessageType value) {
  
  _impl_.type_ = value;
}
inline void SearchMessagesRequest::set_type(::sonet::messaging::MessageType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sonet.messaging.SearchMessagesRequest.type)
}

// .sonet.common.PaginationRequest pagination = 5;
inline bool SearchMessagesRequest::_internal_has_pagination() const {
  return this != internal_default_instance() && _impl_.pagination_ != nullptr;
}
inline bool SearchMessagesRequest::has_pagination() const {
  return _internal_has_pagination();
}
inline const ::sonet::common::PaginationRequest& SearchMessagesRequest::_internal_pagination() const {
  const ::sonet::common::PaginationRequest* p = _impl_.pagination_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::PaginationRequest&>(
      ::sonet::common::_PaginationRequest_default_instance_);
}
inline const ::sonet::common::PaginationRequest& SearchMessagesRequest::pagination() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.SearchMessagesRequest.pagination)
  return _internal_pagination();
}
inline void SearchMessagesRequest::unsafe_arena_set_allocated_pagination(
    ::sonet::common::PaginationRequest* pagination) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  _impl_.pagination_ = pagination;
  if (pagination) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.messaging.SearchMessagesRequest.pagination)
}
inline ::sonet::common::PaginationRequest* SearchMessagesRequest::release_pagination() {
  
  ::sonet::common::PaginationRequest* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::PaginationRequest* SearchMessagesRequest::unsafe_arena_release_pagination() {
  // @@protoc_insertion_point(field_release:sonet.messaging.SearchMessagesRequest.pagination)
  
  ::sonet::common::PaginationRequest* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
  return temp;
}
inline ::sonet::common::PaginationRequest* SearchMessagesRequest::_internal_mutable_pagination() {
  
  if (_impl_.pagination_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::PaginationRequest>(GetArenaForAllocation());
    _impl_.pagination_ = p;
  }
  return _impl_.pagination_;
}
inline ::sonet::common::PaginationRequest* SearchMessagesRequest::mutable_pagination() {
  ::sonet::common::PaginationRequest* _msg = _internal_mutable_pagination();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.SearchMessagesRequest.pagination)
  return _msg;
}
inline void SearchMessagesRequest::set_allocated_pagination(::sonet::common::PaginationRequest* pagination) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  if (pagination) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pagination));
    if (message_arena != submessage_arena) {
      pagination = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pagination, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pagination_ = pagination;
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.SearchMessagesRequest.pagination)
}

// -------------------------------------------------------------------

// SearchMessagesResponse

// .sonet.common.Status status = 1;
inline bool SearchMessagesResponse::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool SearchMessagesResponse::has_status() const {
  return _internal_has_status();
}
inline const ::sonet::common::Status& SearchMessagesResponse::_internal_status() const {
  const ::sonet::common::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Status&>(
      ::sonet::common::_Status_default_instance_);
}
inline const ::sonet::common::Status& SearchMessagesResponse::status() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.SearchMessagesResponse.status)
  return _internal_status();
}
inline void SearchMessagesResponse::unsafe_arena_set_allocated_status(
    ::sonet::common::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.messaging.SearchMessagesResponse.status)
}
inline ::sonet::common::Status* SearchMessagesResponse::release_status() {
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Status* SearchMessagesResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:sonet.messaging.SearchMessagesResponse.status)
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::sonet::common::Status* SearchMessagesResponse::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::sonet::common::Status* SearchMessagesResponse::mutable_status() {
  ::sonet::common::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.SearchMessagesResponse.status)
  return _msg;
}
inline void SearchMessagesResponse::set_allocated_status(::sonet::common::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.SearchMessagesResponse.status)
}

// repeated .sonet.messaging.Message messages = 2;
inline int SearchMessagesResponse::_internal_messages_size() const {
  return _impl_.messages_.size();
}
inline int SearchMessagesResponse::messages_size() const {
  return _internal_messages_size();
}
inline void SearchMessagesResponse::clear_messages() {
  _impl_.messages_.Clear();
}
inline ::sonet::messaging::Message* SearchMessagesResponse::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:sonet.messaging.SearchMessagesResponse.messages)
  return _impl_.messages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::messaging::Message >*
SearchMessagesResponse::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:sonet.messaging.SearchMessagesResponse.messages)
  return &_impl_.messages_;
}
inline const ::sonet::messaging::Message& SearchMessagesResponse::_internal_messages(int index) const {
  return _impl_.messages_.Get(index);
}
inline const ::sonet::messaging::Message& SearchMessagesResponse::messages(int index) const {
  // @@protoc_insertion_point(field_get:sonet.messaging.SearchMessagesResponse.messages)
  return _internal_messages(index);
}
inline ::sonet::messaging::Message* SearchMessagesResponse::_internal_add_messages() {
  return _impl_.messages_.Add();
}
inline ::sonet::messaging::Message* SearchMessagesResponse::add_messages() {
  ::sonet::messaging::Message* _add = _internal_add_messages();
  // @@protoc_insertion_point(field_add:sonet.messaging.SearchMessagesResponse.messages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sonet::messaging::Message >&
SearchMessagesResponse::messages() const {
  // @@protoc_insertion_point(field_list:sonet.messaging.SearchMessagesResponse.messages)
  return _impl_.messages_;
}

// .sonet.common.PaginationResponse pagination = 3;
inline bool SearchMessagesResponse::_internal_has_pagination() const {
  return this != internal_default_instance() && _impl_.pagination_ != nullptr;
}
inline bool SearchMessagesResponse::has_pagination() const {
  return _internal_has_pagination();
}
inline const ::sonet::common::PaginationResponse& SearchMessagesResponse::_internal_pagination() const {
  const ::sonet::common::PaginationResponse* p = _impl_.pagination_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::PaginationResponse&>(
      ::sonet::common::_PaginationResponse_default_instance_);
}
inline const ::sonet::common::PaginationResponse& SearchMessagesResponse::pagination() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.SearchMessagesResponse.pagination)
  return _internal_pagination();
}
inline void SearchMessagesResponse::unsafe_arena_set_allocated_pagination(
    ::sonet::common::PaginationResponse* pagination) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  _impl_.pagination_ = pagination;
  if (pagination) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.messaging.SearchMessagesResponse.pagination)
}
inline ::sonet::common::PaginationResponse* SearchMessagesResponse::release_pagination() {
  
  ::sonet::common::PaginationResponse* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::PaginationResponse* SearchMessagesResponse::unsafe_arena_release_pagination() {
  // @@protoc_insertion_point(field_release:sonet.messaging.SearchMessagesResponse.pagination)
  
  ::sonet::common::PaginationResponse* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
  return temp;
}
inline ::sonet::common::PaginationResponse* SearchMessagesResponse::_internal_mutable_pagination() {
  
  if (_impl_.pagination_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::PaginationResponse>(GetArenaForAllocation());
    _impl_.pagination_ = p;
  }
  return _impl_.pagination_;
}
inline ::sonet::common::PaginationResponse* SearchMessagesResponse::mutable_pagination() {
  ::sonet::common::PaginationResponse* _msg = _internal_mutable_pagination();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.SearchMessagesResponse.pagination)
  return _msg;
}
inline void SearchMessagesResponse::set_allocated_pagination(::sonet::common::PaginationResponse* pagination) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  if (pagination) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pagination));
    if (message_arena != submessage_arena) {
      pagination = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pagination, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pagination_ = pagination;
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.SearchMessagesResponse.pagination)
}

// -------------------------------------------------------------------

// UploadAttachmentRequest

// string filename = 1;
inline void UploadAttachmentRequest::clear_filename() {
  _impl_.filename_.ClearToEmpty();
}
inline const std::string& UploadAttachmentRequest::filename() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.UploadAttachmentRequest.filename)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UploadAttachmentRequest::set_filename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.messaging.UploadAttachmentRequest.filename)
}
inline std::string* UploadAttachmentRequest::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.UploadAttachmentRequest.filename)
  return _s;
}
inline const std::string& UploadAttachmentRequest::_internal_filename() const {
  return _impl_.filename_.Get();
}
inline void UploadAttachmentRequest::_internal_set_filename(const std::string& value) {
  
  _impl_.filename_.Set(value, GetArenaForAllocation());
}
inline std::string* UploadAttachmentRequest::_internal_mutable_filename() {
  
  return _impl_.filename_.Mutable(GetArenaForAllocation());
}
inline std::string* UploadAttachmentRequest::release_filename() {
  // @@protoc_insertion_point(field_release:sonet.messaging.UploadAttachmentRequest.filename)
  return _impl_.filename_.Release();
}
inline void UploadAttachmentRequest::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    
  } else {
    
  }
  _impl_.filename_.SetAllocated(filename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.UploadAttachmentRequest.filename)
}

// string content_type = 2;
inline void UploadAttachmentRequest::clear_content_type() {
  _impl_.content_type_.ClearToEmpty();
}
inline const std::string& UploadAttachmentRequest::content_type() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.UploadAttachmentRequest.content_type)
  return _internal_content_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UploadAttachmentRequest::set_content_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.messaging.UploadAttachmentRequest.content_type)
}
inline std::string* UploadAttachmentRequest::mutable_content_type() {
  std::string* _s = _internal_mutable_content_type();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.UploadAttachmentRequest.content_type)
  return _s;
}
inline const std::string& UploadAttachmentRequest::_internal_content_type() const {
  return _impl_.content_type_.Get();
}
inline void UploadAttachmentRequest::_internal_set_content_type(const std::string& value) {
  
  _impl_.content_type_.Set(value, GetArenaForAllocation());
}
inline std::string* UploadAttachmentRequest::_internal_mutable_content_type() {
  
  return _impl_.content_type_.Mutable(GetArenaForAllocation());
}
inline std::string* UploadAttachmentRequest::release_content_type() {
  // @@protoc_insertion_point(field_release:sonet.messaging.UploadAttachmentRequest.content_type)
  return _impl_.content_type_.Release();
}
inline void UploadAttachmentRequest::set_allocated_content_type(std::string* content_type) {
  if (content_type != nullptr) {
    
  } else {
    
  }
  _impl_.content_type_.SetAllocated(content_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_type_.IsDefault()) {
    _impl_.content_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.UploadAttachmentRequest.content_type)
}

// bytes data = 3;
inline void UploadAttachmentRequest::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& UploadAttachmentRequest::data() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.UploadAttachmentRequest.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UploadAttachmentRequest::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.messaging.UploadAttachmentRequest.data)
}
inline std::string* UploadAttachmentRequest::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.UploadAttachmentRequest.data)
  return _s;
}
inline const std::string& UploadAttachmentRequest::_internal_data() const {
  return _impl_.data_.Get();
}
inline void UploadAttachmentRequest::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* UploadAttachmentRequest::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* UploadAttachmentRequest::release_data() {
  // @@protoc_insertion_point(field_release:sonet.messaging.UploadAttachmentRequest.data)
  return _impl_.data_.Release();
}
inline void UploadAttachmentRequest::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.UploadAttachmentRequest.data)
}

// -------------------------------------------------------------------

// UploadAttachmentResponse

// .sonet.common.Status status = 1;
inline bool UploadAttachmentResponse::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool UploadAttachmentResponse::has_status() const {
  return _internal_has_status();
}
inline const ::sonet::common::Status& UploadAttachmentResponse::_internal_status() const {
  const ::sonet::common::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Status&>(
      ::sonet::common::_Status_default_instance_);
}
inline const ::sonet::common::Status& UploadAttachmentResponse::status() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.UploadAttachmentResponse.status)
  return _internal_status();
}
inline void UploadAttachmentResponse::unsafe_arena_set_allocated_status(
    ::sonet::common::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.messaging.UploadAttachmentResponse.status)
}
inline ::sonet::common::Status* UploadAttachmentResponse::release_status() {
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Status* UploadAttachmentResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:sonet.messaging.UploadAttachmentResponse.status)
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::sonet::common::Status* UploadAttachmentResponse::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::sonet::common::Status* UploadAttachmentResponse::mutable_status() {
  ::sonet::common::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.UploadAttachmentResponse.status)
  return _msg;
}
inline void UploadAttachmentResponse::set_allocated_status(::sonet::common::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.UploadAttachmentResponse.status)
}

// .sonet.messaging.Attachment attachment = 2;
inline bool UploadAttachmentResponse::_internal_has_attachment() const {
  return this != internal_default_instance() && _impl_.attachment_ != nullptr;
}
inline bool UploadAttachmentResponse::has_attachment() const {
  return _internal_has_attachment();
}
inline void UploadAttachmentResponse::clear_attachment() {
  if (GetArenaForAllocation() == nullptr && _impl_.attachment_ != nullptr) {
    delete _impl_.attachment_;
  }
  _impl_.attachment_ = nullptr;
}
inline const ::sonet::messaging::Attachment& UploadAttachmentResponse::_internal_attachment() const {
  const ::sonet::messaging::Attachment* p = _impl_.attachment_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::messaging::Attachment&>(
      ::sonet::messaging::_Attachment_default_instance_);
}
inline const ::sonet::messaging::Attachment& UploadAttachmentResponse::attachment() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.UploadAttachmentResponse.attachment)
  return _internal_attachment();
}
inline void UploadAttachmentResponse::unsafe_arena_set_allocated_attachment(
    ::sonet::messaging::Attachment* attachment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.attachment_);
  }
  _impl_.attachment_ = attachment;
  if (attachment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.messaging.UploadAttachmentResponse.attachment)
}
inline ::sonet::messaging::Attachment* UploadAttachmentResponse::release_attachment() {
  
  ::sonet::messaging::Attachment* temp = _impl_.attachment_;
  _impl_.attachment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::messaging::Attachment* UploadAttachmentResponse::unsafe_arena_release_attachment() {
  // @@protoc_insertion_point(field_release:sonet.messaging.UploadAttachmentResponse.attachment)
  
  ::sonet::messaging::Attachment* temp = _impl_.attachment_;
  _impl_.attachment_ = nullptr;
  return temp;
}
inline ::sonet::messaging::Attachment* UploadAttachmentResponse::_internal_mutable_attachment() {
  
  if (_impl_.attachment_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::messaging::Attachment>(GetArenaForAllocation());
    _impl_.attachment_ = p;
  }
  return _impl_.attachment_;
}
inline ::sonet::messaging::Attachment* UploadAttachmentResponse::mutable_attachment() {
  ::sonet::messaging::Attachment* _msg = _internal_mutable_attachment();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.UploadAttachmentResponse.attachment)
  return _msg;
}
inline void UploadAttachmentResponse::set_allocated_attachment(::sonet::messaging::Attachment* attachment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.attachment_;
  }
  if (attachment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(attachment);
    if (message_arena != submessage_arena) {
      attachment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attachment, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.attachment_ = attachment;
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.UploadAttachmentResponse.attachment)
}

// -------------------------------------------------------------------

// SetTypingRequest

// string chat_id = 1;
inline void SetTypingRequest::clear_chat_id() {
  _impl_.chat_id_.ClearToEmpty();
}
inline const std::string& SetTypingRequest::chat_id() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.SetTypingRequest.chat_id)
  return _internal_chat_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetTypingRequest::set_chat_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.chat_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sonet.messaging.SetTypingRequest.chat_id)
}
inline std::string* SetTypingRequest::mutable_chat_id() {
  std::string* _s = _internal_mutable_chat_id();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.SetTypingRequest.chat_id)
  return _s;
}
inline const std::string& SetTypingRequest::_internal_chat_id() const {
  return _impl_.chat_id_.Get();
}
inline void SetTypingRequest::_internal_set_chat_id(const std::string& value) {
  
  _impl_.chat_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SetTypingRequest::_internal_mutable_chat_id() {
  
  return _impl_.chat_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SetTypingRequest::release_chat_id() {
  // @@protoc_insertion_point(field_release:sonet.messaging.SetTypingRequest.chat_id)
  return _impl_.chat_id_.Release();
}
inline void SetTypingRequest::set_allocated_chat_id(std::string* chat_id) {
  if (chat_id != nullptr) {
    
  } else {
    
  }
  _impl_.chat_id_.SetAllocated(chat_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chat_id_.IsDefault()) {
    _impl_.chat_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.SetTypingRequest.chat_id)
}

// bool is_typing = 2;
inline void SetTypingRequest::clear_is_typing() {
  _impl_.is_typing_ = false;
}
inline bool SetTypingRequest::_internal_is_typing() const {
  return _impl_.is_typing_;
}
inline bool SetTypingRequest::is_typing() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.SetTypingRequest.is_typing)
  return _internal_is_typing();
}
inline void SetTypingRequest::_internal_set_is_typing(bool value) {
  
  _impl_.is_typing_ = value;
}
inline void SetTypingRequest::set_is_typing(bool value) {
  _internal_set_is_typing(value);
  // @@protoc_insertion_point(field_set:sonet.messaging.SetTypingRequest.is_typing)
}

// -------------------------------------------------------------------

// SetTypingResponse

// .sonet.common.Status status = 1;
inline bool SetTypingResponse::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool SetTypingResponse::has_status() const {
  return _internal_has_status();
}
inline const ::sonet::common::Status& SetTypingResponse::_internal_status() const {
  const ::sonet::common::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sonet::common::Status&>(
      ::sonet::common::_Status_default_instance_);
}
inline const ::sonet::common::Status& SetTypingResponse::status() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.SetTypingResponse.status)
  return _internal_status();
}
inline void SetTypingResponse::unsafe_arena_set_allocated_status(
    ::sonet::common::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.messaging.SetTypingResponse.status)
}
inline ::sonet::common::Status* SetTypingResponse::release_status() {
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sonet::common::Status* SetTypingResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:sonet.messaging.SetTypingResponse.status)
  
  ::sonet::common::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::sonet::common::Status* SetTypingResponse::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sonet::common::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::sonet::common::Status* SetTypingResponse::mutable_status() {
  ::sonet::common::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.SetTypingResponse.status)
  return _msg;
}
inline void SetTypingResponse::set_allocated_status(::sonet::common::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:sonet.messaging.SetTypingResponse.status)
}

// -------------------------------------------------------------------

// WebSocketMessage

// .sonet.messaging.Message new_message = 1;
inline bool WebSocketMessage::_internal_has_new_message() const {
  return payload_case() == kNewMessage;
}
inline bool WebSocketMessage::has_new_message() const {
  return _internal_has_new_message();
}
inline void WebSocketMessage::set_has_new_message() {
  _impl_._oneof_case_[0] = kNewMessage;
}
inline void WebSocketMessage::clear_new_message() {
  if (_internal_has_new_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.new_message_;
    }
    clear_has_payload();
  }
}
inline ::sonet::messaging::Message* WebSocketMessage::release_new_message() {
  // @@protoc_insertion_point(field_release:sonet.messaging.WebSocketMessage.new_message)
  if (_internal_has_new_message()) {
    clear_has_payload();
    ::sonet::messaging::Message* temp = _impl_.payload_.new_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.new_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sonet::messaging::Message& WebSocketMessage::_internal_new_message() const {
  return _internal_has_new_message()
      ? *_impl_.payload_.new_message_
      : reinterpret_cast< ::sonet::messaging::Message&>(::sonet::messaging::_Message_default_instance_);
}
inline const ::sonet::messaging::Message& WebSocketMessage::new_message() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.WebSocketMessage.new_message)
  return _internal_new_message();
}
inline ::sonet::messaging::Message* WebSocketMessage::unsafe_arena_release_new_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sonet.messaging.WebSocketMessage.new_message)
  if (_internal_has_new_message()) {
    clear_has_payload();
    ::sonet::messaging::Message* temp = _impl_.payload_.new_message_;
    _impl_.payload_.new_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WebSocketMessage::unsafe_arena_set_allocated_new_message(::sonet::messaging::Message* new_message) {
  clear_payload();
  if (new_message) {
    set_has_new_message();
    _impl_.payload_.new_message_ = new_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.messaging.WebSocketMessage.new_message)
}
inline ::sonet::messaging::Message* WebSocketMessage::_internal_mutable_new_message() {
  if (!_internal_has_new_message()) {
    clear_payload();
    set_has_new_message();
    _impl_.payload_.new_message_ = CreateMaybeMessage< ::sonet::messaging::Message >(GetArenaForAllocation());
  }
  return _impl_.payload_.new_message_;
}
inline ::sonet::messaging::Message* WebSocketMessage::mutable_new_message() {
  ::sonet::messaging::Message* _msg = _internal_mutable_new_message();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.WebSocketMessage.new_message)
  return _msg;
}

// .sonet.messaging.TypingIndicator typing = 2;
inline bool WebSocketMessage::_internal_has_typing() const {
  return payload_case() == kTyping;
}
inline bool WebSocketMessage::has_typing() const {
  return _internal_has_typing();
}
inline void WebSocketMessage::set_has_typing() {
  _impl_._oneof_case_[0] = kTyping;
}
inline void WebSocketMessage::clear_typing() {
  if (_internal_has_typing()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.typing_;
    }
    clear_has_payload();
  }
}
inline ::sonet::messaging::TypingIndicator* WebSocketMessage::release_typing() {
  // @@protoc_insertion_point(field_release:sonet.messaging.WebSocketMessage.typing)
  if (_internal_has_typing()) {
    clear_has_payload();
    ::sonet::messaging::TypingIndicator* temp = _impl_.payload_.typing_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.typing_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sonet::messaging::TypingIndicator& WebSocketMessage::_internal_typing() const {
  return _internal_has_typing()
      ? *_impl_.payload_.typing_
      : reinterpret_cast< ::sonet::messaging::TypingIndicator&>(::sonet::messaging::_TypingIndicator_default_instance_);
}
inline const ::sonet::messaging::TypingIndicator& WebSocketMessage::typing() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.WebSocketMessage.typing)
  return _internal_typing();
}
inline ::sonet::messaging::TypingIndicator* WebSocketMessage::unsafe_arena_release_typing() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sonet.messaging.WebSocketMessage.typing)
  if (_internal_has_typing()) {
    clear_has_payload();
    ::sonet::messaging::TypingIndicator* temp = _impl_.payload_.typing_;
    _impl_.payload_.typing_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WebSocketMessage::unsafe_arena_set_allocated_typing(::sonet::messaging::TypingIndicator* typing) {
  clear_payload();
  if (typing) {
    set_has_typing();
    _impl_.payload_.typing_ = typing;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.messaging.WebSocketMessage.typing)
}
inline ::sonet::messaging::TypingIndicator* WebSocketMessage::_internal_mutable_typing() {
  if (!_internal_has_typing()) {
    clear_payload();
    set_has_typing();
    _impl_.payload_.typing_ = CreateMaybeMessage< ::sonet::messaging::TypingIndicator >(GetArenaForAllocation());
  }
  return _impl_.payload_.typing_;
}
inline ::sonet::messaging::TypingIndicator* WebSocketMessage::mutable_typing() {
  ::sonet::messaging::TypingIndicator* _msg = _internal_mutable_typing();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.WebSocketMessage.typing)
  return _msg;
}

// .sonet.messaging.ReadReceipt read_receipt = 3;
inline bool WebSocketMessage::_internal_has_read_receipt() const {
  return payload_case() == kReadReceipt;
}
inline bool WebSocketMessage::has_read_receipt() const {
  return _internal_has_read_receipt();
}
inline void WebSocketMessage::set_has_read_receipt() {
  _impl_._oneof_case_[0] = kReadReceipt;
}
inline void WebSocketMessage::clear_read_receipt() {
  if (_internal_has_read_receipt()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.read_receipt_;
    }
    clear_has_payload();
  }
}
inline ::sonet::messaging::ReadReceipt* WebSocketMessage::release_read_receipt() {
  // @@protoc_insertion_point(field_release:sonet.messaging.WebSocketMessage.read_receipt)
  if (_internal_has_read_receipt()) {
    clear_has_payload();
    ::sonet::messaging::ReadReceipt* temp = _impl_.payload_.read_receipt_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.read_receipt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sonet::messaging::ReadReceipt& WebSocketMessage::_internal_read_receipt() const {
  return _internal_has_read_receipt()
      ? *_impl_.payload_.read_receipt_
      : reinterpret_cast< ::sonet::messaging::ReadReceipt&>(::sonet::messaging::_ReadReceipt_default_instance_);
}
inline const ::sonet::messaging::ReadReceipt& WebSocketMessage::read_receipt() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.WebSocketMessage.read_receipt)
  return _internal_read_receipt();
}
inline ::sonet::messaging::ReadReceipt* WebSocketMessage::unsafe_arena_release_read_receipt() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sonet.messaging.WebSocketMessage.read_receipt)
  if (_internal_has_read_receipt()) {
    clear_has_payload();
    ::sonet::messaging::ReadReceipt* temp = _impl_.payload_.read_receipt_;
    _impl_.payload_.read_receipt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WebSocketMessage::unsafe_arena_set_allocated_read_receipt(::sonet::messaging::ReadReceipt* read_receipt) {
  clear_payload();
  if (read_receipt) {
    set_has_read_receipt();
    _impl_.payload_.read_receipt_ = read_receipt;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sonet.messaging.WebSocketMessage.read_receipt)
}
inline ::sonet::messaging::ReadReceipt* WebSocketMessage::_internal_mutable_read_receipt() {
  if (!_internal_has_read_receipt()) {
    clear_payload();
    set_has_read_receipt();
    _impl_.payload_.read_receipt_ = CreateMaybeMessage< ::sonet::messaging::ReadReceipt >(GetArenaForAllocation());
  }
  return _impl_.payload_.read_receipt_;
}
inline ::sonet::messaging::ReadReceipt* WebSocketMessage::mutable_read_receipt() {
  ::sonet::messaging::ReadReceipt* _msg = _internal_mutable_read_receipt();
  // @@protoc_insertion_point(field_mutable:sonet.messaging.WebSocketMessage.read_receipt)
  return _msg;
}

// .sonet.messaging.MessageStatus message_status_update = 4;
inline bool WebSocketMessage::_internal_has_message_status_update() const {
  return payload_case() == kMessageStatusUpdate;
}
inline bool WebSocketMessage::has_message_status_update() const {
  return _internal_has_message_status_update();
}
inline void WebSocketMessage::set_has_message_status_update() {
  _impl_._oneof_case_[0] = kMessageStatusUpdate;
}
inline void WebSocketMessage::clear_message_status_update() {
  if (_internal_has_message_status_update()) {
    _impl_.payload_.message_status_update_ = 0;
    clear_has_payload();
  }
}
inline ::sonet::messaging::MessageStatus WebSocketMessage::_internal_message_status_update() const {
  if (_internal_has_message_status_update()) {
    return static_cast< ::sonet::messaging::MessageStatus >(_impl_.payload_.message_status_update_);
  }
  return static_cast< ::sonet::messaging::MessageStatus >(0);
}
inline ::sonet::messaging::MessageStatus WebSocketMessage::message_status_update() const {
  // @@protoc_insertion_point(field_get:sonet.messaging.WebSocketMessage.message_status_update)
  return _internal_message_status_update();
}
inline void WebSocketMessage::_internal_set_message_status_update(::sonet::messaging::MessageStatus value) {
  if (!_internal_has_message_status_update()) {
    clear_payload();
    set_has_message_status_update();
  }
  _impl_.payload_.message_status_update_ = value;
}
inline void WebSocketMessage::set_message_status_update(::sonet::messaging::MessageStatus value) {
  _internal_set_message_status_update(value);
  // @@protoc_insertion_point(field_set:sonet.messaging.WebSocketMessage.message_status_update)
}

inline bool WebSocketMessage::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void WebSocketMessage::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline WebSocketMessage::PayloadCase WebSocketMessage::payload_case() const {
  return WebSocketMessage::PayloadCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace messaging
}  // namespace sonet

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::sonet::messaging::MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sonet::messaging::MessageType>() {
  return ::sonet::messaging::MessageType_descriptor();
}
template <> struct is_proto_enum< ::sonet::messaging::MessageStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sonet::messaging::MessageStatus>() {
  return ::sonet::messaging::MessageStatus_descriptor();
}
template <> struct is_proto_enum< ::sonet::messaging::ChatType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sonet::messaging::ChatType>() {
  return ::sonet::messaging::ChatType_descriptor();
}
template <> struct is_proto_enum< ::sonet::messaging::EncryptionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sonet::messaging::EncryptionType>() {
  return ::sonet::messaging::EncryptionType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_services_2fmessaging_2eproto
